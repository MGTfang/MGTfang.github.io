{"meta":{"title":"青桥雨之木芳","subtitle":null,"description":null,"author":"Peng Fang","url":"https://www.haoming.fun","root":"/"},"pages":[],"posts":[{"title":"中止HTTP请求或文件上传的方法解析","slug":"中止HTTP请求或文件上传的方法解析","date":"2019-06-30T14:23:00.000Z","updated":"2019-06-30T14:24:17.437Z","comments":true,"path":"2019/06/30/中止HTTP请求或文件上传的方法解析/","link":"","permalink":"https://www.haoming.fun/2019/06/30/中止HTTP请求或文件上传的方法解析/","excerpt":"","text":"某些场景，比如切换TAB、关闭窗口或手动触发中止时，我们想取消正在执行中的HTTP请求，特别当上传大文件时候会有中止上传的需求。开始以为中断通信，当socket传输数据时比较好处理。后来一查原来ajax请求中也能处理。 先看用原生js如何中断http请求API：XMLHttpRequest.abort()如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。示例：12345678var xhr = new XMLHttpRequest(), method = \"GET\", url = \"https://developer.mozilla.org/\";xhr.open(method,url,true);xhr.send();xhr.abort(); 然后想到axios拦截器应该也能中断请求吧 Axios拦截器如何中止HTTP请求Axios能使用一个取消token来取消一个请求 Axios 取消token API 基于 JS可取消去异步操作的建议 可以使用CancelToken.source工厂来生成一个cancel token： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // handle error &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// cancel the request (the message parameter is optional)source.cancel('Operation canceled by the user.'); 注意，get请求的时候，cancelToken是放在第二个参数里；post的时候，cancelToken是放在第三个参数里。每次执行CancelToken.source()，就会返回一个包含新的“CancelToken”的对象。调用source.cancel()以后，实际执行的是以下函数： 12345678function cancel(message) &#123; if (token.reason) &#123; // Cancellation has already been requested return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason);&#125; 上面方法一旦resolvePromise以后，就会触发promise的then方法： 123456789101112if (config.cancelToken) &#123; // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; request.abort(); reject(cancel); // Clean up request request = null; &#125;); &#125; 实际上执行abort方法来中止请求，同时调用reject让外层的promise失败。 jQuery上传文件中执行取消jQuery通常上传文件会用到jquery.fileupload.js，那么用它上传文件的时候，怎么取消呢？同第一点那样可以通过XMLHttpRequest.abort()来取消，示例代码如下：123456789101112131415161718192021222324$( &apos;#fileUpload&apos; ).fileupload( &#123; dataType: &apos;json&apos;, add: function( e, data ) &#123; var abortBtn = $( &apos;&lt;a/&gt;&apos; ) .attr( &apos;href&apos;, &apos;javascript:void(0)&apos; ) .append( &apos;Abort&apos; ) .click( function() &#123; data.abort(); data.context.remove(); &#125; ); data.context = $( &apos;&lt;div/&gt;&apos; ) .appendTo( document.body ); data.context.append( $( &apos;&lt;p/&gt;&apos; ) ) .append( &apos;Uploading &apos; + data.files[0].name ) .append( abortBtn ); data.submit(); &#125;, done: function( e, data ) &#123; /* ... */ &#125; &#125;); 上面介绍了中止HTTP请求或文件上传的两种请情况。 参考文献https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort https://github.com/axios/axios#cancellation http://www.qiutianaimeili.com/html/page/2019/03/8grudzwvfmq.html https://stackoverflow.com/questions/26218571/how-to-add-a-cancel-upload-button-to-jquery-file-upload-basic-plugin","categories":[{"name":"前端","slug":"前端","permalink":"https://www.haoming.fun/categories/前端/"}],"tags":[{"name":"经验总结","slug":"经验总结","permalink":"https://www.haoming.fun/tags/经验总结/"}],"author":"Peng Fang"},{"title":"如何使用GraphQL,Koa和MongoDB建立强大的API","slug":"如何使用GraphQL-Koa和MongoDB建立强大的API","date":"2019-06-30T14:16:00.000Z","updated":"2019-06-30T14:21:43.229Z","comments":true,"path":"2019/06/30/如何使用GraphQL-Koa和MongoDB建立强大的API/","link":"","permalink":"https://www.haoming.fun/2019/06/30/如何使用GraphQL-Koa和MongoDB建立强大的API/","excerpt":"","text":"构建API是很有趣的，特别当你可以在项目中使用诸如koa、graphql和mongodb等技术的时候。 和Express一样，koa是一个Node框架，很多功能需要借助第三方中间件解决，由于其基于ES6 generator特性的异步流程控制，解决了”回调地狱”和麻烦的错误处理问题，大受开发者欢迎。Express采用callback来处理异步，Koa v1采用generator，Koa v2采用async/await。enerator和async/await使用同步的写法来处理异步，明显好于callback和promise，而async/await在语义化上又要比generator更强。 Koa Github 仓库Express Github 仓库 准备工作构建API的先决条件如下： 安装Node IDE，建议VS code 命令行终端 浏览器 如果具备了上述的条件，可以继续下面的工作了；如果没有的话，请安装它们。 打开终端，创建一个node项目，像这样：目前为止， 我们创建了项目目录，初始化一个新的node项目。接下来我们通过npm包来安装Koa、Mongo和GraphQL。首先安装koa： 1npm i koa 启动一个新的Koa服务非常简单。我们需要一个server.js文件，它的内容如下： 123456const Koa = require('koa');const app = new Koa();app.listen(9000);app.on('error', err =&gt; &#123; log.error('server error', err)&#125;); 用Node启动项目： 1node server.js GraphQL我们需要使用koa-mount和koa-graphql两个包来安装GraphQL，后者创建Graphql HTTP服务，前者将Koa应用挂载为中间件（挂载到某个路径上）,然后安装依赖包graphql 1npm i koa-mount koa-graphql graphql GraphQL需要传递初始的模式（schema）给GraphQL服务。下面创建一个：将Graphql schema放到graphql/schema.js里面。 1234567const &#123; buildSchema &#125; = require('graphql');const schema = buildSchema(` type Query &#123; hello: String &#125;`);module.exports = schema; 将Query类传给buildSchema函数，这里它的参数使用了模版字符串。现在我们能将初始的schema传给graphql服务了。 1234app.use(mount('/graphql', graphqlHTTP(&#123; schema: schema, graphiql: true&#125;))) 不要忘了导入koa-mount、koa-graphql，以及schema.js 123const mount = require('koa-mount');const graphqlHTTP = require('koa-graphql');const schema = require('https://www.haoming.fun/images/graphql/schema'); 通过node启动server.js以后，在浏览器地址栏访问localhost:9000/graphql最初的构建完成，但还不是很有用。我们还想通过 grahql API 来查询 MongoDB 保存的数据。 安装MongoDB为了使用GraphQL来读写数据，我们需要有个读写的来源，这就是MongoDB。下面介绍如何在Centos上安装MongoDB。 创建yum源文件vim /etc/yum.repos.d/mongodb-org-4.0.repo添加以下内容 123456[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc 使用 yum 安装MongoDByum install -y mongodb-org 配置MongoDBvim /etc/mongod.conf配置mongod.conf来开启远程连接： 把第30行bindIp: 127.0.0.1改为bindIp: 0.0.0.0 启动MongoDB服务systemctl start mongod服务器本地连接测试mongo --host 127.0.0.1 --port 27017 本地连接MongoDB需要开启防火墙访问策略： 另外附上：启用/停止/重启 MongoDB 服务的命令123systemctl start mongod.service systemctl stop mongod.service systemctl restart mongod.service 创建MongoDB用户创建数据库用户，可以参考MongoDB 用户权限管理 创建数据库在 MongoDB 中默认数据库是：test。 如果还没有创建过任何数据库，则集合/文档将存储在test数据库中。新建数据库可以参考怎么创建MongoDB数据库 数据库连接测试连接MongoDB的客户端很多，这里选择Robo 3T，新建MongoDB连接如下： 现在我们能使用Mongoose来和MongoDB配对。远程连接数据库的URL像这样： 1mongodb://$&#123;mongoAuth.user&#125;:$&#123;mongoAuth.pass&#125;@$&#123;ip&#125;:$&#123;port&#125;/$&#123;db&#125;&amp;authMechanism=SCRAM-SHA-256?authSource=admin 安装mongoose 1npm i mongoose 创建一个专门用来连接数据库的文件database.js 1234567891011121314const mongoose = require('mongoose');const initDB = () =&gt; &#123; mongoose.connect( 'mongodb://admin:password@47.99.xx.xx/test?authSource=admin&amp;authMechanism=SCRAM-SHA-256', &#123; useNewUrlParser: true &#125; ); mongoose.connection.once('open', () =&gt; &#123; console.log('connected to database'); &#125;);&#125;module.exports = initDB; 注意：MongoDB的连接字符串保证是能验证通过的。上面的代码块完成数据库连接的测试。我们需要将database.js引入到server.js，并调用initDB。server.js加入以下代码： 123const initDB = require('https://www.haoming.fun/images/database');initDB(); 如果以上的各个步骤都正确完成，控制台会打印“connected to databse”。 怎样可以不用每次修改代码以后，重新启动server呢？我们可以安装PM2来达到热加载的目的。先全局安装pm2包。 1npm install pm2 -g 再在package.json中添加启动脚本如下： 123\"scripts\": &#123; \"start\": \"pm2 start server.js\"&#125;, 执行yarn run start命令来启动我们的node服务。这样服务就在后台运行了，如果想杀掉进程，可以使用pm2 kill。现在我们不必一直重启我们的服务，pm2会自动刷新服务。 MongoDB 模型如果你以前使用过Mongo，你应该知道MongoDB让我们为数据创建模型。对于我们来说，这是一个很好的方法来构造数据的结构。创建一个models目录，下面创建一个文件gadget.js 1234567891011121314const mongoose = require('mongoose');const Schema = mongoose.Schema;/* 注意这里没有ID字段. 因为MongoDB会为所有Schema分配默认ID*/const GadgetSchema = new Schema(&#123; name: String, release_date: Date, by_company: String, price: Number,&#125;);module.exports = mongoose.model('Gadget', GadgetSchema); 接下来需要在数据库添加一个集合和一次测试数据，对应的集合名必须是复数，这里用gadgets. GraphQL 查询GrpahQL需要我们创建类型，可以将它类比为计算机指令一样。https://www.haoming.fun/images/graphql/gadgetType.js 1234567891011const graphql = require('graphql');const &#123; GraphQLObjectType, GraphQLString &#125; = graphql;const GadgetType = new GraphQLObjectType(&#123; name: 'Gadget', fields: () =&gt; (&#123; &#125;)&#125;);module.exports = GadgetType; 我们创建了一个graphql类型，然后再具体定义给定类型内部的属性。 1234567891011121314const graphql = require('graphql');const &#123; GraphQLObjectType, GraphQLString &#125; = graphql;const GadgetType = new GraphQLObjectType(&#123; name: 'Gadget', fields: () =&gt; (&#123; id: &#123; type: GraphQLString &#125;, name: &#123; type: GraphQLString &#125;, release_date: &#123; type: GraphQLString &#125;, by_company: &#123; type: GraphQLString &#125;, price: &#123; type: GraphQLString &#125; &#125;)&#125;);module.exports = GadgetType; 注意将GraphQLObjectType和GraphQLObjectType从graphql解构出来，它们是graphql的基本类型。创建GraphQL类型使得创建查询语句时会有类型提示。 最后一件事情是重构schema.js。我们想通过id查询gadget。向schema.js导入模型Gadget，从graphql导入``GraphQLSchema、GraphQLObjectType、GraphQLString，以及导入graphql类型gadgetGraphQLType`。 123const &#123; GraphQLSchema, GraphQLObjectType, GraphQLString&#125; = require('graphql');const gadgetGraphQLType = require('https://www.haoming.fun/images/gadgetType');const Gadget = require('.https://www.haoming.fun/images/models/gadget'); 接下来需要一个根查询，每个graphql查询都以花括号开头。 123456789101112const RootQuery = new GraphQLObjectType(&#123; name: 'RootQueryType', fields: &#123; gadget: &#123; type: gadgetGraphQLType, args: &#123; id: &#123; type: GraphQLString &#125;&#125;, resolve(parent, args) &#123; return Gadget.findById(args.id) &#125; &#125; &#125;&#125;) gadget查询里面有三个属性： type-查询的类型 args-提供给graphql查询的参数 resolve-查询完成后要做什么？这里是按照id返回gadget 最后导出schema： 123module.exports = new GraphQLSchema(&#123; query: RootQuery&#125;); 在浏览器地址栏输入 http://localhost:9000/graphql ，然后编写查询语句： 123456789&#123; gadget(id: \"5cc5109a41aedb25d85c211d\") &#123; name price by_company release_date id &#125;&#125; 最后的查询结果应该是这样： 参考https://www.cnblogs.com/sybboy/p/6418526.htmlhttps://www.cnblogs.com/haoliansheng/p/4390267.htmlhttps://www.cnblogs.com/damingge/p/6507605.htmlhttps://www.yiibai.com/mongodb/mongodb_create_database.htmlhttps://www.strilliant.com/2019/01/27/how-to-setup-a-powerful-api-with-graphql-koa-and-mongodb/","categories":[{"name":"前端","slug":"前端","permalink":"https://www.haoming.fun/categories/前端/"}],"tags":[{"name":"API","slug":"API","permalink":"https://www.haoming.fun/tags/API/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://www.haoming.fun/tags/GraphQL/"},{"name":"Koa","slug":"Koa","permalink":"https://www.haoming.fun/tags/Koa/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.haoming.fun/tags/MongoDB/"}],"author":"Peng Fang"},{"title":"IE下将Web中的SVG导出PNG图片","slug":"IE下将Web中的SVG导出PNG图片","date":"2019-04-29T12:15:00.000Z","updated":"2019-06-30T04:11:36.662Z","comments":true,"path":"2019/04/29/IE下将Web中的SVG导出PNG图片/","link":"","permalink":"https://www.haoming.fun/2019/04/29/IE下将Web中的SVG导出PNG图片/","excerpt":"","text":"目的本文的目的是介绍一种将Web中SVG元素导出成PNG图片的方法，并阐述如何通过修改插件源码做到兼容IE浏览器（IE10以及以上）。 前言图形一般分为两种：矢量图和栅格图。所谓栅格图就是由固定数量的正方形像素（简称“图元”）组成，每个像素填充一种颜色。JPG、PNG、GIF格式的数组图像都属于栅格图。栅格图有一个明显的特征，即缩放时会变得模糊，更确切地说，是像素化。这是由其渲染方式造成的。而矢量图不会被像素化，SVG可缩放矢量图形，是W3C XML的分支语言之一，用于标记可缩放的矢量图形，已经成为一项Web标准技术，IE8以上主流浏览器能够解析其提供的绘图指令。因为SVG可缩放的特性以及实现了DOM接口，我们会利用其提供的元素和接口编程绘制复杂的组合图形。目前我们有一个功能需求就是将Web中复杂的SVG图形导出成PNG这样的图片文件。我们在页面上绘制的SVG图形包含若干矩形、圆、线、文本、嵌入的svg图片等。 SVG图形导出PNG图片需要将D3.js绘制的图形导出并下载成为PNG图片文件，通过查阅资料发现saveSvgAsPng.js对嵌入图片的SVG图形和图形中设定的样式支持较好，在Chrome中能将Web的Svg图形导出Png图片成功。 安装使用saveSvgAspng安装1npm install save-svg-as-png 先决条件SaveSvgAsPng依赖JavaScript的promise，所以不支持标准Promise对象的浏览器需要有个polyfill（IE说你们都看我干嘛？！）。下面是在项目中安装和配置babel/polyfill，它提供完整ES2015+环境所需的polyfill(垫片)： 安装依赖 install --save @babel/polyfill```122. 在入口文件main.js引入依赖```import &apos;@babel/polyfill&apos; 修改babel.config.js 12345678910module.exports = &#123; presets: [ [ &apos;@vue/app&apos;, &#123; useBuiltIns: &apos;entry&apos; &#125; ] ],&#125; 修改 .browserslistrc 目标浏览器配置根据提供的目标浏览器的环境来，智能添加css前缀，js的polyfill垫片,来兼容旧版本浏览器。避免不必要的兼容代码，以提高代码的编译质量。 123&gt; 1%last 2 versionsnot ie &lt;= 9 使用为了保存png图片，在页面中包含saveSvgAsPng.js脚本，然后用一个SVG节点和一个文件名作为参数来调用saveSvgAsPng函数。示例代码： 12import &#123; svgAsDataUri, saveSvgAsPng &#125; from &apos;saveSvgAsPng&apos; // 导入方法saveSvgAsPng(document.getElementById(&quot;diagram&quot;), &quot;diagram.png&quot;) // 保存png图片 如果想获得SVG的dataURL，然后定义一个回调。我们可以将SVG节点，options，回调函数作为参数来调用svgAsDataUri方法，像这样： 1234567import canvg from &apos;canvg&apos;svgAsPngUri(document.querySelector(`#$&#123;id&#125; svg`), &#123; backgroundColor: &apos;#fff&apos;, canvg: canvg &#125;, (uri) =&gt; &#123; // 回调自定义处理逻辑 const imageName = &apos;pngFileName.png&apos; downloadImage(imageName, uri) // url下载成png图片 loading.close() // 关闭loading&#125;) 示例代码的选项说明如下： backgroundColor - 创建一个PNG采用设定的背景颜色，默认是透明的 canvg - 如果传入canvg参数，用来将SVG转为Canvas，以支持IE 其他参见插件README IE下saveSvgAsPng的兼容问题虽然saveSvgAsPng提供了canvg参数以兼容IE，实际经过IE11的测试发现：即便传入canvg参数，在插件调用canvas的toDataURL方法时仍然会抛出SecurityError异常。为了兼容IE，我们还要借助canvg插件，它是Canvas上SVG的解析器和渲染器，它获取SVG文件的URL或者文本，用JavaScript解析，并在Canvas元素上呈现结果。 源码分析通过分析saveSvgAsPng的源码得知它svgAsPngUri方法的执行有三个步骤： 将获取传入svg节点中的所有image元素，也就是内部嵌入的图片元素，通过在canvas上绘制改图形的办法来获取内联图片的dataURL，将其设置为图片href属性。 获取页面中的所有css样式，并将svg节点克隆一份，创建style标签，将所有的css样式代码插入到style标签内，将style标签插入到克隆节点的后面，将它们(HTML)一起作为src返回 按照以上步骤完成准备工作以后，将上面的src作为内容绘制到canvas上面，再调用canvas的toDataURL方法获得uri并返回给回调函数。这一步需要判断是否传入canvg参数，如果传入的话则调用canvg方法将src转换为canvas，以达到调用canvas.toDataURL()不会报错。解决IE下导出图片文件报错经过进一步分析得知，在上面第一步中获取内联图片的dataURL时在IE下会报错，那么解决办法是增加是否获取uri的参数，并作如下判断，如果需要获取uri参数（IE下不获取，也就是有设置canvg参数选项），才调用toDataURL方法。 解决导出图片无背景问题经过以上的处理，在IE下可以正常导出图片，但是导出的png没有背景颜色（呈黑色背景）。经过查询资料发现：利用canvas的toDataURL创建图像，如果图像类型支持透明（比如PNG），那么背景颜色则会是透明，否则是黑色。w3c的说明参考这里在上面第三步返回dataURL的时候，我们判断如果没有传入canvg参数，正常调用canvas的toDataURL方法，否则我们这样处理： 从canvas中得到ImageData 将globalCompositeOperation属性设置为destination-over. 这将会在当前存在的图形之下绘制新的图形 画一个整个canvas大小的rectangle，填充你想要的背景色 生成canvas的dataURL 清空整个canvas（包含背景） 拷贝原来的绘图数据到canvas 重置globalCompositeOperation为你开始想要的值 结语以上我们介绍了如何增加垫片使得ES6的API能在IE下兼容运行，以及修改saveSVGAsPng的源码来使得IE下能正常将svg元素导出为png图片。 参考文献 图说D3数据可视化利器从入门到进阶 Vue CLI 3 配置兼容IE10 saveSvgAsPng github canvg github canvas w3c Setting the background color when generating images from Canvas.toDataURL","categories":[{"name":"可视化","slug":"可视化","permalink":"https://www.haoming.fun/categories/可视化/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://www.haoming.fun/tags/源码分析/"}],"author":"Peng Fang"},{"title":"记一次crontab执行scp异常解决","slug":"记一次crontab执行scp异常解决","date":"2018-10-22T07:57:00.000Z","updated":"2019-06-30T04:11:36.670Z","comments":true,"path":"2018/10/22/记一次crontab执行scp异常解决/","link":"","permalink":"https://www.haoming.fun/2018/10/22/记一次crontab执行scp异常解决/","excerpt":"","text":"Python执行shell命令时的奇怪问题通过crontab命令，周期性执行Python脚本。简单来说，用Python脚本实现的是将一些指定目录下的文件scp到远程主机的某个目录下。奇怪的是，该scp命令在命令行中执行没问题，通过上述的方式执行就不能成功，日志记录的是“scp传输失败” 问题具体一些我们通过crontab命令，可以在固定的间隔时间执行指定的系统指令或shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。任务定义格式：.—————- minute (0 - 59)| .————- hour (0 - 23)| | .———- day of month (1 - 31)| | | .——- month (1 - 12) OR jan,feb,mar,apr …| | | | .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat| | | | |* * * * * user-name command to be executed 例如：每五分钟执行一次验证脚本*/5 * * * * python /data/mgxy/scripts/verify.py MGSM ZL BLXY crontab有个用户域，也就是说当前用户可以设置自己的crontab命令，设置成功可以通过crontab -l命令查看当前用户设置的任务，不能看到其他用户设置的任务。通过crontab -e命令来编辑当前用户的crontab，也就是在执行命令后的编辑器中输入上面的验证脚本，然后保存后会将编辑的crontab文件提交给cron进程执行。 “verify.py”中执行scp命令是采用免密方式，免密登录是通过sshpass来实现的，用-p参数指定明文密码： 1sshpass -p loginPassord scp -oUserKnownHostsFile=/dev/null -oStrictHostKeyChecking=no /sourcePath/sourceFile username@targetIp:/targetPath/ 每次ssh访问过的计算机公钥都会记录在~/.ssh/known_hosts，方便下次访问该计算机时核对。记得首次ssh登录一个主机的时候，命令行都会提示：“RSA key fingerprint is *****. Are you sure you want to continue connecting (yes/no)?”，如果回复yes,ssh客户端就会继续登录，将主机key存在文件~/.ssh/known_hosts中，如果回复no，连接就会中断。 scp 可以通过-o来指定ssh选项。StrictHostKeyChecking=no，该选项会禁用掉上面的交互提示，自动将主机key添加到文件~/.ssh/known_hosts中。如果我们确认远程主机密码更改时合法的，我们可以跳过主机密钥的校验，通过设置UserKnownHostsFile=/dev/null将密钥发送到一个null的known_hosts文件中。 一些尝试 将实际执行的命令，放到命令行中执行结果：能够正常执行。猜想： 会不会命令行用户和执行脚本的用户不同导致？实际这两个都同一个用户。 会不会是Python脚本的问题？python脚本在另一台机器运行正常。 不用crontab命令，将Python脚本在命令行执行结果：脚本正常执行。说明是crontab执行任务的问题。涛哥指导：crontab的用户比较特殊，尽可能使用绝对路径 crontab命令中将python改为绝对路径结果：*/5 * * * * /usr/bin/python xxx问题依然存在设想：会不会是python脚本中执行的scp命令也要换成绝对路径 将python中执行的命令换成绝对路径结果：成功！能够正常拷贝文件。解决办法想想修改python中的命令为绝对路径，这不是通用办法。有没有通用点的办法，不用修改python脚本呢。然后我谷歌了一下，发现/etc/contab中可以设置环境变量，如：1PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin 很多命令就在以上的$PATH中啊。想想该怎么设置环境变量呢，在哪里设置呢？他们以前会不会也有这样的问题呢？是怎么解决的呢？所以我去线上环境crontab -l看了一下，发现类似的设置： 1*/10 * * * * . /etc/profile;/bin/sh xxx.sh 然后百度了一下，有这么一段描述(来自博客)： 当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 最后，我在crontab命令按照以上配置（crontab命令设置绝对路径是好习惯）： 1*/5 * * * * . /etc/profile;/usr/bin/python xxx.py xxx 并在/etc/profile中设置环境变量：PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$PATHbingo, 成功！ 参考资料https://www.cnblogs.com/chenlaichao/p/7727554.htmlhttps://www.shellhacks.com/disable-ssh-host-key-checking/https://stackoverflow.com/questions/2388087/how-to-get-cron-to-call-in-the-correct-pathshttps://www.cnblogs.com/intval/p/5763929.html","categories":[{"name":"运维","slug":"运维","permalink":"https://www.haoming.fun/categories/运维/"}],"tags":[{"name":"异常解决","slug":"异常解决","permalink":"https://www.haoming.fun/tags/异常解决/"}],"author":"Peng Fang"},{"title":"Hive2Hbase入库逻辑","slug":"Hive2Hbase入库逻辑","date":"2018-09-19T12:21:00.000Z","updated":"2019-06-30T04:11:36.661Z","comments":true,"path":"2018/09/19/Hive2Hbase入库逻辑/","link":"","permalink":"https://www.haoming.fun/2018/09/19/Hive2Hbase入库逻辑/","excerpt":"","text":"Parquet格式hdfs文件根据规则生成HFile 创建和设置habse参数 清楚输出目录下HFile文件 创建mapreduce job 设置mapper：job.setJarByClass, job.setMapperClass, job.setMapOutputKeyClass, job.setMapOutputValueClass； 设置Parquet格式的解析器； 设置合并方法：job.setCombinerClass(Combiner.class)，Combiner继承自Reducer，reduce方法用于数据去重； 设置写HFile的reduce：HFileOutputFormat2.configureIncrementalLoad, HFileOutputFormat2.setOutputPath; job.setReducerClass(KeyValueSortReducer.class)：设置reducer class, 如KeyValue、Put、Text，以正确地对输入值进行排序。configureIncrementalLoad中会根据前面设置的MapOutputKeyClass来设置ReducerClass，见下面的源代码。 提交job，轮询等到其完成，退出程序执行。第7步configureIncrementalLoad源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void configureIncrementalLoad(Job job, HTableDescriptor tableDescriptor, RegionLocator regionLocator, Class&lt;? extends OutputFormat&lt;?, ?&gt;&gt; cls) throws IOException, UnsupportedEncodingException &#123; Configuration conf = job.getConfiguration(); job.setOutputKeyClass(ImmutableBytesWritable.class); job.setOutputValueClass(KeyValue.class); job.setOutputFormatClass(cls); // Based on the configured map output class, set the correct reducer to properly // sort the incoming values. // TODO it would be nice to pick one or the other of these formats. if (KeyValue.class.equals(job.getMapOutputValueClass())) &#123; job.setReducerClass(KeyValueSortReducer.class); &#125; else if (Put.class.equals(job.getMapOutputValueClass())) &#123; job.setReducerClass(PutSortReducer.class); &#125; else if (Text.class.equals(job.getMapOutputValueClass())) &#123; job.setReducerClass(TextSortReducer.class); &#125; else &#123; LOG.warn(\"Unknown map output value type:\" + job.getMapOutputValueClass()); &#125; conf.setStrings(\"io.serializations\", conf.get(\"io.serializations\"), MutationSerialization.class.getName(), ResultSerialization.class.getName(), KeyValueSerialization.class.getName()); // Use table's region boundaries for TOP split points. LOG.info(\"Looking up current regions for table \" + tableDescriptor.getTableName()); List&lt;ImmutableBytesWritable&gt; startKeys = getRegionStartKeys(regionLocator); LOG.info(\"Configuring \" + startKeys.size() + \" reduce partitions \" + \"to match current region count\"); job.setNumReduceTasks(startKeys.size()); configurePartitioner(job, startKeys); // Set compression algorithms based on column families configureCompression(conf, tableDescriptor); configureBloomType(tableDescriptor, conf); configureBlockSize(tableDescriptor, conf); configureDataBlockEncoding(tableDescriptor, conf); TableMapReduceUtil.addDependencyJars(job); TableMapReduceUtil.initCredentials(job); LOG.info(\"Incremental table \" + regionLocator.getName() + \" output configured.\");&#125; 加载HFile到HBase表 加载配置文件hbase-site.xml 读取hdfs配置文件hbase-hdfs-site.xml，然后配置hbase-site.xml的一些参数：● 配置dfs.ha.namenodes.[nameservice ID]，让DataNode知道每个集群的所有NameNode● 配置dfs.client.failover.proxy.provider.[nameservice ID]，该参数定义HDFS客户端用来和活动的namenode节目联系的java类。配置的java类是用来给HDFS客户端判断哪个namenode节点是活动的，当前是哪个namenode处理客户端的请求。● 配置dfs.namenode.rpc-address.[nameservice ID].[name node ID] ， 即配置每个namenode监听的RPC地址。● 配置dfs.nameservices–自定义的HDFS服务名，在NameNode节点的集群中，对HDFS集群访问的入口是NameNode所在的服务器。但是在两个NameNode节点的HA集群中，无法配置单一服务器入口。所以需要指定一个逻辑上的服务名，这个服务名是自定义的。当外界访问HDFS集群时，入口就变为这个服务。用户不必关心当前具体是哪台服务器在提供服务（Active状态），只要访问这个服务就可以了。● 配置mapreduce.job.hdfs-servers.token-renewal.exclude为名字服务id的数组，ResourceManager为应用程序更新委托令牌。只有当令牌的更新者是非空字符串时，此行为才被更新为令牌。MapReduce作业可以指示ResourceManager通过指定具有配置mapreduce.job.hdfs-servers.token-renewal.exclude = ，，..，的主机来跳过从某些主机获取的令牌的更新。 向HBASE表加载数据123HTable table = new HTable(conf, tableB);LoadIncrementalHFile loader = new LoadIncrementalHFile(conf);loader.doBulkLoad(new Path(outputPathOnHbase), table); // outputPathOnHbase是HBASE的hdfs上HFile的路径 API解释如下： 1234567891011121314Class LoadIncrementalHFiles：Tool to load the output of HFileOutputFormat into an existing table.public void doBulkLoad(org.apache.hadoop.fs.Path hfofDir, Admin admin, Table table, RegionLocator regionLocator) throws TableNotFoundException, IOExceptionPerform a bulk load of the given directory into the given pre-existing table. This method is not threadsafe.Parameters:hfofDir - the directory that was provided as the output path of a job using HFileOutputFormattable - the table to load intoThrows:TableNotFoundException - if table does not yet existIOException 参考：https://blog.csdn.net/book_mmicky/article/details/25714339https://segmentfault.com/a/1190000007239743http://www.searchdoc.cn/hadoop/hadoop.apache.org/docs/r3.0.0-alpha1/hadoop-project-dist/hadoop-common/release/3.0.0-alpha1/RELEASENOTES.3.0.0-alpha1.com.coder114.cn.htmlhttps://www.programcreek.com/java-api-examples/index.php?api=org.apache.hadoop.hbase.mapreduce.KeyValueSortReducer","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.haoming.fun/categories/大数据/"}],"tags":[{"name":"Hbase","slug":"Hbase","permalink":"https://www.haoming.fun/tags/Hbase/"},{"name":"数据入库","slug":"数据入库","permalink":"https://www.haoming.fun/tags/数据入库/"}],"author":"Peng Fang"},{"title":"2018-2019技术书单","slug":"2018-2019技术书单","date":"2018-09-18T12:42:00.000Z","updated":"2019-06-30T04:11:36.654Z","comments":true,"path":"2018/09/18/2018-2019技术书单/","link":"","permalink":"https://www.haoming.fun/2018/09/18/2018-2019技术书单/","excerpt":"","text":"2018到2019书单 —— 计算机系统化学习，大神进化之路 数学具体数学图论及其应用矩阵理论线性代数与空间解析几何最优化理论与方法组合数学深入浅出统计学 机器学习统计学习方法机器学习(西瓜书)机器学习(经典) 大数据Hadoop权威指南 编程语言css世界Java核心技术(卷一)深入理解Java虚拟机webkit技术内幕高性能JavaScript 数据结构及算法算法导论算法：C语言实现算法心得数据结构与算法分析——C语言描述 网络TCP/IP详解计算机网络自顶向下方法 操作系统深入理解计算机系统Linux内核设计与实现(第三版)Linux程序设计实践Unix操作系统设计老码识途 数据库数据库系统概论MySQL DBA修炼之道高性能MySQL","categories":[{"name":"基础科学","slug":"基础科学","permalink":"https://www.haoming.fun/categories/基础科学/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://www.haoming.fun/tags/书单/"}],"author":"Peng Fang"},{"title":"怎样更有竞争力","slug":"怎样更有竞争力","date":"2018-09-18T12:34:00.000Z","updated":"2019-06-30T04:11:36.669Z","comments":true,"path":"2018/09/18/怎样更有竞争力/","link":"","permalink":"https://www.haoming.fun/2018/09/18/怎样更有竞争力/","excerpt":"","text":"做选择时选择难的，大家认为难的往往有竞争力 只有思考过总结出来记录下来的才是自己的 不在于愿望有多强烈，而在于每天达成一个个小目标 建立自己的个人品牌和影响力 凡事主动，主动思考，主动询问，主动了解 搞技术最难的不是怎么用它，而是为什么用它，它是怎么实现的，实现用到了哪些技术，基于什么样的原理 研究一门技术思考的是它的核心 大数据的核心是mr.hdfs 后端的核心是框架源码和jvm 前端的核心是框架源码，组件源码和编译原理，运行时环境 机器学习核心是神经网络，矩阵理论，概率统计，优化 系统性学习，建立知识框架 写PPT的能力，做汇报的能力(写和讲) 学习基础科学计划：操作系统、计算机网络、编译原理、算法与数据结构","categories":[{"name":"感悟","slug":"感悟","permalink":"https://www.haoming.fun/categories/感悟/"}],"tags":[{"name":"竞争力","slug":"竞争力","permalink":"https://www.haoming.fun/tags/竞争力/"}],"author":"Peng Fang"},{"title":"webcola介绍","slug":"webcola介绍","date":"2018-09-12T12:18:00.000Z","updated":"2019-06-30T04:11:36.665Z","comments":true,"path":"2018/09/12/webcola介绍/","link":"","permalink":"https://www.haoming.fun/2018/09/12/webcola介绍/","excerpt":"","text":"cola.js是一个开源的JavaScript库，使用基于约束的优化技术组织HTML5文档和图表。它可以和D3.js、SVG.js以及Cytoscape.js类似的很好配合。核心布局是基于libcola的C++库重写的。它也适配于d3.js，允许你使用cola作为D3力布局的一个核心替代。不同于D3力布局，通过一个简单的退火策略使其布局收敛到局部最优，因此与D3力布局相比： Cola实现更高质量的布局 在交互式应用程序中更稳定（没有”抖动”） 它允许用户指定约束，例如对齐和分组 它能自动生成约束来 避免节点重叠 为有向图提供流布局 对于非常大的图，它可能不太好扩展然而，图上节点少于100个的情况下工作得很好，见Unix家族树 注意，虽然使用D3力布局，为了获得合理的节点分离，你可能要必须处理”charge”这样的参数。cola在最终布局中指定的链接距离方面做得更好。这是因为cola直接试着最小化理想链接距离和图中实际链接距离中的方差。换句话说，仅仅根据节点大小设置合理的链接距离。 为了了解一些可选的参数，我们可以像这样开始布局： 1234567d3cola .nodes(graph.nodes) .links(graph.links) .constraints(graph.constraints) .symmetricDiffLinkLengths(5) .avoidOverlaps(true) .start(10,15,20); 我们像D3力布局一样指定节点和链接。constraints是一个新参数，它是一个包含约束的数组，像这样： 1&#123;\"axis\":\"y\", \"left\":0, \"right\":1, \"gap\":25&#125; 这就是说，graph.nodes[0]的中心必须与graph.nodes[1]的中心距离25个像素以上。更精确地讲，约束要求满足这样的不等式： 1graph.nodes[0].y + gap &lt;= graph.nodes[1].y 设置avoidOverlaps(true)，在布局进行时动态生成约束，以防止节点的边框彼此重叠。symmetricDiffLinkLengths(5) ，使用5作为基本长度，计算每个链路上的理想长度，为的是在高度节点周围创造额外的空间。或者，你也可以将自己的函数f传递给linkDistance，返回每个链接的特定长度。start()方法现在包含多达三个整数参数。在上面的例子中，start最初将应用10次没有约束的布局迭代，15次仅具有结构（用户指定的）约束的迭代，以及20次包含反重叠约束的具有所有约束的布局迭代。指定这样一个计划是有用的，使得图形在其被严格约束前展开。 在cytoscape.js中使用cola.jsCytoscape.js通过扩展已经完全支持Cola.js.Cytoscape.js拥有一个完全的图理论模型，高度可定制的样式和布局。Cola.js在Cytoscape.js中运行只需要一行代码： 123cy.layout(&#123; name: 'cola' /* and maybe some other options */ &#125;); 翻译自https://ialab.it.monash.edu/webcola","categories":[{"name":"可视化","slug":"可视化","permalink":"https://www.haoming.fun/categories/可视化/"}],"tags":[{"name":"webcola","slug":"webcola","permalink":"https://www.haoming.fun/tags/webcola/"}],"author":"Peng Fang"},{"title":"Hbase基础知识点梳理","slug":"Hbase基础知识点梳理","date":"2018-09-10T12:09:00.000Z","updated":"2019-06-30T04:11:36.661Z","comments":true,"path":"2018/09/10/Hbase基础知识点梳理/","link":"","permalink":"https://www.haoming.fun/2018/09/10/Hbase基础知识点梳理/","excerpt":"","text":"整体架构从HBase部署架构来说，HBase有两种服务器：Master服务器和RegionServer服务器。一般一个HBase集群有一个Master服务器和几个RegionServer服务器。Master服务器负责维护表结构信息，Master挂到后还能查询数据，只是不能新建表或修改表。实际的数据存储在RegionServer服务器上，RegionServer保存的表数据是直接存储在Hadoop的HDFS上。客户端获取数据是由客户端直接连接RegionServer服务器。RegionServer非常依赖ZooKeeper服务。ZooKeeper在HBase中扮演管家角色，管理了HBase所有RegionServer的信息，包括具体的数据段存放在哪个RegionServer上。客户端每次与HBase连接，先与ZooKeeper通信，查询出需要与哪个RegionServer连接，然后再连接RegionServer。整体架构图如下： Region是什么Region就是一段数据的集合。HBase中的表一般拥有一个到多个Region。Region有几个特性： Region不能跨服务器 当数据量大的时候，HBase会拆分region HBase负载均衡的时候，可能会把Region从一个RegionServer移动到另一个上 Region是基于HDFS的，所有数据存取操作都是调用了HDFS的客户端接口来实现的 RegionServer是什么RegionServer是存放Region的容器，直观来说就是服务器上的一个服务。一般来说，一个服务器只会安装一个RegionServer服务。当客户端从ZooKeeper获取RegionServer的地址后，它会直接从RegionServer获取数据，插入、删除等数据操作也是经过它。 Master是什么HBase中Master角色不像领导，更像是打杂的。Master负责各种协调工作，比如建表、删表、移动Region、合并等操作。它们的共性就是需要跨RegionServer，由哪个RegionServer来执行都不合适，所以HBase将这些操作放到Master上。这种结构大大降低了集群对Master的依赖，即使Master宕机了，也不影响数据操作。 存储架构HBase最基本的存储单位是列。行跟行的列可以完全不一样，行与行的数据，甚至同一行的列可以存储在不同的机器上。若干个列被归类为一个列族。存储架构图如下： 行键是什么rowkey是由用户指定的一串不重复字符串。rowkey是决定row存储顺序的唯一凭证。HBase是根据字典排序的。比如：row-1, row-11, row-2。 列族是什么建表的时候不需要指定列，但需要确定列族，这就是说一个表有几个列族是一开始确定好的。此外，表的很多属性，比如过期时间、数据块缓存以及是否压缩等都是定义在列族上，而不是定义在表上或者列上。同一个表里的不同列族可以有完全不同的属性配置，但是同一个列族内的所有列都会有相同属性。列名称规范是列族：列名，如brother:age。列族的意义是：HBase会把相同的列族尽量放在同一台机器上，所以说，如果想让某一个列被放在一起，就给他们定义相同的列族。一个表设置多少个列族合适？官方的建议是：越少越好，因为Hbase虽然是分布式数据库，但是数据在同一台机器上仍然会加速数据的查询过程。所以请根据实际需要制定列族，列族太多会极大降低数据库性能。 单元格是什么一个列上可以存储多个版本的值，多个版本的值被存储在多个单元格里面，多个版本之间用版本号（Version）来区分。所以唯一确定一条结果的表达式应该是行键：列族：列：版本号(rowkey:column family:column:version)。不过版本号是可以省略的，如果不写版本号，HBase默认获取最后一个版本的数据并返回。每个列或者单元格的值都被赋予一个时间戳，这个时间戳默认是由系统指定的，也可以由用户显示指定。 Region跟行的关系一个Region就是多个行的集合。在Region中行的排序按照行键（rowkey）字典排序。表结构图如下： 传统数据库insert语句可以把整行的数据一次性写在行语句里面，而在HBase里面如果一行有10列，那么存储一行的数据得写10行的语句。存储语句必须精确写出数据被存储到哪个单元格，根据表：列族：行：列来定义。行的概念被弱化到只有一个抽象的存在，rowkey是其唯一的体现。 讲讲ZooKeeperZooKeeper不知Hadoop的HA模式（HA的作用是保证一个namenode挂掉的时候，另外一个namenode能立即启动将其代替，这样就不会发生单点故障的问题）用到，HBase也会用到。ZooKeeper是Apache旗下的一个开源项目，它是一个开源的分布式应用程序协调服务，它可以为分布式应用提供一致性服务，提供的功能包括：配置服务、域名服务、分布式同步、组服务等。ZooKeeper负责维护HBase的所有节点，如果ZooKeeper宕掉了，集群的一个节点都连不上。ZooKeeper最大的功能之一就是知道某个节点是否宕机了，那么ZooKeeper是如何知道某个节点宕机的呢？答案是，每一个机器在ZooKeeper中都有一个会话（Session），如果某个机器宕机了，这个会话（Session）就会过期，与此同时，ZooKeeper就知道该节点已宕机。多少个节点最好？节点越多容灾能力就越强，不过节点数最好是奇数个，这样有利于仲裁。ZooKeeper的容灾机制：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。如果有5个节点，有2个集群宕掉，集群依然可以运行。这是我们称该集群容灾能力是2。目前节点数是6，只要有3个机器宕掉那么集群就宕掉了，此时的容灾能力仍是2。ZooKeeper应该存储在一个独立的磁盘上，避免当磁盘出现IO问题的时候ZooKeeper被波及。 HBase常用命令 list查看数据库中有哪些表 describe查看表属性 create &amp; altercreate ‘test’, ‘cf’ # 建立一个叫test的表，这个表有一个列族叫cfalter ‘test’, ‘cf2’ # 新增一个列族在生产环境更改表之前，最好先停用（disable）这个表。因为对列族的所有操作都会同步到所有拥有这个表的RegionServer上。当有很多客户端都在连着的时候，直接新增一个列族对性能的影响较大。 putput ‘test’, ‘row1’, ‘cf:name’, ‘jack’意思是往test表插入一个单元格，这个单元格的rowkey为row1，也就是说它是属于row1这个行中的一个列。该单元格的列族是cf，单元格的列名是name，数据值是jack。 关于时间戳每一个单元格可以存储多个版本的值。它用timestamp来存储该条记录的时间戳，这个时间戳就用来当版本号使用。timestamp虽然是时间的标定，其实可以输入任意的数字，比如1，2，3等。当用scan命令的时候HBase会显示拥有最大（最新）的timestamp的数据版本。创建表时默认版本是1，也就是说在一个单元格插入多个版本的数据的时候，HBase只会保留最后一个版本。能够在scan操作的结果集看到多个版本的前提是建表时设定的VERSIONS参数要大于1，这样表才能保存设定VERSIONS数个历史记录。修改版本数的命令：alter ‘test’, {NAME=&gt;’cf’,VERSION=&gt;5} # NAME为要修改的列族的名称，后面跟要修改的属性，我们修改VERSION为5put ‘test’,’row2’,’cf:name’,’ted’put ‘test’,’row2’,’cf:name’,’billy’,2222222222222 #自定义时间戳晚于当前时间scan ‘test’ # 只能看到时间戳最大的那条结果get ‘test’,’row2’,{COLUMN=&gt;’cf:name’, VERSIONS=&gt;3} #查询所有版本的数据 scanscan ‘表名’，这样输入的话，会从第一条数据开始把所有数据全部显示一遍。在HBase中我们用起始行（STARTROW）和结束行（ENDROW）来限制记录的条数。scan ‘test’,{STARTROW=&gt;’row3’} # 显示所有rowkey大于等于row3的记录scan ‘test’,{ENDROW=&gt;’row4’} # 小于row4(不包括)的记录两个参数一起用就是显示 &gt;= STARTROW 并且 &lt;ENDROW中的那段数据scan ‘表名’,{COLUMNS=&gt;[‘列1’,’列2’,…]} # 只遍历指定列scan ‘表名’,{STARTROW=&gt;’起始行键’,ENDROW=&gt;’结束行键’} # 指定行键范围scan ‘表名’,{LIMIT=&gt;行数量} # 指定最大返回行数量scan ‘表名’,{TIMERANGE=&gt;[最小时间戳,最大时间戳]} # 找出单元格的历史版本数据scan ’表名’,{VERSION=&gt;’版本数’} # 指定版本数，显示单元格多个版本值scan ‘表名’,{FILTER=&gt;’过滤器’} # scan ‘table1’ { FILTER=&gt; “PrefixFilter(‘row1’)” } getscan可以查询表的多条数据，get只能查询一个单元格的记录。在数据量大的时候，get的查询熟读远远高于scan。get ‘test’,’row7’,’cf:name’ # 查询某个单元格的记录get ‘test’,’row7’,{COLUMN=&gt;’cf:name’,VERSION=&gt;5} # 把查询版本数设定为5scan ‘test’,{VERSION=&gt;5} # scan跟上VERSIONS参数也可以查询出多个版本的数据 count计算表的行数 deletedelete ‘表名’,’行键’,’列名’delete ‘表名’,’行键’,’列名’,时间戳 split拆分(split)指定的Region，除了可以等到Region大小达到阈值后触发自动拆分机制来拆分Region，还可以手动拆分指定的Region，如 split ‘region名’。 merge_region合并（merge）两个Region和一个Region compact调用指定表的所有Region或者指定列族的所有Region的合并（compact）机制。通过compact机制可以合并该Region或者Region的列族下的所有HFile（StoreFile），以此来提高读取性能。compact跟合并（merge）并不一样。merge操作是合并2个Region为1个，而compact操作更新的单元StoreFile，一个Region可以含有一个或多个StoreFile，compact操作的目的在于减少StoreFile的数量以增加读取性能。 快照快照就是表在某个时刻的结构和数据。可以使用快照来将表恢复到某个时刻的结构和数据，恢复过程很快，往往只有数秒。HBase是怎么做到的呢？其实快照并不直接复制数据，而是保持一份文件列表，通过修改表所链接的文件夹来改变表的数据，好处是：速度极快；不额外占用磁盘空间。HBase要求在恢复快照之前必须要先停用（disable）需要恢复的表，才能恢复快照，避免不必要的麻烦。先停用，然后恢复快照，再启用（enable）。通过snapshot命令可以创建指定表的快照。disable ‘mgdmcredit:userblack_temp’snapshot ‘mgdmcredit:userblack_temp’, ‘userblack_temp_snapshot’disable ‘mgdmcredit:userblack’drop ‘mgdmcredit:userblack’clone_snapshot ‘userblack_temp_snapshot’ ‘mgdmcredit:userblack’enable ‘mgdmcredit:userblack_temp’truncate ‘mgdmcredit:userblack_temp’delete_snapshot ‘userblack_temp_snapshot’clone_snapshot使用快照的数据创建一张新表，创建的过程很快，因为使用的方式不是复制数据，并且修改新表的数据不会影响旧表的数据。 客户端API在HBase中有一个理念：所有数据皆为bytes。在HBase中数据最终都会被序列化为bytes[]保存。 put方法123456try(Connection connection = ConnectionFactory.createConnection(config)) &#123; Table table = connection.getTable(TableName.valueOf(\"myTable\")); Put put = new Put(Bytes.toBytes(\"row1\")); put.addColumn(Bytes.toBytes(\"mycf\"), Bytes.toBytes(\"name\"), Bytes.toBytes(\"ted\")); table.put(put);&#125; 新增和修改类型，修改就是往同一个rowkey再执行一次put操作，将之前的数据覆盖掉。JDK的try-with-resources，上面例子中看到try(…){….}，{….}中的代码执行完毕会自动释放资源，不需要手动写finally语句块了。 get方法get不像scan，并不能用多种条件去查找，只能用行键去查找。不过HBase一行有可能很大，我们可以通过设置参数让get只获取其中一部分的数据，以提高查询性能。 123456789Get get = new Get(Bytes.toBytes(\"row1\"));get.setMaxVersions(10);Result result = table.get(get);List&lt;Cell&gt; cells = result.getColumnCells(Bytes.toBytes(\"mycf\"), Bytes.toBytes(\"name\"));for(Cell c: cells) &#123; // 用CellUtil.cloneValue来获取数据而不是getValue bytes[] cValue = CellUtil.cloneValue(c); System.out.println(Bytes.toString(cValue));&#125; 用CellUtil.cloneValue来获取数据而不用getValue的原因：根据目前getValue的实现代码，每次调用它都会获取整个Cell的数组备份，比较消耗性能。所以当需要获取Cell中的值时，请使用CellUtil.cloneValue方法。 Scan扫描查询多条数据我们会想到用scan。默认的scan是从表头一直遍历到表尾，非常耗时好性能，实际工作中，我们至少要定义一下遍历的起始rowkey，如果知道遍历的结束rowkey就好了。举个栗子：1234Scan scan = new Scan(Bytes.toBytes(\"row1\"));ResultScanner rs = table.getScanner(scan);...rs.close(); // 使用完了关闭 这里为什么是getScanner()而不是scan()？因为Table通过传入scan之后返回的结果扫描器（ResultScanner）并不是实际的查询结果。获取结果扫描器（ResultScanner）的时候并没有实际去查询数据。真正要获取数据的时候要打开扫描器，然后遍历它，这个时候才真正地查询了数据。这个ResultScanner就像关系型数据库中的ResultSet一样是需要持续占用资源的，所以用完后务必记得关闭它。 缓存HBase在扫描的时候已经默认开启了缓存。具体来讲，每一次的next()操作都会产生一次完整的RPC请求，而这次RPC请求可以获取多少数据是通过hbase-site.xml中的hbase.client.scanner.caching参数配置的。比如配置为1，遍历了10个结果就会发送10次请求。可以在表的层面修改缓存条数，也可以在扫描层面去修改。表的层面修改时通过hbase-site.xml中的配置: 1234&lt;property&gt;&lt;name&gt;hbase.client.scanner.caching&lt;/name&gt;&lt;value&gt;1000&lt;/value&gt;&lt;/property&gt; hbase.client.scanner.caching的默认配置是100.在扫描层面修改缓存可以使用Scan.setCaching(int caching)方法设置一次next获取的数据条数，这个配置的优先级比配置文件内的hbase.client.scanner.caching高。 HBase二层查询架构从0.96版本之后三层查询架构被改成了二层查询架构。直接把.META.表所在的RegionServer信息存储到zk中的/hbase/meta-region-server去了。上图可以总结成以下流程： 客户端先通过ZooKeeper的/hbase/meta-region-server节点查询到哪台RegionServer上有hbase:meta表。 客户端连接含有hbase:meta表的RegionServer。hbase:meta表存储了所有Region的行键范围信息，通过这个表可以查询出你要存放的rowkey属于哪个Region的范围里面，以及这个Region又属于哪个RegionServer。 获取这些信息后，客户端就可以直连其中一台用于你要存取的rowkey的RegionServer，并直接对其操作。 客户端会把meta信息缓存起来，下次操作就不需要进行以上加载habse:meta的步骤了。 过滤器过滤器就是在Get或Scan的时候过滤结果用的，可以把他看成SQL中的where语句。HBase中过滤器被用户创建出来以后会被序列化我可以网络传输的格式，然后被分发到各个RegionServer。在RegionServer中Filter被还原出来。这样在Scan的遍历过程中，不满足过滤条件的结果将不会被返回客户端。 前缀过滤器这种过滤器可以根据行键的前缀匹配同样是这个前缀的行。运用它能提高查询性能，因为前缀过滤器在遇到扫描的行键的前缀大于所指定的前缀时，立即停止扫描。就算用了前缀过滤器也依然要结合上STARTROW使用，否则scan还是会从第一条记录开始扫描，浪费了大量的性能。当我们用Scan扫描数据的时候，如果使用STOPROW来指定终止行，结果集中并不会包含终止行。如果想在结果中包含终止行可以有两种方式：（1）在终止行的rowkey上增加一个字节的数据，然后把增加一个字节的rowkey作为STOPROW（2）使用包含结尾过滤器（InclusiveStopFilter） Region的拆分通过查询hbase:meta我们可以形象地看到，一个Region就是一个表的一段rowkey的数据集合。当Region太大的时候HBase会拆分它。为什么要拆分Region？因为当某个Region太大的时候读取效率太低了。我们可以想想为什么从MySQL、Oracle转移到NoSQL来？最根本的原因就是这些关系型数据库把数据放到一个地方，而当数据量增大到上亿的时候同一个磁盘已经无法应付这些数据的读取了，因为遍历一遍数据的时间实在太长了。用NoSQL的理由就是其能把大数据分拆到不同的机器上，然后像查询一个完整的数据一样查询他们。当Region太大的时候，一样会遇到跟传统数据库一样的问题，所以要拆分Region。 IncreasingToUpperBounRegionSplitPolicy策略（默认）计算公式：Math.min(tableRegionsCount^3 * initialSize, defaultRegionMaxFileSzie) tableRegionsCount：表在所有RegionServer上拥有的Region数量总和 initialSize：如果定义了hbase.increasing.policy.initial.size，则使用这个数值，否则，就使用memstore的刷写大小的2倍，即hbase.hregion.memstore.flush.size *2 defaultRegionMaxFileSzie：ConstantSizeRegionSplitPolicy所用到的hbase.hregion.max(一般是10G) 一开始可以先定义拆分点，但是当书记开始工作起来后会出现热点不均的情况，所以推荐的方法是： 用预拆分导入初始数据 然后用自动拆分来让HBase自动管理RegionRegion的拆分对性能的影响还是很大的，默认的策略已经适用于大多数情况。可以尝试哪种策略最好。 Region的合并Region的合并（merge）并不是为了性能考虑，更多地出于维护的目的。啥时候才会用到合并呢？比如删了大量的数据，每个Region都变小了，这个时候分成这么多个Region就有点浪费，可以把Region合并起来。通过Merge类来合并叫冷合并，就是要把HMaster和所有的HRegionServer全部停掉，再执行才可以；通过online_merge命令叫做热合并 HFile的合并除了Region会合并和拆分，在Region中的单个Store中也会发生合并（compaction）。HFile为什么要合并？但凡存储在磁盘上的东西都涉及到一个操作：寻址。传统硬盘是磁头的移动寻址，是一个很慢的动作。当HFile一多，每次读取数据的时候寻址动作就多了，效率就降低了。所以我们要适当减少碎片文件，进而需要合并操作。HFile的合并操作就是在一个store里面找到需要合并的HFile，把他们合并起来，再把之前的碎文件移除。 0.96版本之后的合并算法待合并文件挑选条件该文件 &lt; （所有文件大小总和 - 该文件大小）* 比例因子如果该文件大小小于最小合并大小(minCompactSize)，直接进入待合并列表。最小合并大小配置项：hbase.hstore.compaction.min.size，如果没有设定该项，则使用hbase.hregion.memstore.flush.size. 以组合作为计算单元新的算法不再按文件为单元进行比较了，而是挑出多个文件组合。挑选组合的条件：被挑选的文件必须能通过以上提到的筛选条件，并且组合内含有的文件数必须大于hbase.hstore.compaction.min，小于hbase.hstore.compaction.max.挑选完组合后，比较哪个文件组合包含的文件更多，则合并哪个组合。如果出现平局，就挑选哪个文件尺寸总和更少的组合。 调整HFile合并策略，让HFile的数量尽量减小，以减少每次Scan的跨HFile的次数，但同时又要保证该合并策略适用于场景，并且不用太频繁。 读取性能优化性能有两方面的提高空间： 调整对于API的用法 调整系统配置 参考《Mysql不睡觉书》","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.haoming.fun/categories/大数据/"}],"tags":[{"name":"Hbase","slug":"Hbase","permalink":"https://www.haoming.fun/tags/Hbase/"}],"author":"Peng Fang"},{"title":"D3.js数据可视化实践（精简）","slug":"D3-js数据可视化实践（精简）","date":"2018-07-01T11:03:00.000Z","updated":"2019-06-30T04:11:36.657Z","comments":true,"path":"2018/07/01/D3-js数据可视化实践（精简）/","link":"","permalink":"https://www.haoming.fun/2018/07/01/D3-js数据可视化实践（精简）/","excerpt":"","text":"D3数据可视化实践 方鹏 2018/07/05 前言在我们的APP上线后，经过数据分析，实时获取反映使用情况的活跃用户数；活跃数可分为总的日活或月活，分APP的日活或月活，分APP分省的日活或月活等等。想把这些数据表达清楚，可能会涉及实时的动态的变化数据；数据的按维度分类展示；如何按数字大小或者属性进行区分，着重展示我们感兴趣的数据。以上涉及到的就是我们常说的数据可视化。数据可视化的目的就是对数据进行可视化处理，以使得明确有效地传递信息。利用图表来对数据进行可视化是我们熟知的方式。产品经理对可视化需求进行分析，选择合适的图表来表达和传递信息。而我们作为前端开发人员，也需要理解需求及设计，选用能满足需求的图表组件或可视化方案来实现产品设计。选择技术方案的时候，我们或许会发现，因为图表内容复杂，没有现成的图表组件能够利用；或者现有的图表组件不能满足我们的部分需求；或者因为大数据量的场景，造成图表渲染较慢。解决这些需求中的痛点，我们就得思考用何种技术方案，怎样解决遇到的问题。思考为什么选择这个方案，它能帮助我们解决什么问题，或者说它有什么优势。 怎么选择现有的可视化库很多，像Echarts，Highcharts，D3这些我们多少都在项目中经常使用或者听说过大名。Echarts等可视化库封装层次很高，能够简单地制作图表，但是给予开发者控制和设计的空间较少。D3在这一点上取得了平衡。D3提供了极度灵活的Web标准化能力，例如CSS3, HTML5, SVG。试想用原生的HTML、SVG、Canvas来实现数据绘图是困难和繁琐的。D3封装了这些能力，使开发者专注布局和逻辑。那么方案怎么选择呢？我们应该熟悉各可视化库的优势，在满足需求的同时也要考虑开发成本。 关于D3.js什么是D3.jsD3 全称是Data-Driven Document，直译为数据驱动文档。 数据由用户或开发者提供文档指的是基于web的文档，即Web浏览器可以渲染的任何元素，例如HTML、SVG、Canvas由D3来驱动数据和文档。从某种意义上说，它将文档和数据联系起来。 D3是一个JavaScript函数库，是用来做数据可视化的。 用D3.js的创始人Mike Bostock 其开源地址：https://github.com/d3/d3 历史及版本比较 2011年2月，Mike Bostock发布了v1.0.0版本。 2012年12月，v3.0.0版本发布，网上3.x的资料比较多。 2016年6月，v4.0.0版本发布，开始支持Canvas，采用模块化设计模式。 v3.x v4.x 嵌套结构 模块化 稳定，资料多 有优化，资料相对较少 只支持SVG渲染 支持Canvas渲染 注意：两个版本的代码不兼容 D3的优势 相对比较底层数据和元素捆绑。DOM里含有数据，数据更新时重绘。同时支持SVG和Canvas。 更像数学库强大的图形计算能力，D3的“布局”封装了提供力直方图、饼图、树图、力导向图等。D3的“比例尺”提供线性、指数、对数、序数等多种关于对应关系的计算。还提供“地图”功能。 即封装操作，也给予自由计算和绘图相互独立。计算是算出节点的位置、线段端点、弧线角度等；绘图是将计算所得的节点、线段绘制到网页上。 D3部分模块 模块 描述 依赖 d3-axis 坐标轴 d3-scale, d3-selection, d3-transition d3-color 颜色集操作和呈现 None. d3-format 数字格式化 None. d3-interpolate 插值函数 d3-color d3-path 路径生成 None. d3-polygon 二维多边形几何操作 None. d3-request XMLHttpRequest封装 d3-dsv, d3-dispatch d3-scale XMLHttpRequest封装 d3-dsv, d3-dispatch d3-request 从抽象到具体数据的映射 d3-array, d3-collection, d3-color, d3-format, d3-interpolate, d3-time, d3-time-format d3-selection 通过选择和加入数据进行DOM转换 d3-dsv, d3-dispatch d3-transition D3.js选择集的动画过渡 d3-ease, d3-timer, d3-interpolate, d3-selection D3基础SVG基础SVG（可缩放矢量图形），除了IE8之前的版本外，绝大部分浏览器支持SVG，可以直接嵌入HTML显示。位图与矢量图的区别：位图缩放后失真，矢量图缩放不失真；位图色彩表现力较丰富，矢量图图形色彩较简单；矢量图占用空间较小，位图较大；矢量图容易转化为位图，反之不容易。 SVG图形元素SVG预定义七种形状元素：矩形&lt;rect&gt;、圆形&lt;circle&gt;、椭圆形&lt;ellipse&gt;、线段&lt;line&gt;、折线&lt;polyline&gt;、多边形&lt;polygon&gt;、路径&lt;path&gt;路径指令： M=moveto L=lineto H=horizontal lineto V=vertical lineto C=curveto 画三次贝塞尔曲线经两个指定控制点到达终点 S=smooth curveto 与前一条三次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称 Q=quadratic curveto 画二次贝塞尔曲线经一个指定控制点到达终点 T=smooth quadratic Bezier curvto 与前一条二次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称，只需输入终点，即可绘制一条二次贝塞尔曲线SVG 示例 文字在SVG中可以使用&lt;text&gt;标签绘制文字dx: 相对当前位置在x方向上平移的距离，dy同理。text-anchor属性 1234&lt;text class=\"label-2\" text-anchor=\"end\" dy=\".35em\" rank=\"B\"&gt; &lt;tspan x=\"0\" dy=\"0.35em\"&gt;(不知情定制B004)内容战&lt;/tspan&gt; &lt;tspan x=\"0\" dy=\"1.0499999999999998em\"&gt;略合作伙伴分类不合规&lt;/tspan&gt;&lt;/text&gt; D3数据选择和属性设定我们要对DOM中的元素执行一个行为，例如移动位置，改变颜色,更新数据中的值，首先要选中它。d3.select()是选中单个元素；d3.selectAll()是选中多个元素。选择集是一个或多个页面元素的组合，能够与数据集相关联。利用D3提供的方法设置元素属性和样式值： 123d3.selectAll(\"circle.a\").style(\"fill\", \"red\").attr(\"cx\", 100)d3.select(\"circle\").attr(\"class\", \"active\");d3.select(\"circle\").classed(\"active\", true); // 添加或者移除命名的样式 有部分属性不能用attr()设定和获取，最典型的就是文本框的value属性，这样情况可以用property()来设定，例如： 1d3.select(\"#someCheckbox\").property(\"checked\", true); 方法链，也叫链式调用。和JQuery写法类似。 1d3.selectAll(\"div\").data(someData).enter().append(\"div\").html(\"Wow\").append(\"span\").html(\"Even More Wow\").style(\"font-weight\", \"900\"); 可以给.style(), .attr(), .property(), .html()设置匿名函数调用或者其他提供数据绑定的选择器的函数。 123456789var someColors = [\"blue\", \"red\", \"chartreuse\", \"orange\"];someColors = someColors.filter(function(d) &#123;return d.length &lt; 5&#125;);d3.select(\"body\").selectAll(\"div\") .data(someColors) .enter() .append(\"div\") .style(\"background\", function(d) &#123;return d&#125;) .attr(\"cx\", function(d,i) &#123;return i&#125;) .html(function(d) &#123;return d&#125;) D3数据处理 数据映射数字数据仅仅同图形化元素在屏幕上的尺寸和位置相关。Scales（比例尺）有一个定义域domain和一个值域range。我们使用d3.scale()函数来归一化数据。例如我们通过线性比例尺，将 500,000到13,000,000的城市人口相同的线性变化映射到0到500px宽的画布上。12345678var newRamp = d3.scaleLinear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // 返回20，可以将一千万人口的国家放在20px处newRamp(9000000); // 返回340newRamp.invert(313); // 求逆，返回8325000var newRamp = d3.scaleLinear().domain([500000,13000000]).range([\"blue\", \"red\"]);newRamp(1000000); // 返回\"#0a00f5\"，可以将一百万人口的城市用深紫色表示newRamp(9000000); // 返回\"#ad0052\"newRamp.invert(\"#ad0052\"); // 因为invert函数只接受数字，因此返回NaN 我们也能使用d3.scaleLog(), d3.scalePow(), d3.scaleOrdinal()等其他对数据集来说更加适合的比例尺来映射数据。 数据分类将定量数据分类，是将值按范围分或者组装到一起。一种分类方法是将数组均分几份。12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scaleQuantile().domain(sampleArray).range([0,1,2]);qScale(423); // 返回2qScale(20); // 返回0qScale(10000); // 返回2 嵌套允许数组中的元素被组织为分层树型结构；类似SQL语句里面的GROUP BY方法。下面的例子，将示例数据首先按year分组再按variety分组，如下： 12345678var yields = [&#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]var nest = d3.nest() .key(function(d) &#123; return d.year; &#125;) .key(function(d) &#123; return d.variety; &#125;) .entries(yields); 返回的嵌套数组中,以键值对的形式对数据进行分组: 123456789[&#123;key: 1931, values: [ &#123;key: \"Manchuria\", values: [ &#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]&#125;, &#123;key: \"Glabron\", values: [ &#123;yield: 43.07, variety: \"Glabron\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 55.20, variety: \"Glabron\", year: 1931, site: \"Waseca\"&#125;, ...]&#125;, ...]&#125;, &#123;key: 1932, values: ...&#125;] 在数据格式化以后，需要测量它，以确保创建的图形尺寸合适，位置是基于数据集的参数。那你将会一直用到d3.extent，d3.min，d3.max，d3.mean。 数据测量在加载你的数据以后，首要的事情之一是应该对数据进行测量和排序。很重要的是知道特殊属性值的分布，以及最大最小值和属性名称。D3提供一个数组的函数集合能帮助理解数据。加入想从cities.csv获取城市人口的最小，最大，平均值：12345d3.csv(\"cities.csv\", data =&gt; &#123; d3.min(data, el =&gt; +el.population); d3.max(data, el =&gt; +el.population); d3.mean(data, el =&gt; +el.population);&#125;); d3.extent方便地将d3.min()和d3.max()在一个数组中返回： 1d3.extent(data, el =&gt; +el.population); // 返回[500000, 1300000] 现在，我们已经加载、格式化、测量了我们的数据，那我们就可以创建数据可视化了。 简单数据可视化示例 D3数据绑定过程一个选择集是由DOM中一个或多个元素构成。能使用选择器创建和删除元素，更改样式和内容。 123456789101112131415d3.csv(\"cities.csv\", (error,data) =&gt; &#123; if (error) &#123; console.error(error) &#125; else &#123; dataViz(data) &#125;&#125;);function dataViz(incomingData) &#123; d3.select(\"body\").selectAll(\"div.cities\") .data(incomingData) // 绑定数据到选择集 .enter() // 定义当选择集中的数据多于DOM元素时如何响应 .append(\"div\") // 在当前选择集中创建一个元素 .attr(\"class\", \"cities\") // 设置新创建元素class .html(d =&gt; d.label); // 设置创建div的内容&#125; 经常传入id没有匹配到任何元素，那么称其为空选择集。当数据值的数量大于选择器中元素的数量，.enter()函数触发，允许你为每一个没有相应DOM元素的值定义一个执行行为。这里需要将选中的DOM元素同一个数组联系起来。数据集里的每一个城市同选择集中的一个DOM元素相联系，关联数据是存在元素的data属性中。 1document.getElementsByClassName(\"cities\")[0].__data__ // 返回一个指向对象的指针 如果数组长度大于元素数量，则部分还不存在的元素“即将进入可视化（enter）” 如果数组长度小于元素数量，则多余的元素“即将退出可视化（exit）” 如果数组长度等于元素数量，则绑定数据的元素“即将被更新（update）” 大多数情况，.enter()函数触发，使用.append()来添加元素；.exit()函数触发，使用.remove()来移除元素。 交互颜色插值D3支持颜色插值 123var ybRamp = d3.scaleLinear() .interpolate(d3.interpolateHsl) .domain([0, maxValue]).range([\"yellow\", \"blue\"]); 离散颜色比例尺：d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, and d3.schemeCategory20c序数比例尺，映射离散值为特殊的颜色。一个有用的特征是它的unknown方法，当传入一个不存在的值的时候，返回设定值。Color Scales 1234var tenColorScale = d3.scaleOrdinal() .domain([\"UEFA\", \"CONMEBOL\"]) .range(d3.schemeCategory10) .unknown(\"#c4b9ac\") 事件监听D3选择器可以通过on来为事件添加监听器：selection.on(type[, listener[, capture]]) 123selection.on(\"click\", function () &#123; console.log(d3.mouse(this)); // 输出相对坐标&#125;) 在当前选择的每个元素，为指定的类型type，添加或删除事件监听器listener 。type是一个字符串事件类型的名称，如“click”、“mouseover”、“keydown”、“touchstart”。基本上支持任何DOM事件，如鼠标、键盘、触屏事件。为了在侦听器内访问当前事件，使用全局函数d3.event。 如果所选择的元素相同类型的一个事件监听已经注册了，新的侦听加入之前的现有侦听被除去。为注册相同事件类型的多个监听器，该类型可以跟一个可选的命名空间，如“click.first”和“click.second”。 要删除一个监听器，传递null给listener如：selection.on(click”, null)。 行为下面给出拖拽和缩放的例子：拖拽简单示例缩放简单示例 布局D3 3.x提供了12种布局：饼状图（Pie）、力导向图（Force）、弦图（Chord）、树图（Tree）、集群图（Cluster）、捆图（Bundle）、打包图（Pack）、直方图（Histogram）、分区图（Partition）、堆栈图（Stack）、矩阵树图（Treemap）、层级图（Hierarchy）。力导向图（Force-Directed Graph），是一种常用的绘图算法。d3-force, 力布局这个模块基于Verlet integration(韦尔莱积分法)实现了物理粒子之间的作用力的仿真。模拟的作用力有电荷之间的吸引排斥力，重力，链接吸引力。 力导向图的绘制 生成数据 设置力导向图 添加绘制方法 添加交互 力导向图示例 总结Ben Fry提出的数据可视化七个步骤：获取、解析、过滤、挖掘、表现、改善、交互。D3数据可视化也会经历这几个过程。首先D3读取源数据，进行解析得到需要处理的对象数组，然后将得到的数据进行过滤返回我们感兴趣的数据，然后对过滤得到的数据进行格式化，分类或分组，方便利用数据来驱动文档。通常我们根据数据数值大小或时间远近等熟悉转换为图形上元素的大小或者位置。如果需要生成网络图谱等可视化图表，我们可以利用D3提供的布局来绘制。以力导向图为例，首先构建节点和连线的对象数据，然后将其设定给力导向图，力导向图为给节点连线生成初始的位置信息，然后根据节点和连线对象数据来自定义（绘制）节点和内容。同时我们利用tick机制绑定tick回调函数，在回调函数中定义机制对节点和连线的坐标进行更新，并更新图表。D3.js是一种很强大的可视化利器，在GitHub数据可视化分类中关注度最高的。在AI+物联网时代，数据可视化或者说人机交互将会越来越重要。掌握常见的数据可视化技术，理解可视化中的图形图像算法对于想在可视化方向深耕的小伙伴来说是很有必要的。 参考资料 D3 API 中文文档 D3 js in action 精通D3.js（第二版） D3.js 4.x Data Visualization(Third Edition) 图说D3数据可视化利器从入门到进阶","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://www.haoming.fun/categories/数据可视化/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://www.haoming.fun/tags/D3-js/"}],"author":"Peng Fang"},{"title":"D3.js数据可视化实践（讲义）","slug":"D3-js数据可视化实践（讲义）","date":"2018-06-29T11:01:00.000Z","updated":"2019-06-30T04:11:36.658Z","comments":true,"path":"2018/06/29/D3-js数据可视化实践（讲义）/","link":"","permalink":"https://www.haoming.fun/2018/06/29/D3-js数据可视化实践（讲义）/","excerpt":"","text":"D3数据可视化实践 方鹏 2018/06/29 目标了解D3常用API和重要知识点，能阅读和编写简单的D3.js可视化程序。 内容 D3简介 基础知识点（SVG + D3） 数据处理（涉及加载数据、处理数据） 数据绑定 交互 布局 什么是D3D3 全称是Data-Driven Document，直译为数据驱动文档。 数据由用户或开发者提供文档指的是基于web的文档，即Web浏览器可以渲染的任何元素，例如HTML、SVG它们由D3来驱动。从某种意义上说，它将文档和数据联系起来。 只要记住：D3是一个JavaScript函数库，是用来做数据可视化的。 其开源地址：https://github.com/d3/d3 用D3.js的创始人Mike Bostock的话说：D3提供了极度灵活，Web标准化的能力，例如CSS3, HTML5, SVG。试想用原生的HTML、SVG、Canvas来实现数据变成图形是困难和繁琐的。D3封装了这些能力，使开发者专注布局和逻辑。 D3简史 2011年2月，Mike Bostock发布了v1.0.0版本。 2012年12月，v3.0.0版本发布，网上3.x的资料比较多。 2016年6月，v4.0.0版本发布，开始支持Canvas，采用模块化设计模式。 D3的优势Echarts等封装层次很高，能够简单地制作图表，但是给予开发者控制和设计的空间较少。D3在这一点上取得了平衡。 相对比较底层数据和元素捆绑。DOM里含有数据，数据更新时重绘。同时支持SVG和Canvas。 更像数学库强大的图形计算能力，D3的“布局”封装了提供力直方图、饼图、树图、力导向图等。D3的“比例尺”提供线性、指数、对数、序数等多种关于对应关系的计算。还提供“地图”功能。 即封装操作，也给予自由计算和绘图相互独立。计算是算出节点的位置、线段端点、弧线角度等；绘图是将计算所得的节点、线段绘制到网页上。 应用截图如下： 适用范围数据可视化七个步骤：获取、解析、过滤、挖掘、表现、改善、交互表现、改善、交互属于D3的适用范围 它不能干什么 D3不能生成预定义的或者封装好的可视化效果，也就是不提供预先配置的图表类型。 D3不支持老的浏览器。 D3代码在客户端执行，因此不能隐藏源数据。如果担心数据泄露，最好不要可视化，可视化的目的是交流数据。 SVGSVG（可缩放矢量图形），除了IE8之前的版本外，绝大部分浏览器支持SVG，可以直接嵌入HTML显示。位图与矢量图的区别：位图缩放后失真，矢量图缩放不失真；位图色彩表现力较丰富，矢量图图形色彩较简单；矢量图占用空间较小，位图较大；矢量图容易转化为位图，反之不容易。 SVG图形元素SVG预定义七种形状元素：矩形&lt;rect&gt;、圆形&lt;circle&gt;、椭圆形&lt;ellipse&gt;、线段&lt;line&gt;、折线&lt;polyline&gt;、多边形&lt;polygon&gt;、路径&lt;path&gt;路径指令： M=moveto L=lineto H=horizontal lineto V=vertical lineto C=curveto 画三次贝塞尔曲线经两个指定控制点到达终点 S=smooth curveto 与前一条三次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称 Q=quadratic curveto 画二次贝塞尔曲线经一个指定控制点到达终点 T=smooth quadratic Bezier curvto 与前一条二次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称，只需输入终点，即可绘制一条二次贝塞尔曲线示例 文字在SVG中可以使用&lt;text&gt;标签绘制文字dx: 相对当前位置在x方向上平移的距离，dy同理。text-anchor属性 1234&lt;text class=\"label-2\" text-anchor=\"end\" dy=\".35em\" rank=\"B\"&gt; &lt;tspan x=\"0\" dy=\"0.35em\"&gt;(不知情定制B004)内容战&lt;/tspan&gt; &lt;tspan x=\"0\" dy=\"1.0499999999999998em\"&gt;略合作伙伴分类不合规&lt;/tspan&gt;&lt;/text&gt; D3数据选择和属性设定我们要对DOM中的元素执行一个行为，例如移动位置，改变颜色,更新数据中的值，首先要选中它。d3.select()是选中单个元素；d3.selectAll()是选中多个元素。选择集是一个或多个页面元素的组合，能够与数据集相关联。利用D3提供的方法设置元素属性和样式值： 123d3.selectAll(\"circle.a\").style(\"fill\", \"red\").attr(\"cx\", 100)d3.select(\"circle\").attr(\"class\", \"active\");d3.select(\"circle\").classed(\"active\", true); // 添加或者移除命名的样式 有部分属性不能用attr()设定和获取，最典型的就是文本框的value属性，这样情况可以用property()来设定，例如： 1d3.select(\"#someCheckbox\").property(\"checked\", true); 方法链，也叫链式调用。和JQuery写法类似。 1d3.selectAll(\"div\").data(someData).enter().append(\"div\").html(\"Wow\").append(\"span\").html(\"Even More Wow\").style(\"font-weight\", \"900\"); 可以给.style(), .attr(), .property(), .html()设置匿名函数调用或者其他提供数据绑定的选择器的函数。 123456789var someColors = [\"blue\", \"red\", \"chartreuse\", \"orange\"];someColors = someColors.filter(function(d) &#123;return d.length &lt; 5&#125;);d3.select(\"body\").selectAll(\"div\") .data(someColors) .enter() .append(\"div\") .style(\"background\", function(d) &#123;return d&#125;) .attr(\"cx\", function(d,i) &#123;return i&#125;) .html(function(d) &#123;return d&#125;) Hello World 示例 使用数据D3数据处理流程： 加载数据D3提供几个方法来导入和处理数据。一样的是，d3.csv()和d3.json()生成一个JSON对象数组，而d3.xml()会创建一个XML文档。 12d3.csv(\"cities.csv\", (error, data) =&gt; &#123; console.log(error, data) &#125;);d3.json(\"tweets.json\", data =&gt; console.log(data)); error变量是可选项 数据格式化 数据映射数字数据仅仅同图形化元素在屏幕上的尺寸和位置相关。Scales（比例尺）有一个定义域domain和一个值域range。我们使用d3.scale()函数来归一化数据。例如我们通过线性比例尺，将 500,000到13,000,000的城市人口相同的线性变化映射到0到500px宽的画布上。12345678var newRamp = d3.scaleLinear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // 返回20，可以将一千万人口的国家放在20px处newRamp(9000000); // 返回340newRamp.invert(313); // 求逆，返回8325000var newRamp = d3.scaleLinear().domain([500000,13000000]).range([\"blue\", \"red\"]);newRamp(1000000); // 返回\"#0a00f5\"，可以将一百万人口的城市用深紫色表示newRamp(9000000); // 返回\"#ad0052\"newRamp.invert(\"#ad0052\"); // 因为invert函数只接受数字，因此返回NaN 我们也能使用d3.scaleLog(), d3.scalePow(), d3.scaleOrdinal()等其他对数据集来说更加适合的比例尺来映射数据。 数据分类将定量数据分类，是将值按范围分或者组装到一起。一种分类方法是将数组均分几份。12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scaleQuantile().domain(sampleArray).range([0,1,2]);qScale(423); // 返回2qScale(20); // 返回0qScale(10000); // 返回2 嵌套允许数组中的元素被组织为分层树型结构；类似SQL语句里面的GROUP BY方法。下面的例子，将示例数据首先按year分组再按variety分组，如下： 12345678var yields = [&#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]var nest = d3.nest() .key(function(d) &#123; return d.year; &#125;) .key(function(d) &#123; return d.variety; &#125;) .entries(yields); 返回的嵌套数组中,以键值对的形式对数据进行分组: 123456789[&#123;key: 1931, values: [ &#123;key: \"Manchuria\", values: [ &#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]&#125;, &#123;key: \"Glabron\", values: [ &#123;yield: 43.07, variety: \"Glabron\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 55.20, variety: \"Glabron\", year: 1931, site: \"Waseca\"&#125;, ...]&#125;, ...]&#125;, &#123;key: 1932, values: ...&#125;] 在数据格式化以后，需要测量它，以确保创建的图形尺寸合适，位置是基于数据集的参数。那你将会一直用到d3.extent，d3.min，d3.max，d3.mean。 测量数据在加载你的数据以后，首要的事情之一是应该对数据进行测量和排序。很重要的是知道特殊属性值的分布，以及最大最小值和属性名称。D3提供一个数组的函数集合能帮助理解数据。加入想从cities.csv获取城市人口的最小，最大，平均值： 12345d3.csv(\"cities.csv\", data =&gt; &#123; d3.min(data, el =&gt; +el.population); d3.max(data, el =&gt; +el.population); d3.mean(data, el =&gt; +el.population);&#125;); d3.extent方便地将d3.min()和d3.max()在一个数组中返回： 1d3.extent(data, el =&gt; +el.population); // 返回[500000, 1300000] 现在，我们已经加载、格式化、测量了我们的数据，那我们就可以创建数据可视化了。 简单数据可视化示例 数据可视化接下来将更深入解释选择器是如何与数据绑定一起创建元素的，以及创建后如何改变这些元素。 data工作过程一个选择集是由DOM中一个或多个元素构成。能使用选择器创建和删除元素，更改样式和内容。 123456789101112131415d3.csv(\"cities.csv\", (error,data) =&gt; &#123; if (error) &#123; console.error(error) &#125; else &#123; dataViz(data) &#125;&#125;);function dataViz(incomingData) &#123; d3.select(\"body\").selectAll(\"div.cities\") .data(incomingData) // 绑定数据到选择集 .enter() // 定义当选择集中的数据多于DOM元素时如何响应 .append(\"div\") // 在当前选择集中创建一个元素 .attr(\"class\", \"cities\") // 设置新创建元素class .html(d =&gt; d.label); // 设置创建div的内容&#125; 经常传入id没有匹配到任何元素，那么称其为空选择集。当数据值的数量大于选择器中元素的数量，.enter()函数触发，允许你为每一个没有相应DOM元素的值定义一个执行行为。这里需要将选中的DOM元素同一个数组联系起来。数据集里的每一个城市同选择集中的一个DOM元素相联系，关联数据是存在元素的data属性中。 1document.getElementsByClassName(\"cities\")[0].__data__ // 返回一个指向对象的指针 如果数组长度大于元素数量，则部分还不存在的元素“即将进入可视化（enter）” 如果数组长度小于元素数量，则多余的元素“即将退出可视化（exit）” 如果数组长度等于元素数量，则绑定数据的元素“即将被更新（update）” 大多数情况，.enter()函数触发，使用.append()来添加元素；.exit()函数触发，使用.remove()来移除元素。 文档驱动设计及交互D3v4 有几个方法帮助DOM上下移动：selection.raise 和 selection.lower. 使用这些方法来移动选择的元素到DOM兄弟节点的末尾或者移动到开头位置。 12d3.select(\"g.overallG\").raise()d3.select(\"g.overallG\").lower() 禁用元素的鼠标事件： 1teamG.select(\"text\").style(\"pointer-events\",\"none\"); 使用颜色d3.rbg()的使用如下： 1234teamColor = d3.rgb(\"red\");teamColor = d3.rgb(\"#ff0000\");teamColor = d3.rgb(\"rgb(255,0,0)\");teamColor = d3.rgb(255,0,0); 这些颜色对象有两个有用的方法：.darker() 和 .brighter()，返回比初始值更亮或更暗的值。 123d3.selectAll(\"g.overallG\").select(\"circle\") .style(\"fill\", p =&gt; p.region === d.region ? teamColor.darker(.75) : teamColor.brighter(.5)) // rgb.brighter([k]),每个颜色通道值将乘以0.7 ^ -k d3.hsl, d3.lab, d3.cubehelix, d3.hcl可以呈现不同的颜色空间D3支持颜色插值 123var ybRamp = d3.scaleLinear() .interpolate(d3.interpolateHsl) .domain([0, maxValue]).range([\"yellow\", \"blue\"]); 离散颜色比例尺：d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, and d3.schemeCategory20c序数比例尺，映射离散值为特殊的颜色。一个有用的特征是它的unknown方法，当传入一个不存在的值的时候，返回设定值。Color Scales 1234var tenColorScale = d3.scaleOrdinal() .domain([\"UEFA\", \"CONMEBOL\"]) .range(d3.schemeCategory10) .unknown(\"#c4b9ac\") 监听器D3选择器可以通过on来为事件添加监听器：selection.on(type[, listener[, capture]]) 123selection.on(\"click\", function () &#123; console.log(d3.mouse(this)); // 输出相对坐标&#125;) 在当前选择的每个元素，为指定的类型type，添加或删除事件监听器listener 。type是一个字符串事件类型的名称，如“click”、“mouseover”、“keydown”、“touchstart”。基本上支持任何DOM事件，如鼠标、键盘、触屏事件。为了在侦听器内访问当前事件，使用全局函数d3.event。 如果所选择的元素相同类型的一个事件监听已经注册了，新的侦听加入之前的现有侦听被除去。为注册相同事件类型的多个监听器，该类型可以跟一个可选的命名空间，如“click.first”和“click.second”。 要删除一个监听器，传递null给listener如：selection.on(click”, null)。 行为下面给出拖拽和缩放的例子：拖拽简单示例缩放简单示例 布局D3 3.x提供了12种布局：饼状图（Pie）、力导向图（Force）、弦图（Chord）、树图（Tree）、集群图（Cluster）、捆图（Bundle）、打包图（Pack）、直方图（Histogram）、分区图（Partition）、堆栈图（Stack）、矩阵树图（Treemap）、层级图（Hierarchy） 力导向图力导向图（Force-Directed Graph），是绘图的一种算法。d3-force, 力布局这个模块基于Verlet integration(韦尔莱积分法)实现了物理粒子之间的作用力的仿真。模拟的作用力有电荷之间的吸引排斥力，重力，链接吸引力。 力导向图示例 项目案例分析参考资料 D3 API 中文文档 D3 js in action 精通D3.js（第二版） D3.js 4.x Data Visualization(Third Edition) 图说D3数据可视化利器从入门到进阶","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://www.haoming.fun/categories/数据可视化/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://www.haoming.fun/tags/D3-js/"}],"author":"Peng Fang"},{"title":"《D3.js in Action Data visualization with JavaScript(2nd)》部分章节摘要","slug":"《D3-js-in-Action-Data-visualization-with-JavaScript-2nd-》部分章节摘要","date":"2018-06-27T10:58:00.000Z","updated":"2019-06-30T04:11:36.664Z","comments":true,"path":"2018/06/27/《D3-js-in-Action-Data-visualization-with-JavaScript-2nd-》部分章节摘要/","link":"","permalink":"https://www.haoming.fun/2018/06/27/《D3-js-in-Action-Data-visualization-with-JavaScript-2nd-》部分章节摘要/","excerpt":"","text":"什么是D3为满足Web可访问的，复杂的数据可视化需求而生。假如你公司使用了BI工具，但是他们不能满足团队需求用来显示数据的类型模式。那么你就需要量身定制地构建一个客户化的看板来精确展示具体领域客户的行为。这个数据看板需要快速、可交互、能在组织内分享。那么可以使用D3来做这个事情。D3.js的创始人Mike Bostock，用他的话说：提供极度灵活，Web标准化的能力，例如CSS3,HTML5,SVG. 最新迭代版本D3.v4 D3怎样工作怎样使用D3来处理和呈现数据，也是增加交互性，优化数据可视化。理解D3选择器、数据绑定、D3怎样与DOM中的SVG和HTML交互。 数据可视化不仅仅是图表你或许认为数据可视化仅限于饼图、线图、以及其他各类图表。远远不止如此。D3.js核心能力之一是为传统图表创建矢量图形，创建地理空间和网络可视化，以及丰富的动画和交互性。数据可视化这种广泛的方法中，地图或者网络图谱或表格是数据的一种表现形式，也是D3.js库提供的核心能力。学习D3是因为它提供能力实现几乎每个主要的数据可视化技术，也提供能力创建你自己的数据可视化技术。 D3数据选择和绑定selection是数据和元素的组合。我们对group中的元素执行一个行为，例如移动或者改变颜色。同样也可以更新数据中的值。尽管我们以页面元素和数据分离的方式工作，D3真正强大来自于使用选择器来合并数据和web页面元素。 1d3.selectAll(\"circle.a\").style(\"fill\", \"red\").attr(\"cx\", 100) 使用d3.select()选择单个元素；使用d3.selectAll()选中多个元素选择器是一个或多个页面元素的组合能够与数据集相关联，例如下面的代码是绑定数组[1,5,11,3]元素到样式名为market的div： 1d3.selectAll(\"div.market\").data([1,5,11,3]) D3遍历选择器中的元素，使用绑定数据执行相同的行为，导致不同的图形化效果。行为相同，效果不同。决定一个元素的行为和呈现分别是：样式、属性attributes、特性properties。样式决定不透明度、颜色、尺寸、边框等。属性包含ID、类名、交互行为。特性涉及状态，例如单选框的选中。D3有三个函数来定义这些值： 123d3.select(\"#someDiv\").style(\"border\", \"5px darkgray dashed\");d3.select(\"#someDiv\").attr(\"id\", \"newID\");d3.select(\"#someCheckbox\").property(\"checked\", true); DOM决定了元素在屏幕上的绘制顺序，孩子元素在父元素的里面及之后绘制。尽管传统HTML中可以使用z-index来控制，但是在SVG2规范实现之前，设置z-index对SVG元素来说不管用。 SVGHTML5一个主要的特性就是集成支持SVG。SVG允许图像简单的数字呈现如缩放，这并应用到动画和交互中。D3提供一个抽象层绘制SVG。SVG绘制复杂形状的指令如路径，从画布的一个点开始向另一个点画线。如果想绘制曲线，将绘制曲线的坐标设置为path的d属性。 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;script src=\"d3.v4.min.js\"&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=\"infovizDiv\"&gt;&lt;svg style=\"width:500px;height:500px;border:1px lightgray solid;\"&gt;&lt;path d=\"M 10,60 40,30 50,50 60,30 70,80\"style=\"fill:black;stroke:gray;stroke-width:4px;\" /&gt;&lt;polygon style=\"fill:gray;\"points=\"80,400 120,400 160,440 120,480 60,460\" /&gt;&lt;g&gt;&lt;line x1=\"200\" y1=\"100\" x2=\"450\" y2=\"225\"style=\"stroke:black;stroke-width:2px;\"/&gt;&lt;circle cy=\"100\" cx=\"200\" r=\"30\"/&gt;&lt;rect x=\"410\" y=\"200\" width=\"100\" height=\"50\"style=\"fill:pink;stroke:black;stroke-width:1px;\" /&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; svg提供一系列的通用形状集合：&lt;CIRCLE&gt;, &lt;RECT&gt;, &lt;LINE&gt;, &lt;POLYGON&gt;，每个形状都有元素决定它的尺寸和位置。&lt;RECT&gt;有x和y属性决定形状左上角的位置。&lt;CIRCLE&gt;的x和y属性决定圆心的位置，r属性决定圆半径。&lt;LINE&gt;x1和y1作为起点坐标，x2和y2决定中的坐标位置。任何形状的颜色、外轮廓、不透明度能被改变来适应形状的样式，fill决定形状区域的颜色，stroke,stroke-width,stroke-dasharray决定其外轮廓。能像下面这样改变矩形的样式： 1fill:purple;stroke-width:5px;stroke:cornflowerblue; &lt;TEXT&gt;,SVG提供写文本的能力。如果想要实现基本的格式化，可以在&lt;TEXT&gt;中嵌套&lt;TSPAN&gt;。&lt;G&gt;或者组元素，区别于之前的SVG元素，它没有图形化呈现的能力，不存在一个边界空间。可以使用它来表示一个逻辑分组。当创建一个图形对象，有几个形状的图形和文本组成，就可以将它们放在&lt;G&gt;标签内。在画板内移动&lt;G&gt;元素，可以通过transform属性，它接受一个结构化的描述就是translate()，传一对坐标x和y，表示其向右和向下移动的像素数。transform属性还接受scale()，用来改变图形渲染的比例。 CSS.css文件能被引入到HTML页当中，或者直接嵌入HTML当中，或者同js控制。 123d3.select(#someElement).style(opacity, .5);d3.select(\"circle\").attr(\"class\", \"tentative\");d3.select(\"circle\").classed(\"active\", true); 通过.classed()，不必重写存在的样式，而是从样式列表中添加或者移除命名的样式。 JavaScript方法链，也叫链式调用。这和我们平时聊天有点像。 1d3.selectAll(\"div\").data(someData).enter().append(\"div\").html(\"Wow\").append(\"span\").html(\"Even More Wow\").style(\"font-weight\", \"900\"); 可以给.style(), .attr(), .property(), .html()设置匿名函数调用或者其他提供数据绑定的选择器的函数。 123456789var someColors = [\"blue\", \"red\", \"chartreuse\", \"orange\"];someColors = someColors.filter(function(d) &#123;return d.length &lt; 5&#125;);d3.select(\"body\").selectAll(\"div\").data(someColors).enter().append(\"div\").style(\"background\", function(d) &#123;return d&#125;).attr(\"cx\", function(d,i) &#123;return i&#125;).html(function(d) &#123;return d&#125;) 数据标准因为不同目的数据被格式化为不同的形式，但是它倾向存在于我们认识的类型：表格数据，嵌套数据，网络数据，地理数据，裸数据，对象。 第一个D3 APP1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;&lt;script src=\"https://d3js.org/d3.v4.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"vizcontainer\"&gt;&lt;svg style=\"width:500px;height:500px;border:1px lightgray solid;\" /&gt;&lt;script&gt;d3.select(\"svg\").append(\"circle\").attr(\"r\", 20).attr(\"cx\",20).attr(\"cy\",20).style(\"fill\",\"red\");d3.select(\"svg\").append(\"text\").attr(\"id\", \"a\").attr(\"x\",20).attr(\"y\",20).style(\"opacity\", 0).text(\"HELLO WORLD\");d3.select(\"svg\").append(\"circle\").attr(\"r\", 100).attr(\"cx\",400).attr(\"cy\",400).style(\"fill\",\"lightblue\");d3.select(\"svg\").append(\"text\").attr(\"id\", \"b\").attr(\"x\",400).attr(\"y\",400).style(\"opacity\", 0).text(\"Uh, hi.\");d3.select(\"#a\").transition().delay(1000).style(\"opacity\", 1);d3.select(\"#b\").transition().delay(3000).style(\"opacity\", .75);d3.selectAll(\"circle\").transition().duration(2000).attr(\"cy\", 200);&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用数据 加载数据不管什么样的数据源，都可能被格式化成XML，CSV，或者JSON这样的格式。D3提供几个方法来导入和处理数据。一样的是，d3.csv()和d3.json()生成一个JSON对象数组，而d3.xml()会创建一个XML文档。 12d3.csv(\"cities.csv\", (error,data) =&gt; &#123; console.log(error, data) &#125;);d3.json(\"tweets.json\", data =&gt; console.log(data)); error变量是可选项 数据格式化在我们加载数据集以后，我们需要定义方法以致于数据的属性同颜色、尺寸和位置的设定相关。比如想展示导入的CSV文件格式的城市数据，假如使用圆来表示，根据人口数量来设置圆的大小，根据几何坐标设置位置。在做数据可视化的时候，我们需要理解数据形式，通常可以分为数量的，类别的，几何的，临时的，拓扑的或者未加工的。 进一步更改数据数字数据仅仅同图形化元素在屏幕上的尺寸和位置相关。使用d3.scale()函数来归一化数据。Scales（比例尺）有一个定义域domain和一个值域range。例如，从cities.csv里面取出人口数字的最小值和最大值，通过线性比例尺我们能将它们的不同很容易地展示到500px的画布上。下图所示，将 500,000到13,000,000相同的线性变化映射到0到500. 12345678var newRamp = d3.scaleLinear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // 返回20，可以将一千万人口的国家放在20px处newRamp(9000000); // 返回340newRamp.invert(313); // 求逆，返回8325000var newRamp = d3.scaleLinear().domain([500000,13000000]).range([\"blue\", \"red\"]);newRamp(1000000); // 返回\"#0a00f5\"，可以将一百万人口的城市用深紫色表示newRamp(9000000); // 返回\"#ad0052\"newRamp.invert(\"#ad0052\"); // 因为invert函数只接受数字，因此返回NaN 我们也能使用d3.scaleLog(), d3.scalePow(),d3.scaleOrdinal(), 以及其他不太通用但对数据集来说更加适合的比例尺来映射数据。将定量数据分类，将值按范围分或者组装到一起，是挺有用的。一种分类方法是将数组均分几份。 12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scaleQuantile().domain(sampleArray).range([0,1,2]);qScale(423); // 返回2qScale(20); // 返回0qScale(10000); // 返回2 嵌套背后的观点是数据的共享属性能被用来排序成离散的类别和子类。 123456d3.json(\"tweets.json\", data =&gt; &#123;var tweetData = data.tweets;var nestedTweets = d3.nest().key(d =&gt; d.user).entries(tweetData);&#125;); d3.nest()合并推特账户到新的对象下的数组，这些新对象由唯一的用户属性值标记。在数据格式化以后，需要测量它，以确保创建的图形尺寸合适，位置是基于数据集的参数。那你将会一直用到d3.extent，d3.min，d3.max，d3.mean. 测量数据在加载你的数据以后，首页的事情之一是你应该将它测量和排序。很重要的是知道特殊属性值的分布，以及最大最小值和属性名称。D3提供一个数组的函数集合能帮助你理解数据。 1234var testArray = [88,10000,1,75,12,35];d3.min(testArray, el =&gt; el); // return 1d3.max(testArray, el =&gt; el); // 返回10000d3.mean(testArray, el =&gt; el); // 返回平均值1701.83 加入想从cities.csv获取人口的最小，最大，平均值： 12345d3.csv(\"cities.csv\", data =&gt; &#123; d3.min(data, el =&gt; +el.population); d3.max(data, el =&gt; +el.population); d3.mean(data, el =&gt; +el.population);&#125;); d3.extent方便地将d3.min()和d3.max()在一个数组中返回： 1d3.extent(data, el =&gt; +el.population); // 返回[500000, 1300000] 现在，我们已经加载、格式化、测量了我们的数据，那我们就可以创建数据可视化了。 数据可视化接下来将更深入解释选择器是如何与数据绑定一起创建元素的，以及创建后如何改变这些元素。第一个例子使用cities.csv中的数据。 选择器及绑定使用D3选择器来改变web页的结构和呈现。一个选择器是由DOM中一个或多个元素构成。你能使用选择器创建和删除元素，更改样式和内容。 12345678910111213141516d3.csv(\"cities.csv\", (error,data) =&gt; &#123; if (error) &#123; console.error(error) &#125; else &#123; dataViz(data) &#125;&#125;);function dataViz(incomingData) &#123; d3.select(\"body\").selectAll(\"div.cities\") .data(incomingData) // 绑定数据到选择器 .enter() // 定义当选择中的数据多于DOM元素时如何响应 .append(\"div\") // 在当前选择器中创建一个元素 .attr(\"class\", \"cities\") // 设置新创建元素class .html(d =&gt; d.label); // 设置创建div的内容&#125; d3.selectAll()传入对应于DOM一部分的CSS id选择器。经常传入id没有匹配到任何元素，那么称其为空选择器，使用.enter()函数在页面上创建新元素。需要指明一个选择器如何创建或更改一个具体DOM元素的孩子元素。注意子选项不会自动生成父节点。父亲必须已经存在，或者需要使用.append()创建一个。这里需要将选中的DOM元素同一个数组联系起来。数据集里的每一个城市通选中器中的一个DOM元素想联系，关联数据是存在元素的data属性中。 1document.getElementsByClassName(\"cities\")[0].__data__ // 返回一个指向对象的指针 当数据值的数量大于选择器中元素的数量，.enter()函数触发，允许你为每一个没有相应DOM元素的值定义一个执行行为。当存在的数据值比较少，.enter()函数会触发当两者数量一样，则都不会触发当你知道将不会有更少的数据元素，则不必为.exit()定义处理行为。.append()函数允许你添加更多元素，定义添加哪个元素。通过.insert()你能控制新元素添加的地方。.attr()函数是用来改变样式和属性.html()函数可以设置DOM元素的内容 使用内联函数访问数据在选择器中使用一个内联匿名函数，自动提供两个变量的访问，这对数据呈现很关键。一个是数据值本身，一个是该数据在数组中的位置。直方图是分类表达数据数值最简单最有效的方法。 1234567891011d3.select(\"svg\") .selectAll(\"rect\") .data([15, 50, 22, 8, 100, 10]) .enter() .append(\"rect\") .attr(\"height\", d =&gt; d) .style(\"fill\", \"#FE9922\") .style(\"stroke\", \"#9A8B7A\") .style(\"stroke-width\", \"1px\") .attr(\"x\", (d,i) =&gt; i * 10) .attr(\"y\", d =&gt; 100 - d); 多线性比例尺是在domain和range带有多个点的线性比例尺。比如我们对1到100范围内的值特别感兴趣，对100到1000内的值有时候感兴趣。偶尔会得到相当大的异常值。我们能这样表示： 12var yScale = d3.scaleLinear().domain([0,100,1000,24500]).range([0,50,75,100]); 例如，有一些调查返回的数据，我们认为大于500就表示成功。我们仅仅想显示0到500内的数据，同时用比例尺强调0到100的变化。 12var yScale = d3.scaleLinear().domain([0,100,500]).range([0,50,100]);yScale(1000); // 返回162.5 通常D3比例尺会推断最小值到最大值之外的值。如果想设置小于最小值的取最小值，大于最大值的取最大值。可以使用.clamp()函数： 12345var yScale = d3.scaleLinear() .domain([0,100,500]) .range([0,50,100]) .clamp(true);yScale(1000); // 返回100 scale函数使决定位置、尺寸、数据可视化元素颜色的关键。 数据呈现123456789101112131415161718d3.csv(\"cities.csv\",(error, data) =&gt; &#123; dataViz(data) &#125;);function dataViz(incomingData) &#123; var maxPopulation = d3.max(incomingData, d =&gt; parseInt(d.population)) // 人口数最大值 var yScale = d3.scaleLinear().domain([0, maxPopulation]).range([0,460]); d3.select(\"svg\").attr(\"style\", \"height: 480px; width: 600px;\"); d3.select(\"svg\") .selectAll(\"rect\") .data(incomingData) .enter() .append(\"rect\") .attr(\"width\", 50) .attr(\"height\", d =&gt; yScale(parseInt(d.population))) .attr(\"x\", (d,i) =&gt; i * 60) .attr(\"y\", d =&gt; 480 - yScale(parseInt(d.population))) .style(\"fill\", \"#FE9922\") .style(\"stroke\", \"#9A8B7A\") .style(\"stroke-width\", \"1px\")&#125; 1234567891011121314151617181920212223d3.json(\"tweets.json\",(error, data) =&gt; &#123; dataViz(data.tweets) &#125;); function dataViz(incomingData) &#123; var nestedTweets = d3.nest() .key(d =&gt; d.user) .entries(incomingData); nestedTweets.forEach(d =&gt; &#123; d.numTweets = d.values.length; // 创建一个新属性 &#125;) var maxTweets = d3.max(nestedTweets, d =&gt; d.numTweets); var yScale = d3.scaleLinear().domain([0,maxTweets]).range([0,500]); d3.select(\"svg\") .selectAll(\"rect\") .data(nestedTweets) .enter() .append(\"rect\") .attr(\"width\", 50) .attr(\"height\", d =&gt; yScale(d.numTweets)) .attr(\"x\", (d,i) =&gt; i * 60) .attr(\"y\", d =&gt; 500 - yScale(d.numTweets)) .style(\"fill\", \"#FE9922\") .style(\"stroke\", \"#9A8B7A\") .style(\"stroke-width\", \"1px\");&#125; 设置通道channel多变量是另一种表示具有多个数据特征的数据点的方式。channel是一个图形如何直观表达数据的技术术语，它取决于你正在使用的数据，不同的通道适用于来表达不同的数据可视化。下面通过时间和影响因子两个维度来呈现数据： 12345678910111213141516171819202122232425function dataViz(incomingData) &#123; incomingData.forEach(d =&gt; &#123; d.impact = d.favorites.length + d.retweets.length; d.tweetTime = new Date(d.timestamp); &#125;) var maxImpact = d3.max(incomingData, d =&gt; d.impact); var startEnd = d3.extent(incomingData, d =&gt; d.tweetTime); var timeRamp = d3.scaleTime().domain(startEnd).range([20, 480]); var yScale = d3.scaleLinear().domain([0, maxImpact]).range([0, 460]); var radiusScale = d3.scaleLinear() .domain([0, maxImpact]).range([1, 20]); var colorScale = d3.scaleLinear() .domain([0, maxImpact]).range([\"white\", \"#75739F\"]); d3.select(\"svg\") .selectAll(\"circle\") .data(incomingData) .enter() .append(\"circle\") .attr(\"r\", d =&gt; radiusScale(d.impact)) .attr(\"cx\", d =&gt; timeRamp(d.tweetTime)) .attr(\"cy\", d =&gt; 480 - yScale(d.impact)) .style(\"fill\", d =&gt; colorScale(d.impact)) .style(\"stroke\", \"black\") .style(\"stroke-width\", \"1px\"); &#125;; Enter, update, mergem, exit.enter()已经用到很多次了。现在让我们近距离看看它， 以及与它配对的.exit()。它们只有在绑定数据个数和选择器中DOM元素个数不匹配时才会触发。使用selection.enter() 定义怎样基于绑定数据创建新元素，使用selection.exit()定义元素相关的数据被删除时，如何移除选择器中的元素。更新绑定数据时，会基于数据重新创建图形元素。大多数情况，使用.enter()事件，就会使用.append()来添加元素。 1d3.selectAll(\"g\").data([1,2,3,4]).exit().remove(); 这个代码会删除四个元素。选择器前四个元素绑定了新数据，其余的属于.exit()函数。大多数情况下，不会遇到这样的绑定数组完全不同情况，一般通过用户交互或者其他行为触发数据过滤界面呈现变化后会看到初始化数据的重新绑定。d3.merge()允许合并两个选择器，以致于可以同时操作它们。通常.data()绑定基于数据值在数组中的位置。如果不想依赖位置，而是依赖你绑定的键值，使用有意义的键值，例如数据对象本身的值。所有对象都被当做[object object]对待，所有可以使用JSON.stringify函数。 1234567891011121314151617181920212223242526272829function dataViz(incomingData) &#123; incomingData.forEach(d =&gt; &#123; d.impact = d.favorites.length + d.retweets.length; d.tweetTime = new Date(d.timestamp); &#125;) var maxImpact = d3.max(incomingData, d =&gt; d.impact) var startEnd = d3.extent(incomingData, d =&gt; d.tweetTime) var timeRamp = d3.scaleTime().domain(startEnd).range([ 50, 450 ]); var yScale = d3.scaleLinear().domain([ 0, maxImpact ]).range([ 0, 460 ]); var radiusScale = d3.scaleLinear() .domain([ 0, maxImpact ]) .range([ 1, 20 ]); d3.select(\"svg\").selectAll(\"circle\") .data(incomingData, JSON.stringify) .enter().append(\"circle\") .attr(\"r\", d =&gt; radiusScale(d.impact)) .attr(\"cx\", d =&gt; timeRamp(d.tweetTime)) .attr(\"cy\", d =&gt; 480 - yScale(d.impact)) .style(\"fill\", \"#75739F \") .style(\"stroke\", \"black\") .style(\"stroke-width\", \"1px\"); var filteredData = incomingData.filter(d =&gt; d.impact &gt; 0) d3.selectAll(\"circle\") .data(filteredData, d =&gt; JSON.stringify(d)) .exit() .remove();&#125;以上代码，会将影响因子不大于0的元素移除。如果使用转化为字符串的对象，改变数据的话将不起作用，因为它不再与原始绑定的字符串相关。如果计划做重要的改变和更新，数据对象需要一个唯一ID作为绑定键值。 文档驱动设计及交互D3v4 有几个方法帮助DOM上下移动：selection.raise 和 selection.lower. 使用这些方法来移动选择的元素到DOM兄弟节点的末尾或者移动到开头位置。 12d3.select(\"g.overallG\").raise()d3.select(\"g.overallG\").lower() 禁用元素的鼠标事件： 1teamG.select(\"text\").style(\"pointer-events\",\"none\"); 使用颜色d3.rbg()的使用如下： 1234teamColor = d3.rgb(\"red\");teamColor = d3.rgb(\"#ff0000\");teamColor = d3.rgb(\"rgb(255,0,0)\");teamColor = d3.rgb(255,0,0); 这些颜色对象有两个有用的方法：.darker() 和 .brighter()，返回比初始值更亮或更暗的值。 123d3.selectAll(\"g.overallG\").select(\"circle\") .style(\"fill\", p =&gt; p.region === d.region ? teamColor.darker(.75) : teamColor.brighter(.5)) d3.hsl, d3.lab, d3.cubehelix, d3.hcl可以呈现不同的颜色空间D3支持颜色插值 123var ybRamp = d3.scaleLinear() .interpolate(d3.interpolateHsl) .domain([0,maxValue]).range([\"yellow\", \"blue\"]); 离散颜色比例尺：d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, and d3.schemeCategory20c序数比例尺，映射离散值为特殊的颜色。一个有用的特征是它的unknown方法，当传入一个不存在的值的时候，返回灰色值。 1234var tenColorScale = d3.scaleOrdinal() .domain([\"UEFA\", \"CONMEBOL\"]) .range(d3.schemeCategory10) .unknown(\"#c4b9ac\") 预生成内容图片使用insert()替代append()，是告诉D3在文本元素前面嵌入图片，使得标签文字在新添加的图片后被绘制。 1234d3.selectAll(\"g.overallG\").insert(\"image\", \"text\") .attr(\"xlink:href\", d =&gt; `images/$&#123;d.team&#125;.png`) .attr(\"width\", \"45px\").attr(\"height\", \"20px\") .attr(\"x\", -22).attr(\"y\", -10) SVG1234567891011d3.html(\"resources/icon_1907.svg\", loadSVG);function loadSVG(svgData) &#123; d3.selectAll(\"g\").each(function() &#123; var gParent = this; d3.select(svgData).selectAll(\"path\").each(function() &#123; gParent.appendChild(this.cloneNode(true)) &#125;); &#125;);&#125;;d3.selectAll(\"path\").style(\"fill\", \"#93C464\") .style(\"stroke\", \"black\").style(\"stroke-width\", \"1px\"); 效果图 参考资料 D3 js in action","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://www.haoming.fun/categories/数据可视化/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://www.haoming.fun/tags/D3-js/"}],"author":"Peng Fang"},{"title":"HTTPS证书及Nginx配置相关","slug":"HTTPS证书及Nginx配置相关","date":"2018-06-08T10:11:00.000Z","updated":"2019-06-30T04:11:36.659Z","comments":true,"path":"2018/06/08/HTTPS证书及Nginx配置相关/","link":"","permalink":"https://www.haoming.fun/2018/06/08/HTTPS证书及Nginx配置相关/","excerpt":"","text":"本文档包括：Nginx支持HTTPS，自签名证书生成，配置Nginx支持HTTPS，客户端证书导入。作者：方鹏 Nginx安装SSL模块 安装依赖包 1yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel 执行编译解压安装包，进入目录，执行命令： 12./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake install 自签名证书生成 [root@vultr ~]# openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout bcp.key -out bcp.crt Generating a 2048 bit RSA private key ...................................................&gt; ................................+++ ....................+++ writing new private key to &apos;bcp.key&apos; ------ You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &apos;.&apos;, the field will be left blank. Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:SICHUAN Locality Name (eg, city) [Default City]:CHENGDU Organization Name (eg, company) [Default Company Ltd]:MIGU Organizational Unit Name (eg, section) []:TSG Common Name (eg, your name or your server&apos;s hostname) []:10.146.50.22 #注意：这里填服务端的IP地址 Email Address []:fangpeng@address.cn 配置Nginx支持HTTPS12345678910111213141516171819202122# HTTPS server server &#123; listen 443 ssl; server_name localhost; ssl on; ssl_certificate /usr/local/nginx/key/bcp.crt; #证书文件存放路径 ssl_certificate_key /usr/local/nginx/key/bcp.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:8080/; #后端服务地址 proxy_redirect off; &#125; &#125; 客户端证书导入如果在调用服务的客户端没有导入自签名证书，那么可能在接口调用时会出现如下错误： 12sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 导入证书： 1keytool -import -alias $&#123;alias&#125; -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -file $&#123;path-to-certificate-file&#125; 12cd $&#123;JAVA_HOME&#125;/jre/lib/security/sudo keytool -import -alias 5022-cert -keystore cacerts -file ~/server.crt server.crt：服务端自签名的证书文件keystore密码：默认changit如果导入过证书，alias相同，会出现错误提示：Certificate not imported, alias &lt;xxx&gt; already exists.从keystone删除证书： 1sudo keytool -delete -keystore cacerts -alias &apos;bcp-cert&apos; 导入后调用依然出现异常： 1javax.net.ssl.SSLException: Certificate for XXX doesn&apos;t match common name of the certificate subject: XXX 原因：需要连接服务器的域名或IP和证书中的common name不一致。重新生成证书，Common Name 填服务器IP。 证书文件也可以通过命令请求远端站点获取 获取远程网站（服务器）的根证书和中间证书 1openssl s_client -showcerts -connect 10.146.50.22:443 保存证书文件保存证书hash（上图中包含–BEGIN CERTIFICATE–到–END CERTIFICATE–部分）为文件，例如server.crt 证书导入keystore使用keytool import 命令导入根证书和中间证书到JAVA信任的根证书中（通常叫cacerts) 1sudo keytool -importcert -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -storepass changeit -file ~/server.crt -alias &quot;5022-cert&quot; 证书添加到keystore参考文章","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.haoming.fun/categories/Nginx/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.haoming.fun/tags/HTTPS/"}],"author":"Peng Fang"},{"title":"从接口调用安全考虑","slug":"从接口调用安全考虑","date":"2018-05-17T10:09:00.000Z","updated":"2019-06-30T04:11:36.666Z","comments":true,"path":"2018/05/17/从接口调用安全考虑/","link":"","permalink":"https://www.haoming.fun/2018/05/17/从接口调用安全考虑/","excerpt":"","text":"在数据通信时，需要考虑接口访问的合法性和安全性： 用户身份的合法性校验 接口调用的合法性校验 敏感数据加密 用户身份的合法性校验用户身份校验一般通过用户名和密码。这里要考虑明文如何加密为密文。具体应用中RSA加密比较常见。RSA的密钥n长度一般是1024位，长度越长就越难被破解，目前被破解最长的RSA密钥是768位。 n能分解为两个质数的乘积，即n = p * q,这样我们就可以计算出欧拉函数φ(n) = (p-1)*(q-1) 随机选择一个整数e，条件是1&lt; e &lt; φ(n)且与φ(n)互为质数 计算模反元素d，使得ed被φ(n)除的余数为1。如果n能被因数分解，那么d可以被算出，意味着私钥被破解。加密的公钥是(n,e)，解密的私钥是(n,d)用户合法性认证以后，在整个会话过程中，必须携带服务端返回的令牌token，以保证会话的合法性。 接口调用的合法性校验为了防止接口调用中，参数被篡改或者防止重放攻击，需要在参数中加上签名。在参数中可以加上imei(设备唯一Id)、timestamp，以确保签名sign的唯一性。sign=md5(path?query&amp;imei&amp;tamp&amp;SIGN_KEY)服务端接收到请求后，首先根据参数和SIGN_KEY验证签名结果是否一致，然后验证时间戳是否是在一定时间范围内，比如5分钟之内，如果超过则视为无效请求，如果在时间范围内，需要检查签名是否存在Redis中以防止重放攻击，如果不存在则存入Redis中5分钟。因为签名的唯一性，如果Redis中已存在相同的签名，那么很可能是重放攻击。 敏感数据加密HTTP协议通信是不安全的，敏感数据传输采用基于SSL的HTTPS会更安全。另外敏感数据最好加密（加盐）传输，防止被篡改。 参考如何确保服务端的接口调用安全","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://www.haoming.fun/categories/系统设计/"}],"tags":[{"name":"接口设计","slug":"接口设计","permalink":"https://www.haoming.fun/tags/接口设计/"}],"author":"Peng Fang"},{"title":"常见的Web安全漏洞介绍及解决办法","slug":"常见的Web安全漏洞介绍及解决办法","date":"2017-08-14T10:01:00.000Z","updated":"2019-06-30T04:11:36.668Z","comments":true,"path":"2017/08/14/常见的Web安全漏洞介绍及解决办法/","link":"","permalink":"https://www.haoming.fun/2017/08/14/常见的Web安全漏洞介绍及解决办法/","excerpt":"","text":"本文对常见的Web漏洞的原因、关注点、解决办法做简要介绍，整理自Web安全培训笔记。 SQL注入解决办法：参数化查询 失效的身份认证和会话管理 原因：Session相关的数据没有被完整替换导致的安全问题 关注点：Login通过后，立刻把当前Session（包含Session、Cache、Cookie）失效掉，把需要保持到Session的value重新开一个Session保存；Logout功能中，除了把当前Session失效掉外，还要把Session相关的Cache也remove掉。 登录: 登录验证通过后，要把Session.Abort()，再保存新值 注销：Session要Abort，相关缓存要clear，额外的cookie也有被clear | XSS（跨站脚本） 简介：XSS是指攻击者利用网站程序对用户输入过滤不足，输入可以显示子在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 关注点：HTML输入输出编码、JavaScript的编码、URL的编码 解决办法：对用户输出的数据要过滤特殊字符，对输出到客户端的数据也要过滤特殊字符。HTML、js、URL过滤方法不同。js中使用escape函数来过滤特殊字符，包括元素value、元素Attribute，都有encode起来，相关函数有escape、encodeURI、encodeURIComponent。PHP中有htmlspecialchars 函数。下面是js中特殊字符编码的一种写法：1234567891011function escapeHtml(text) &#123; var map = &#123; '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '\"': '&amp;quot;', \"'\": '&amp;#039;' &#125;; return text.replace(/[&amp;&lt;&gt;\"']/g, function(m) &#123; return map[m]; &#125;);&#125; 另外一种办法是增加cookie安全：启用httponly和secure secure属性是防止信息在传递的过程中被监听捕获后信息泄漏。当设置为true时，表示创建的cookie会被以安全的形式向服务器传输，也就是只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以不会被窃取到cookie的具体内容。HttpOnly属性不允许通过脚本访问cookie，只能用于传输，目的是防止程序获取cookie后进行攻击。 敏感数据暴露 原因：敏感信息需要加密保存（内存、数据库、客户端中）+加密传输（HTTPS）+不缓存（只是尽量，看情况） 解决关注点：登录、付款这样的页面要用HTTPS保护传输。密码可采用单向加密，信用卡账号采用可逆的加密方式。 Base64算法：Base64只是一种编码方式，并不是一种加密算法，不要使用Base64来加密数据。 Hash算法：具有不可逆性是一种单向密码体制，只能加密不能解密，可以用来加密用户登录密码等凭证。有的开源项目采用md5加盐的方式加密如md5(md5(pwd)+salt)，但是不建议使用MD5等算法，MD5可用因子碰撞暴力破解，建议采用SHA-256算法。不要使用哈希函数作为对称加密算法的签名，字符串串接后再做哈希要注意（URL签名）。 对称加密：加解密使用同一个密钥，计算耗时短，通常用来加密数据。推荐使用AES算法 非对称加密：加解密使用不同的密钥，计算耗时长，通常利用来加密密钥。注意密钥长度不要低于512，建议2048位的密钥长度。 为了确保安全性，有时多种加密算法混合使用。如非对称-&gt;hash-&gt;对称 CSRF（跨站请求伪造）利用合法用户的身份，在合法用户的终端调用请求。解决关注点：重要操作不用使用get方式，要使用post方式；为每个能进行post动作的form增加token，并且在服务端检查token的合法性，合法则进行操作。正确的防御方式： 第一步，新建CSRF令牌添加进用户每次登陆以及存储在httpsession里，这种令牌至少对每个用户会话应是唯一的，或者是对每个请求是唯一的。 第二步，令牌可以包含在URL中或作为一个URL参数记/隐藏字段。 第三步，在服务器端检查提交令牌与用户会话对象令牌是否匹配。 第四步，在注销和会话超时，删除用户对象会话和会话销毁。 未验证的重定向和转发原因：当系统接受重定向参数，如http://www.a.com/login.aspx?returnUrl=default.aspx，只要修改只要修改这个url为http://www.a.com/login.aspx?returnUrl=http://wwv.a.com/login.aspx，这样会被重定向到假冒站点的login界面，用户再次输入密码，此时密码就被假冒站点保存起来了。解决关注点：对于returnUrl这种参数值进行判断，只要在白名单中的url才能redirect，尽量使用相对路径来redirect。 会话安全 Session会话ID要足够长足够随机 认证用户后应开启一个全新的用户ID 限制会话闲置时间 限制会话生命周期 允许用户自行注销会话 会话结束后清除数据 安全基础应当在完全不信任用户输入和客户端提交的数据的前提下开发应用程序。 输入验证 集中式输入验证 服务器端输入验证 建议采用白名单放弃黑名单 验证输入长度、格式、字符合法性等 验证所有的输入 防范元字符攻击 防范元字符攻击 SQL注入 跨站脚本 路径操纵 命令注入 日志欺骗 数据库连接安全 使用参数化SQL语句 数据库中的数据也是不可信的 确保数据库资源能够被释放 减少编码逻辑漏洞执行操作时需要权限判断 文件安全严格控制文件上传 文件类型验证（白名单验证） 存储路径安全（把握原则：可执行目录不可写，可写目录不可执行） 防范rar压缩炸弹 限制文件大小 严格分配文件访问权限策略安全的临时文件访问竞争条件开发调试日志 集中日志记录 使用时间戳 记录每个重要行为 保护日志文件 调试 上线产品删除调试代码 产品中不包含后门代码 清除备份和调试文件 错误日志错误处理 保证整个团队使用一个共同的异常处理方法 禁用或限制详细错误处理信息（可以暴露错误状态码，而错误详细信息不应被暴露） 多个错误同一时间内返回相似或同样的出错信息 各种应用层会返回错误或异常结果 有必要创建一个默认的错误处理机 可以用总是返回“200”错误代码来覆盖默认的错误输出 不安全的加密存储 不要自己创建加密算法。 应使用已经被证明的公开加密算法，例如AES，RAS公钥加密，和SHA-256或更好的HASH算法。 不要使用弱加密算法，比如MD5/SHA1。 建议使用更安全的加密算法，比如SHA-256或更其它的选择。 不安全的通讯 对所有传输认证或传输数据的连接启用SSL 确保web服务器和数据库之间的通讯安全恰当的加密 限制敏感数据的生命周期问题 使用对象来存储敏感数据，但使用后没清除或回收 具有可以被操作系统按需交换到磁盘的内存页面 在缓冲区中有敏感数据 使用了一些反射机制来控制敏感数据 通过调试信息、日志文件、环境变量等方式暴露敏感数据 不要在客户端存储未经加密的数据确保安全敏感方法被调用时参数经过验证不要使用不安全的弱加密算法身份鉴别用户ID管理 用户名是唯一的 注册判断重命等逻辑放在服务器端 Insert之前判断用户名是否存在 密码管理 密码长度不小于8个字符密码至少包含大小写字母、数字及特殊符号。密码与账户名不同存储过程中不能使用明文以及不安全的存储在密码传输工程中不能使用明文，短信验证码设置有效期输入密码时不显示密码管理账户没弱口令，删除测试账户 认证限制 用户身份认证尝试超限锁定功能如果用户名易被猜测，对同一ip多次认证失败锁定认证期间不透露用户ID是否存在关键系统双因子认证认证需要采用有效挑战应答机制 注意的漏洞 Struts2框架任意代码执行 Java反序列化化漏洞 容错处理不当致信息泄露 mybatis(ibatis)框架存在的SQL注入，正确的写法： 1select * from user where username like concat('%',#username#,'%') mybatis框架$存在的SQL注入尽量使用#描述参数，如果一定要使用$，则需要自己过滤用户输入。因为使用$参数MyBatis不会修改或转义字符串。 Hibernate存在的SQL注入正确的写法： 名称绑定 12String queryString = \"from Item item where item.description like :searchString and item.date &gt; :minDate\";List result = session.createQuery(queryString).setString(\"searchString\", searchString).setDate(\"minDate\", minDate).list(); 位置绑定 12String queryString = \"from Item item where item.description like ? and item.date &gt; ?\";List result = session.createQuery(queryString).setString(0, searchString).setDate(1, minDate).list();","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.haoming.fun/categories/Web安全/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.haoming.fun/tags/Web安全/"}],"author":"Peng Fang"},{"title":"Linux下离线安装node和npm","slug":"Linux下离线安装node和npm","date":"2017-08-10T09:56:00.000Z","updated":"2019-06-30T04:11:36.663Z","comments":true,"path":"2017/08/10/Linux下离线安装node和npm/","link":"","permalink":"https://www.haoming.fun/2017/08/10/Linux下离线安装node和npm/","excerpt":"","text":"本文记录在Linux环境下怎样离线安装node和npm环境。 上传安装包到服务器 从Download Node.js and npm下载Linux Binaries可运行uname -a查看系统的位数，如x86_64为64为系统。先上传安装包到FTP，用root账号登录服务器后从FTP下载安装包 执行安装命令 解压安装包到想要安装node的目录 1234sudo mkdir /usr/lib/nodejssudo tar -xJvf node-v8.2.1-linux-x64.tar.xz -C /usr/lib/nodejscd /usr/lib/nodejssudo mv node-v8.2.1-linux-x64/ node-v8.2.1 设置环境变量设置环境变量vi ~/.profile，在最后添加下面的shell命令 123# Nodejsexport NODEJS_HOME=/usr/lib/nodejs/node-v8.2.1export PATH=$NODEJS_HOME/bin:$PATH 执行source ~/.profile使环境变量生效 创建软链接配置了环境变量，有可能出现npm命令找不到的情况。我的办法是添加软链接：123sudo ln -s /usr/lib/nodejs/node-v8.2.1/bin/node /usr/bin/nodesudo ln -s /usr/lib/nodejs/node-v8.2.1/bin/node /usr/lib/nodesudo ln -s /usr/lib/nodejs/node-v8.2.1/bin/npm /usr/bin/npm 注意在Windows下运行过npm install安装了node组件的，到Linux下面删除node_components目录重新运行npm install。 测试安装执行下面的命令测试安装是否成功1node -v 这里输出： v8.2.1 1npm version 这里输出： { &apos;vue-riskaudit&apos;: &apos;1.0.5&apos;, npm: &apos;5.3.0&apos;, ares: &apos;1.10.1-DEV&apos;, cldr: &apos;31.0.1&apos;, http_parser: &apos;2.7.0&apos;, icu: &apos;59.1&apos;, modules: &apos;57&apos;, node: &apos;8.2.1&apos;, openssl: &apos;1.0.2l&apos;, tz: &apos;2017b&apos;, unicode: &apos;9.0&apos;, uv: &apos;1.13.1&apos;, v8: &apos;5.8.283.41&apos;, zlib: &apos;1.2.11&apos; }","categories":[{"name":"环境安装","slug":"环境安装","permalink":"https://www.haoming.fun/categories/环境安装/"}],"tags":[{"name":"前端环境","slug":"前端环境","permalink":"https://www.haoming.fun/tags/前端环境/"}],"author":"Peng Fang"},{"title":"基于VUE+VUEX+ELEMENT-UI的项目结构","slug":"基于VUE-VUEX-ELEMENT-UI的项目结构","date":"2017-07-31T09:54:00.000Z","updated":"2019-06-30T04:11:36.667Z","comments":true,"path":"2017/07/31/基于VUE-VUEX-ELEMENT-UI的项目结构/","link":"","permalink":"https://www.haoming.fun/2017/07/31/基于VUE-VUEX-ELEMENT-UI的项目结构/","excerpt":"","text":"分析了石头哥的VUE模板工程（基于VUE+VUEX+ELEMENT-UI）的项目结构，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364mock-server // 模拟数据| api.json // 配置请求响应的数据| server.js // mock数据响应node_modules // 组件安装存放目录src // 源文件目录|---actions // 分模块定义接口调用| | articles.js| | index.js| | root.js|---components // 组件| | Select.vue| | Table.vue|---constants // 定义一些常量| | actions.js| | api.js|---containers // 页面| | Article.vue|---layouts // 布局 |---css |---core | | base.less | | common.less | | font.less | | index.less | | normalize.less | | reset.less |---mixins | | compatibility.less | | iconfont.less | | index.less | | opacity.less | | size.less |---themes | | default.less index.less |---fonts |---antd | | iconfont.eot | | iconfont.svg // ... |---img|---mutations // 更改state| | article.js| | index.js| | root.js|---plugins| | element.js // 注册需要的element组件|---store| | index.js // 创建Vuex的Store实例|---utils| | api.js // 暴露一些请求Api以及createAction方法| | misc.js // 公用方法| App.vue // 主页| index_dev.html // 开发环境的首页| index_prod.html // 生产环境的首页| root.js // 入口文件，创建Vue实例| router.js // 创建VueRouter实例.babelrc babel配置文件.editorconfig IDE编辑器配置文件package-lock.json npm更改操作自动生成package.json 项目相关的各种元数据(依赖的模块)proxy.js 配置代理webpack.config.js 根据是否是生产环境设置webpack的配置文件webpack.dev.config.js 开发环境配置文件webpack.prod.config 生产环境配置文件","categories":[{"name":"vue","slug":"vue","permalink":"https://www.haoming.fun/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.haoming.fun/tags/vue/"}],"author":"Peng Fang"},{"title":"webpack中文文档摘要","slug":"webpack中文文档摘要","date":"2017-07-31T09:49:00.000Z","updated":"2019-06-30T04:11:36.663Z","comments":true,"path":"2017/07/31/webpack中文文档摘要/","link":"","permalink":"https://www.haoming.fun/2017/07/31/webpack中文文档摘要/","excerpt":"","text":"首先给出webpack中文文档的地址这是我目前见过的翻译最好的webpack文档，清晰明了。 webpack在webpack之前，前端开发人员会使用grunt和gulp等工具来处理资源，并将它们从/src文件夹移动到/dist或/build目录中。同样的方式也被用于Javascript模块。但是像webpack这样的工具，将动态打包所有的依赖项（创建所谓的依赖图），避免打包未使用的模块。webpack最出色的功能之一就是除了JavaScript，还可以通过loader因人员任何其他类型的文件。webpack打包命令默认选择使用一个配置文件叫webpack.config.js，改文件存在于根目录下。配置文件具有更强的灵活性，我们可以通过配置方式指定loader规则(loader rules)、插件(plugins)、解析选项(resolve options)，以及许多其他增强功能。初始化npm (npm init -y)会生成一个package.json，其中可以配npm 脚本和项目所需的依赖等。使用npm的scripts，我们可以通过模块名，来引用本地安装的npm包，而不是写出完整路径。例如： 1234567&#123; ... \"scripts\": &#123; \"build\": \"webpack\" &#125;, ...&#125; 我们直接调用webpack这样的别名，而不是去调用./node_modules/.bin/webpack通过向npm run build命令和我们的参数之间添加两个中横线，可以将自定义参数传递给webpack，例如: npm run build – –colors 管理输出加载CSS为了从JavaScript模块中import一个css文件，你需要在webpack.config.js的module配置中安装并添加style-loader和css-loader。webpack根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的loader。这样可以在依赖此样式的文件中import某个样式文件，当模块运行时，含有CSS字符串的&lt;style&gt;标签将被插入到HTML文件的&lt;head&gt;中。 可以生产环境中进行CSS分离达到节省加载时间的目的。 加载图片试想下载CSS的时候，如果其中有图片文件，那要如何处理呢？使用file-loader可以轻松地将内容混合到CSS中。当我们import oneImage from ‘./my-image.png’，该图像将被处理并添加到output目录，并且oneImage变量将包含该图片名在被处理后的最终URL。例如当使用css-loader， css中url(‘./my-image.png’)中的路径被替换为输出目录中图片的最终路径。 查看image-webpack-loader和url-loader了解压缩和优化图像等功能。 加载字体file-loader和url-loader可以接收并加载任何文件，然后将其输出到构建目录，当然也包括字体文件。 加载数据数据文件一般包含JSON文件、CSV、TSV和XML。类似于NodeJS，JSON支持实际上是内置的，import一个json文件默认将正常运行。我们可以使用csv-loader和xml-loader来处理其余三类文件，csv-loader处理csv和tsv。这样import四类文件中的任何一类，所导入的变量将包含可直接使用的已解析JSON 在使用d3等工具来实现某些数据可视化时，预加载数据会非常有用。构建过程中将数据提前载入并打包到模块中，以便浏览器加载模块后，可以立即从模块中解析数据。 全局资源上述内容最出色之处是，以这种方式加载资源，可以更直观地将模块和资源组合在一起，无需依赖于含有全部资源的/asset目录，而是将资源与代码组合在一起。例如：类似这样的结构非常有用： 123456+ |– /components+ | |– /my-component+ | | |– index.jsx+ | | |– index.css+ | | |– icon.svg+ | | |– img.png 这种配置方式会使你的代码更具备可移植性，现有统一放置的方式会造成所有资源紧密耦合在一起。假如在想在另一个项目中使用/my-component，只需将其复制或移动到/components目录下。只要你安装了扩展依赖，并且配置过相同的loader，那么项目应该可以良好运行。但是这样的缺点是无法使用新的开发方式或者在多个组件之间共享资源。仍然可以将这些资源存储在公共目录中，甚至配合使用alias来使它们更方便导入。","categories":[{"name":"webpack","slug":"webpack","permalink":"https://www.haoming.fun/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.haoming.fun/tags/webpack/"}],"author":"Peng Fang"},{"title":"利用travis自动化部署博客项目","slug":"利用travis自动化部署博客项目","date":"2017-07-25T09:36:00.000Z","updated":"2019-06-30T04:11:36.666Z","comments":true,"path":"2017/07/25/利用travis自动化部署博客项目/","link":"","permalink":"https://www.haoming.fun/2017/07/25/利用travis自动化部署博客项目/","excerpt":"","text":"目的本文记录如何用travis实现自动化部署GitHub仓库中的博客项目，并完成域名访问。 travis登录和授权travis可以用GitHub账号登录，登录后在profile页授权允许travis访问的仓库。 比如我这里的GitHub仓库是vue-ghpages-blog，也是我准备部署的博客项目。 GitHub pages的一点概念搭建项目站点的两种方式： 一种是创建一个名为 GitHub用户名.github.io的仓库，在外网以该仓库名作为地址进行访问就可以访问到仓库里面的静态页面了。另一种是给仓库创建一个gh-pages分支，将运行npm run build命令编译生成到项目dist目录下的文件push到gh-pages分支。访问GitHub用户名.github.io/仓库名如https://github.com/MGTfang/vue-ghpages-blog，也能访问到编译项目生成的静态文件。 travis自动化部署的条件在授权travis访问仓库（项目）的前提下，还需要在仓库的根目录下有个.travis.yml文件，部分内容如下： 1234567891011121314151617script: - npm testafter_success: - npm run build - cd dist - echo \"dtechvoi.com\" &gt; CNAME - cp index.html 404.html - git add --all . - git commit --message \"Automatically update from travis-ci\" - git push --quiet \"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\" gh-pages:gh-pages# Note: you should set Environment Variables here or 'Settings' on travis-ci.orgenv: global: - GH_REF: github.com/MGTfang/vue-ghpages-blog.git # - GH_TOKEN: 'Your GitHub Personal access tokens, via https://github.com/settings/tokens' 当将更改的文件push到远端仓库（这里是vue-ghpages-blog的develop分支）的时候，travis会自动执行一次build，build操作根据.travis.yml内容来进行。例如根据上面的脚本（有部分省去了），先设置环境变量GH_REF、GH_TOKEN，再更新nvm，运行npm install、npm test。 我这里报错：没有找到electron这个包，因此运行`npm install electron --save`进行安装 在`npm run test`成功以后，会将build生成的文件推送到gh-pages分支。 这里可能会出现没权限访问远端仓库的error，这样需要通过`https://github.com/settings/tokens`来设置访问token，特别主要要将repo勾选，不然照样没有权限。 域名绑定在域名的解析设置下添加三条记录： 记录类型 主机记录 解析线路(运营商) 记录值 CNAME @ 默认 MGTfang.github.io. A www 默认 192.30.252.153 A www 默认 192.30.252.154 包括两条A记录和一条CNAME记录，A记录指向以www开头的域名，记录值是GitHub的IP地址，CNAME的记录值是可以访问GitHub pages的地址。除了绑定域名，还需要在访问仓库额根目录下创建一个CNAME文件，并在其中写入绑定的域名，这样直接访问域名就能访问gh-pages分支下的静态页面。","categories":[{"name":"博客","slug":"博客","permalink":"https://www.haoming.fun/categories/博客/"}],"tags":[{"name":"自动化部署 博客","slug":"自动化部署-博客","permalink":"https://www.haoming.fun/tags/自动化部署-博客/"}],"author":"Peng Fang"}]}