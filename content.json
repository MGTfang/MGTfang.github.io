{"meta":{"title":"青桥雨之木芳","subtitle":null,"description":null,"author":"Peng Fang","url":"https://www.haoming.fun","root":"/"},"pages":[],"posts":[{"title":"客户端字体放大问题解决","slug":"客户端字体放大问题解决","date":"2020-02-08T10:38:00.000Z","updated":"2020-02-08T10:55:58.128Z","comments":true,"path":"2020/02/08/客户端字体放大问题解决/","link":"","permalink":"https://www.haoming.fun/2020/02/08/客户端字体放大问题解决/","excerpt":"","text":"华为手机，或者苹果手机能设置手机端的字体大小，字体大小的变动就足以导致页面布局乱掉，导致文本不居中、文字折行、布局混乱等问题。解决办法参考这篇文章 现象用户修改手机字体设置大小，影响App里打开的web页面。 Android端解决办法手机字体设置大小，影响App的页面。Android的可以通过webview配置webview.getSettings().setTextZoom(100)就可以禁止缩放，按照百分百显示。 H5解决办法Android因为改变的是字体的大小，所以可以考虑将字体大小在设置的时候进行等比例缩小。例如，一个文字希望以10px来进行渲染，当webview被放大两倍时，此时font-size会变为20px。因此我们可以在取到这个放大比例之后，对原样式进行等比缩小，比如将原文字大小设置为5px，渲染的时候就变成了10px。 代码如下： 1234567891011121314// 手机字体放大或缩小的情况，恢复根字体的大小let $dom = document.createElement('div');$dom.style = 'font-size:16px;';document.body.appendChild($dom);// 计算出放大后的字体大小const scaledFontSize = parseInt(window.getComputedStyle($dom, null).getPropertyValue('font-size'));document.body.removeChild($dom);// 计算原字体和放大后字体的比例const scaleFactor = 16 / scaledFontSize;// 获取当前已经缩放的根元素字体大小const originRootFontSize = parseInt(window.getComputedStyle(document.documentElement, null).getPropertyValue('font-size'));// 乘以scaledFontSize是原来的html字体大小// 再次乘以scaledFontSize是为了经过手机缩放后显示为想要的大小document.documentElement.style.fontSize = originRootFontSize * scaleFactor * scaleFactor + 'px'; 通过改变根元素字体来影响文档中元素字体大小的方法，对字体单位是rem的才有效。因此如果字体单位是vw，该方法并不能一劳永逸。这里能想到的办法是讲显示错乱的地方的字体单位vw转换成rem。怎样转换比较方便呢？我们采用的是less这个css预编译处理语言，能不能写一个单位转换的方法，在less 中调用呢？在网上找到了一篇文章，结合这篇文章，我们这里的实现是这样： 12345678910111213141516.remMixin() &#123; @functions: ~`(function() &#123; var clientWidth = 375; function convert(size) &#123; return typeof size === 'string' ? +size.replace('px', '').replace('vw', '') : size; &#125; this.rem = function(size) &#123; return (convert(size) / 16).toFixed(3) + 'rem'; &#125; this.vw2rem = function(size) &#123; return this.rem(convert(size) * clientWidth / 100); &#125; &#125;)()`;&#125;.remMixin(); 这里对less 的一个语法进行介绍：为了表示Javascript，必须用反引号包装代码。执行此操作时，Less讲计算表达式并讲结果作为字符串返回。它做到了“原样”返回。因此如果返回的是字符串的话，会带有引号。如果想将返回结果中的引号删除，可以在反引号前加上波浪号。实际使用的时候，比如设置： 1font-size: ~`vw2rem(&apos;3.2vw&apos;)`; 经过转换后： 1font-size: 0.75rem; 参考文章https://www.cnblogs.com/axl234/p/7753187.htmlhttps://blog.csdn.net/weixin_34146986/article/details/91430581https://www.bennadel.com/blog/2638-executing-javascript-in-the-less-css-precompiler.htm","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"https://www.haoming.fun/categories/移动端开发/"}],"tags":[],"author":"Peng Fang"},{"title":"【工作杂记】20200204","slug":"【工作杂记】20200204","date":"2020-02-08T09:58:00.000Z","updated":"2020-02-08T10:55:13.815Z","comments":true,"path":"2020/02/08/【工作杂记】20200204/","link":"","permalink":"https://www.haoming.fun/2020/02/08/【工作杂记】20200204/","excerpt":"","text":"获取根节点font size 1getComputedStyle(window.document.documentElement).['font-size'] 设置根节点font size 123document.getElementsByTagName(&quot;html&quot;)[0].style.cssText = &apos;font-size: 16px&apos;;document.getElementsByTagName(&quot;html&quot;)[0].style.fontSize= 16px&apos;;document.documentElement.style.fontSize = &apos;16px&apos; 项目乱码如果某个项目或者某个文件出现中文乱码现象，项目或者文件上右键选择Properties（配置文件）——&gt;Resource,右边找到Text File encoding选项，选择Other，里面有几种编码方式可供选择，选择何时的编码方式(一般是UTF—8或者GBK)，然后Apply就OK了。 构建Java项目选中项目，右键选择 run as -&gt; maven build…填写 maven 命令：clean install assembly:assembly或者 尝试命令：mvn package assembly:assembly -Dmaven.test.skip=true -U -B执行完在target目录会生成tar包。 执行错误·Fatal error compiling: tools.jar not found: C:\\Program Files\\Java\\jre-8u111\\..\\lib\\tools.jarPreference —&gt; Java -&gt; Installed JREs -&gt; click Add button -&gt; Standard VM -&gt; click Directory button -&gt; 选择jdk 下的jre: C:\\Program Files\\Java\\jdk1.8.0_131\\jre 安装 Java 环境（JDK 1.8）下载jdk-8u241-linux-x64.tar.gz，拷贝到阿里云创建目录mkdir /usr/local/java/解压至安装目录：tar -zxvf jdk-8u241-linux-x64.tar.gz -C /usr/local/java/编辑文件vim /etc/profile在末尾添加： 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_241export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量生效source /etc/profile添加软链接ln -s /usr/local/java/jdk1.8.0_241/bin/java /usr/bin/java检查是否安装成功java -version 部署Java包bin目录里面是启动停止脚本conf目录是配置文件lib目录就是jar包，后面重新部署就直接替换这一个jar包就可以了修改启动脚本中的服务端口号jvm 参数设置过大可能会在启动的时候报错，前面一部分带内存空间的参数可以删掉.修改jdbc连接参数创建和同步数据库设置阿里云访问规则，开放端口 运行启动脚本提示No such file or directory错误shell 文件的编码造成用vim打开该sh文件，输入：:set ff回车，显示fileformat=dos，重新设置下文件格式，输入：:set ff=unix保存退出::wq 访问服务时mysql出现which is not functionally dependent on columns in GROUP BY clause报错编辑/etc/my.cnf，在文件的最后加上sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION重启服务systemctl restart mysqld.service","categories":[],"tags":[{"name":"工作杂记","slug":"工作杂记","permalink":"https://www.haoming.fun/tags/工作杂记/"}],"author":"Peng Fang"},{"title":"H5 体验优化总结（二）","slug":"H5-体验优化总结（二）","date":"2020-02-02T15:43:00.000Z","updated":"2020-02-02T15:43:58.344Z","comments":true,"path":"2020/02/02/H5-体验优化总结（二）/","link":"","permalink":"https://www.haoming.fun/2020/02/02/H5-体验优化总结（二）/","excerpt":"","text":"前言&emsp;&emsp;本文对近期开发移动端 H5 过程中解决的体验问题进行梳理汇总。内容涉及移动端适配、网络状态监听、DOM元素位置属性的计算、与原生通信、用户行为埋点、包体积优化等。通过小的问题案例，来讲解开发中问题的解决及如何提升用户体验。如果本文有任何不确切的地方，欢迎指正！&emsp;&emsp;本文分为两部分，第一部分包含页面优化、设计优化、性能优化；第二部分包含功能优化。本文内容概要如下： 网络状态监听&emsp;&emsp;H5 通常需要对网络状态进行监听，比如说断网的时候，给用户一个提示，或者跳转到一个指定的提示页面。那么如何对网络状态进行监听呢？答案是可以在页面添加对offline事件的监听。据MDN的解释，当浏览器失去网络连接时，offline事件被处罚。并且navigator.online的值变为false。 12345678created() &#123; // 添加断网监听 window.addEventListener('offline', this.pushNetworkErrorPage);&#125;,beforeDestroy() &#123; // 移除网络状态监听 window.removeEventListener('offline', this.pushNetworkErrorPage);&#125; &emsp;&emsp;断网处理是 APP 比较常见的一个场景，为了提升用户体验，在网络断开或者网络状态不好的时候，及时给出用户提升信息，或者进入到一个类似404的提示页面。我们这里采用后者，用图文来展示断网的提示信息，并且用户通过“点击重试”，可以尝试重连（刷新实际是返回上一页，该过程中如果还是断网状态，又会回到提示页）。 点击展开按钮，页面自动往上&emsp;&emsp;有时候页面内容比较多，一些内容是没有展开的，即便是展开后，内容较长，屏幕长度有限，可能出现下方内容被屏幕遮挡。因此为了提升体验，需要在点击展开按钮的时候，页面能自动往上，滚动到内容区域的起始位置。来看下面的实现代码： 12345678// 展开的时候，滚动到顶部导航下面// assessmentTableBox 的 offsetParent 是 body，offsetTop 为其到 body 的距离const scrollTop = this.$refs.assessmentTableBox.offsetTop - document.querySelector('.sticky-wrapper').clientHeight - 40; // 元素距离顶部的距离 - 顶部 header 高度 - 偏移量if (document.documentElement.scrollTop) &#123; document.documentElement.scrollTop = scrollTop;&#125; else &#123; document.body.scrollTop = scrollTop;&#125; &emsp;&emsp;为了解释这段代码，首先需要了解几个基本概念：&emsp;&emsp;HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body 元素。如果这个容器元素未进行CSS定位, 则 offsetParent 属性的取值为body元素的引用。&emsp;&emsp;HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部内边距的距离。&emsp;&emsp;clientHeight它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距，此属性会四舍五入取整。&emsp;&emsp;Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。这里通过设置 document.documentElement 或者 document.body 设置页面向上滚动的像素数，前者返回的是文档对象的根元素通常指&lt;html&gt;，后者返回当前文档的&lt;body&gt;元素。&emsp;&emsp;这里的办法是先获取到页面向上滚动的距离，这个距离scrollTop = 元素距离顶部的距离 - 顶部 header 高度 - 偏移量，然后设置文档根元素或者body元素的 scrollTop 使得页面向上滚动 scrollTop 像素的距离。 下方还有内容时，给用户提示&emsp;&emsp;有时弹窗区域下面还有内容没显示完全时，需要给用户提示，可以向下滑查看更多内容。我们这里的办法是，下方还有内容时，在最下方位置显示一个向下的有动效的箭头，当用户滚动到最下方的时候，该箭头掉转朝上。下面说说怎么实现。 判断窗口内容是否可滚动1234567891011121314watch: &#123; isDisplay(nv) &#123; if (nv) &#123; this.$nextTick(() =&gt; &#123; const scrollDiv = this.$refs.explainContent; this.scrollable = scrollDiv.scrollHeight &gt; scrollDiv.clientHeight; this.scrollable &amp;&amp; scrollDiv.addEventListener('scroll', this.scrollHandler); &#125;); &#125; &#125;&#125;,beforeDestroy() &#123; this.scrollable &amp;&amp; this.$refs.explainContent.removeEventListener('scroll', this.scrollHandler);&#125; &emsp;&emsp;如果元素的 scrollHeight 大于 其clientHeight的话, 我们就说它的内容是可以滚动的。&emsp;&emsp;Element.scrollHeight 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。&emsp;&emsp;scrollHeight 的值等于该元素在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度。 没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 ::before 和 ::after这样的伪元素。&emsp;&emsp;clientHeight 表示元素内部的高度(单位像素)，包含padding，但不包括元素的border和margin。 判断是否滚动到底部1234567891011121314scrollHandler(e) &#123; const element = e.target; this.isScrollBottom = Math.round(element.scrollHeight - element.scrollTop) === element.clientHeight || Math.round(element.scrollHeight - element.scrollTop) === element.clientHeight - 1;&#125;,arrowDownClickHandler(e) &#123; if (this.isScrollBottom) &#123; // 如果箭头朝上，点击滚到顶部 this.$refs.explainContent.scrollTop = 0 &#125; else &#123; // 如果箭头朝下，向下滚一点 this.$refs.explainContent.scrollTop = this.$refs.explainContent.scrollTop + 150; &#125;&#125; &emsp;&emsp;判断是否滚动到元素内容的最底部，是比较元素的scrollHeight（不出现滚动条的最小高度）减去其内容垂直滚动的像素数与元素可视区域的高度的高度近似。 箭头CSS动画&emsp;&emsp;效果：箭头Y方向位移，渐入渐出 1234567891011121314151617181920212223242526.arrow-down &#123; line-height: 0; padding: 15px 0; font-size: 20px; animation: arrow 1.5s ease-in-out infinite; .rotate&#123; transform-origin: center center; transform: rotate(180deg); transition: transform 0.2s; &#125;&#125;@keyframes arrow &#123; 0% &#123; opacity: 0; transform: translate(0, 0px) &#125; 50% &#123; opacity: 1; transform: translate(0, -.1rem) &#125; 100% &#123; opacity: 0; transform: translate(0, -.2rem) &#125;&#125; 切换页面，显示Loading&emsp;&emsp;H5 页面的数据一般分为好几个部分组成，比如有总览，分类详情，有图表等等，每个部分通过不同的接口请求数据，如果每个接口在请求前后显示页面 Loading 转圈的话，那么转圈会显示隐藏多次。这里的解决办法是给页面加一个全局的 Loading，在路由到页面前显示，在路由到页面后关闭。这里用 Vue Router 的全局前置守卫和全局后置钩子来实现，代码如下： 1&lt;loading v-model=\"isLoading\"&gt;&lt;/loading&gt; 12345678910Router.beforeEach(function(to, from, next) &#123; store.commit('updateLoadingStatus', &#123; isLoading: true &#125;); next();&#125;);Router.afterEach(function(to) &#123; setTimeout(() =&gt; &#123; store.commit('updateLoadingStatus', &#123; isLoading: false &#125;); &#125;, 500); // 显示时间长一点&#125;); 设置Tooltip 坐标轴指示器十字线&emsp;&emsp;Echarts Tooltip 为轴触发，且坐标轴指示器的类型为“cross”，即十字线，显示效果如下： &emsp;&emsp;如果需要是不显示指示器的标签和十字轴线，我们可以这样配置Echarts 的tooltip： 12345678910111213tooltip: &#123; ..., axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: 'cross', // 默认为直线，可选为：'line' | 'shadow' label: &#123; color: '#888', show: false // 不显示坐标轴指示器标签 &#125;, crossStyle: &#123; opacity: 0 // 不显示坐标轴指示器线 &#125; &#125;&#125; 限制浮标拖出页面&emsp;&emsp;页面有一个模块入口的圆形浮标，这个浮标需要支持可拖动，且拖动限制在页面内。draggabilly 能支持这个功能。可以通过 npm 来安装，使用也比较简单。 123// APP.vueimport draggabilly from 'draggabilly';Vue.prototype.$draggabilly = draggabilly; 1234const elem = this.$refs.entrance;const draggie = new this.$draggabilly(elem, &#123; containment: document.getElementById('app')&#125;); 123456789101112draggie.on('dragEnd', (event, pointer, moveVector) =&gt; &#123; const elem = this.$refs.entrance; let elemTop = +elem.style.top.replace('px', ''); if (elemTop &lt; 0) &#123; // 超出屏幕上边界，回到屏幕内 elem.style.top = 0; &#125; else if (elem.offsetHeight + elemTop &gt; document.documentElement.clientHeight) &#123; // 超出屏幕下边界，回到屏幕内 elem.style.top = `$&#123;document.documentElement.clientHeight - elem.offsetHeight&#125;px`; &#125;&#125;); &emsp;&emsp;原本该插件能限制拖动的范围，但是在有的页面可能以为布局的原因，导致浮标能拖动出下方边界。为了不改动现有布局引发新的问题，遂通过JS事件来限制，在拖动结束的时候，如果元素超出屏幕边界，则使之回到屏幕内。&emsp;&emsp;浮标元素是fixed定位的，我们能获取该元素距屏幕顶部的距离，这个距离加上元素的距离如果大于屏幕的高度的话，说明被拖出屏幕下边界，则设置元素的top属性为屏幕的高度减去元素的高度这么多像素。如果元素的top属性值小于0，则说明被拖出了上边界，则设置其样式top属性为0。&emsp;&emsp;元素的 offsetHeight 是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含 :before 或 :after 等伪类元素的高度。 趋势图时环比线条出界&emsp;&emsp;有时Echarts绘制出现奇怪的问题，比如线条出界，比如两点之间的连线不平滑，出现拐点。遇到这样匪夷所思的问题，或许我们应该检查下代码，是否是实现逻辑出现问题，除此之外还有个原因可以检查一下，那就是：绘制图表前是否有清空 canvas。一个图表组件会被公用，这种情况如果绘制前不清空画板可能就会出现这样怪异的问题。&emsp;&emsp;原来的代码如下： 1234567let chart = this.$echarts.init(chartBox, null, &#123;renderer: 'svg'&#125;);chart.setOption(&#123; tooltip: &#123; ... &#125;, ...&#125;; &emsp;&emsp;优化后的代码如下： 123456789if (this.chartObj) &#123; this.chartObj.clear();&#125; else &#123; this.chartObj = this.$echarts.init(chartBox, null, &#123;renderer: 'svg'&#125;);&#125;// 绘制图表this.chartObj.setOption(&#123; ...&#125; 调用原生&emsp;&emsp;APP端通常有PDF预览的需求，比如查看报告等。前端有js或者vue相关的插件可以供我们使用，之前使用过pdf.js，实现出来的体验一般。最近项目中同事也用过vue-pdf，这个插件能用来做 PDF 的预览。我们遇到的情况是，在本地开发的时候没有问题，但是上到测试环境后，拉取PDF数据的请求有发送，但是不显示结果。后来我还发现，使用了这个插件以后，包会增大好几兆，这对H5的性能是不利的。所以后来放弃了使用这些插件，转而调用原生提供的PDF预览功能。 12345678910/** * 打开APP原生页面 * @param &#123;string&#125; urlScheme 原生scheme路径地址，这里约定必须以mgstaff://开头 */startNativeActivity(urlScheme = '') &#123; if (urlScheme.indexOf('mgstaff://') === -1) &#123; throw new Error(`urlScheme必须以mgstaff://开头`) &#125; this.invokeNative('handleUrlScheme', &#123; urlScheme &#125;)&#125; &emsp;&emsp;H5 使用原生的功能，通过 JSBridge 实现。JSBridge 主要是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能。这个通信可以是双向的。JavaScript 调用 Native的方式主要有两种：注入API 和 拦截URL SCHEME。&emsp;&emsp;注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。&emsp;&emsp;URL SCHEME 是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，比如：mgstaff://course_pdf_detail?pdf_id=201912011501&amp;pdf_name=weekly_20191201。H5 发送 URL Scheme 请求之后，Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。&emsp;&emsp;Native 调用 JavaScript 的方式，我们主要是采用 JS 向 window下的对象 注册回调函数的方式。H5 在调用原生能力的同时，向 Window 下的对象注册供原生传参调用的方法。比如我们想开启语音识别并返回识别后的文字： 12345678910111213/** * 开启语音识别并返回识别后的文字 * @returns &#123;Promise&lt;string&gt;&#125; 识别后的文字 */recognizeVoice() &#123; return new Promise(resolve =&gt; &#123; this.openNative('mgstaff://voice_recognition_dialog') deviceApi.postVoiceRecognition = res =&gt; &#123; resolve(res.intent &amp;&amp; res.intent.text) delete deviceApi.postVoiceRecognition &#125; &#125;)&#125; 参考文档https://developer.mozilla.org/zh-CN/https://www.echartsjs.com/zh/option.html#grid.tooltip.axisPointer.crossStylehttps://develop.asyncoder.com:8443/docs/solution/module-Default.htmlhttps://blog.csdn.net/yuzhengfei7/article/details/93468914https://juejin.im/post/5bc07ebf6fb9a05d026119a9https://docs.elementor.com/article/595-difference-between-px-em-rem-percentage-vw-vhhttps://www.cnblogs.com/aspwebchh/p/7675539.htmlhttps://www.cnblogs.com/savokiss/p/8514868.html","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"https://www.haoming.fun/categories/移动端开发/"}],"tags":[],"author":"Peng Fang"},{"title":"H5 体验优化总结（一）","slug":"H5-体验优化总结（一）","date":"2020-02-02T15:27:00.000Z","updated":"2020-02-02T15:42:47.082Z","comments":true,"path":"2020/02/02/H5-体验优化总结（一）/","link":"","permalink":"https://www.haoming.fun/2020/02/02/H5-体验优化总结（一）/","excerpt":"","text":"前言&emsp;&emsp;本文对近期开发移动端 H5 过程中解决的体验问题进行梳理汇总。内容涉及移动端适配、网络状态监听、DOM元素位置属性的计算、与原生通信、用户行为埋点、包体积优化等。通过小的问题案例，来讲解开发中问题的解决及如何提升用户体验。如果本文有任何不确切的地方，欢迎指正！&emsp;&emsp;本文分为两部分，第一部分包含页面优化、设计优化、性能优化；第二部分包含功能优化。本文内容概要如下： 移动端适配&emsp;&emsp;为了适配不同手机终端的屏幕尺寸，之前开发移动端 H5 的时候，页面字体、间距等属性设置的单位采用rem。最近参与的项目中采用的单位是 vw，据说一些低版本手机浏览器对 viewport-units 的支持不太理想（IOS 8+, Android 4.4+ 支持，见 caniuse），但是就目前的应用场景来看支持还好。H5 页面适配以 rem 和 vw 这两种单位最为常见。&emsp;&emsp;vw 和 rem 的方案的本质都是“等比例缩放”，适合于视觉组件种类较多，视觉设计对元素位置的相对关系依赖较强的移动端页面。但对于文本内容较多，或者说希望引导用户沉浸浏览的页面，有人不推荐完全使用等比缩放的方案，并且在新闻，社区等可阅读内容较多的场景，px 方案可以让大屏幕手机展示出更多的内容，更符合人们的阅读习惯。&emsp;&emsp;rem 是相对于根元素（HTML标签），而 vw 是相对于视口的宽度。下面说说两种方案的计算。 REM&emsp;&emsp;大多数浏览器中，默认的字体大小是 16px，rem 单位的计算是以这个为基准（em以父元素的字体大小为基准）。如果用户将这个根元素的字体大小改成 14px,那么 1rem = 14px (1 * 14)，这样用户通过调整浏览器的默认字体大小，来控制每个元素的相对（缩放）比例。假如为了适配 1920 x 1080 以上尺寸的大屏，我们可以先求得设备像素比 dpr，然后基于 dpr 设置根元素的字体大小为 dpr * 100px。那么设计稿中 12 像素大小的文字，代码中该 font-size 设置为 0.12rem。 12345const docEle = document.documentElement;docEle.style.minWidth = '1920px';const dpr = docEle.offsetWidth / 1920;docEle.setAttribute(\"data-dpr\", dpr + '');docEle.style.fontSize = dpr * 100 + 'px'; Viewport units&emsp;&emsp;Viewport units 代表当前浏览器视口的一个百分比，和 % 单位相似，区别是视口单位按浏览器当前视口大小的百分比计算；而百分比单位是以父元素的百分比计算的。假如一个 375 x 667 的手机（iPhone6），那么1 vw = 1% of the viewport’s width (or 3.75px)。如果 UI 给的高保真宽为 375px，高为 667px，其中有一个按钮，宽为 64px，高为 16px，那么在给这个按钮设定样式的时候 width 属性应该为 (64 / (375/100)) vw。&emsp;&emsp;如果我想在代码中就用 px，有没有插件能帮我们做这个事情呢？经过一番查找发现，postcss-px-to-viewport能解决这个问题，但是这个配置是全局的，也就是所有的px单位都会被转换，除非在它的exclude配置项中配置要排除的文件。如果我们有的地方就想采用px，不需要被转换，并且这种需要忽略的文件比较多怎么办？因此考虑到这些，在实际的应用中没有采用这种方案。&emsp;&emsp;然后又考虑说，能否通过less 的mixins类似的特性，通过less定义方法来实现转换，在写样式的时候简单调用一下，如font-size: px2vw(14)这样就能实现转换呢。翻阅文档发现，less 有提供 plugin 功能，另外less-plugin-functions，也提供类似功能，相当于 css 执行 js 的逻辑。当时由于时间紧，尝试利用 less plugin 来实现没能成功，只能以后再试一下了。&emsp;&emsp;最后还是利用工具来转换的，推荐pixel-vh-vw-converter这个工具，注意转换前按下 F12,切换设备为手机模式，然后选择手机尺寸。 关于等宽字体&emsp;&emsp;关于什么是等宽字体，先来了解什么是不等宽字体。我们通常看到的大多字体都是不等宽字体，也就是因为英文的数字1和英文的数字9是不等宽的。那为什么需要字体是等宽的呢，比如用表格来展示各种数据值，数据靠左或靠右显示的情况下，如果字体不等宽，各位数字是对不齐的，不美观且不便于比较。&emsp;&emsp;通常的等宽字体有：Consolas, Monaco, monospace，这些字体可能只对英文字符生效，对中文无效。此外我们也可以让 UI 同学提供他们认为美观的与高保真一致的字体文件，比如“DIN-RegularAlternate.ttf”。示例图如下： 关于编码规范&emsp;&emsp;在H5的开发过程中，适配各种机型是不可避免的，因此系统测试可能会发现一些兼容性问题。具以往经验，一部分兼容问题是不规范的CSS或JS编码造成，比如样式属性用简写，比如js用一些较新的方法，都可能是造成不兼容的原因，特别在低端机容易出现，它不识别某些写法。下面来看一个例子，我们 H5 的一个页面在ios上滑动出现卡顿，经排查和我们写的样式有关系。&emsp;&emsp;以下是示例代码： 123456.sticky-wrapper&#123; ... &amp; + div&#123; /* 去掉就OK了 */ overflow-x: hidden; &#125;&#125; 用户事件埋点&emsp;&emsp;用户埋点的目的是统计一般的PV和UV，以及对用户的操作进行记录，方便我们统计出用户的行为轨迹、喜欢看的数据、搜索的关键字等等。方便我们有针对性地了解用户的喜好和行为习惯，帮助开发出更加符合用户需求，令用户满意的产品。&emsp;&emsp;起初我们接入的系统埋点能符合一般的需要，但是对于一些个性化的统计还暂不满足。所以后来我们设计了接口，通过代码中埋点调接口的方式，来记录用户行为。&emsp;&emsp;因此通过 Vue 的 mixins 来定义埋点的功能方法： 123456789101112131415161718192021const userTrack = &#123; methods: &#123; trackEvent(params) &#123; const actions = ['click']; const categories = ['pageView']; const options = &#123; appId: 'xxxxxx', // 约定appId userName: localStorage.user, // 登录用户名 category: categories[0], // 要监控的目标的类型名称 action: actions[0], // 用户行为，默认点击 pageId: store.state.moduleName.id, // 访问页面ID，这里传模块ID pageName: store.state.moduleName.name, // 访问页面名称，这里传模块名 eventTime: util.dateFormat('yyyy-MM-dd HH:mm:ss', new Date()), // 记录事件时间 ...params // 传入的事件参数 &#125;; // JSON对象转字符串，后端需要 options.values &amp;&amp; (options.values = JSON.stringify(options.values)); api.trackEvent(options); &#125; &#125;&#125; 包体积优化&emsp;&emsp;接手项目构建后的前端包比较大，因此着手进行优化，尽量缩小包的体积大小。优化围绕两个原则，第一个是插件的按需引入，第二个去掉页面文件中没有用到引入。&emsp;&emsp;先减小打包后大的 js 文件的体积，要减小大文件，就得利用 Webpack 分析构建后的 js 文件中哪些插件占用空间大，为多大。我们通过在 package.json 的scripts 下配置命令：&quot;analyze&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot;，然后执行 npm run analyze，在打开的页面中进行包分析。 Echarts 按需引入 123// main.jsimport echarts from 'echarts/lib/echarts';Vue.prototype.$echarts = echarts; 1234// ChartPie.vue 等页面按需引入import 'echarts/lib/chart/pie';import 'echarts/lib/component/tooltip';import 'echarts/lib/component/legend'; lodash 按需引入 运行 npm 命令安装依赖：npm install babel-plugin-lodash lodash-webpack-plugin --save-dev 修改.babelrc文件，plugins 中添加 lodash，我的项目添加完成如下：&quot;plugins&quot;: [transform-runtime&quot;, [&quot;import&quot;, {...}], &quot;lodash&quot;] 修改 webpack.base.config.js 1234567const LodashModuleReplacementPlugin = require('lodash-webpack-plugin');module.exports = vuxLoader.merge(webpackConfig, &#123; plugins: [ ..., new LodashModuleReplacementPlugin() ]&#125;); moments 排除字体包修改 webpack.prod.conf.js 1234567const webpackConfig = merge(baseWebpackConfig, &#123; plugins: [ ..., new webpack.IgnorePlugin(/^\\.\\/locale/,/moment$/), ... ]&#125;); &emsp;&emsp;优化后某大文件的体积从1370kB 减小到 518KB，减少约62.2%。&emsp;&emsp;然后是去掉不必要的引用：首先是去掉之前引入的 vue-pdf，后面没用了。去掉以后包体积减小了几兆。其次是执行静态代码扫描，将错误修复，特别是定义了没有使用的报错（no-unused-vars error）或者 import 后没有使用。&emsp;&emsp;最后配置生产环境不启用 SourceMap，即打包的时候不生成 SourceMap 文件： 12345678// 修改config/index.jsmodule.exports = &#123; build: &#123; ..., productionSourceMap: false, ... &#125;&#125; &emsp;&emsp;经过上述优化，包的大小从最初的 33,446,583 字节减小到 1,876,526 字节，减小94.4%。 参考文档https://developer.mozilla.org/zh-CN/https://www.echartsjs.com/zh/option.html#grid.tooltip.axisPointer.crossStylehttps://develop.asyncoder.com:8443/docs/solution/module-Default.htmlhttps://blog.csdn.net/yuzhengfei7/article/details/93468914https://juejin.im/post/5bc07ebf6fb9a05d026119a9https://docs.elementor.com/article/595-difference-between-px-em-rem-percentage-vw-vhhttps://www.cnblogs.com/aspwebchh/p/7675539.htmlhttps://www.cnblogs.com/savokiss/p/8514868.html","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"https://www.haoming.fun/categories/移动端开发/"}],"tags":[{"name":"H5","slug":"H5","permalink":"https://www.haoming.fun/tags/H5/"}],"author":"Peng Fang"},{"title":"Vue nextTick 原理分析","slug":"Vue-nextTick-原理分析","date":"2019-08-30T13:36:00.000Z","updated":"2019-08-30T13:37:38.731Z","comments":true,"path":"2019/08/30/Vue-nextTick-原理分析/","link":"","permalink":"https://www.haoming.fun/2019/08/30/Vue-nextTick-原理分析/","excerpt":"","text":"nextTick 原理分析nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。 看 next-tick.js 源码 在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。后来在Vue 2.5中使用宏任务结合微任务，然而又有一些问题，所以变成了现在的每个地方使用的是微任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import &#123; noop &#125; from 'shared/util'import &#123; handleError &#125; from './error'import &#123; isIE, isIOS, isNative &#125; from './env'export let isUsingMicroTask = falseconst callbacks = []let pending = falsefunction flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;// 这里是使用微任务的异步延迟包装器（timerFunc）。// 在2.5中，我们使用（宏）任务（结合微任务）// 然而，在重绘之前，状态发生改变的时候，它有点细微的问题// 此外，在事件处理程序中使用（宏）任务会导致一些无法回避的奇怪行为// 所以我们现在再一次在所有的地方都使用了微任务// 这样权衡也有它主要的缺点， 那就是有一些场景微任务有太高的优先级，// 据说在连续事件之间，甚至同一事件的冒泡之间会被触发let timerFunc// nextick行为利用微任务队列, 可以通过原生的 Promise.then 或者 MutationObserver 访问该队列// MutationObserver 拥有广泛的支持, 但是它在 iOS &gt;= 9.3.3 的 UIWebView 中存在严重的问题， 这会发生在touch事件的处理程序中// 当触发几次后，它就完全停止工作了... // 因此原生promise如果可以的话，我们将首先使用它:if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; // Promise.resolve()方法调用时不带参数，直接返回一个resolved状态的 Promise 对象 const p = Promise.resolve() timerFunc = () =&gt; &#123; // 立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行 // 也就是在本轮“事件循环”结束时执行回调方法 p.then(flushCallbacks) // 在有问题的 UIWebViews 中, Promise.then 不会完全退出, // 而是陷入一种奇怪的状态： 回调被推到微任务队列中，但队列不会被刷新 // 直到浏览器需要做一些其他工作，例如处理计时器 // 因此我们可以通过添加一个空计时器来“强制”刷新微任务队列 if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; // 原生 Promise 不可用的话，就用 MutationObserver // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; // 如果上面两种不行，回退到使用 setImmediate. // 技术上它利用了宏任务队列, // 但是仍然是一个比 setTimeout 更好的选择 timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // 最后回退到使用 setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() // 异步执行回调 &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 从以上的源码可以看出，在执行回调方面的优先级为 Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout Event loop众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 1234567console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)console.log('script end') 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 12345678910111213141516171819console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)new Promise(resolve =&gt; &#123; console.log('Promise') resolve()&#125;) .then(function() &#123; console.log('promise1') &#125;) .then(function() &#123; console.log('promise2') &#125;)console.log('script end')// output: script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。 所以正确的一次 Event loop 顺序是这样的: 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。 ##参考 https://yuchengkai.cn/docs/frontend/browser.html#event-loophttps://yuchengkai.cn/docs/frontend/browser.html#event-loop","categories":[{"name":"vue","slug":"vue","permalink":"https://www.haoming.fun/categories/vue/"}],"tags":[],"author":"Peng Fang"},{"title":"Web Workers 和 Comlink 的使用","slug":"Web-Workers-和-Comlink-的使用","date":"2019-08-29T10:59:00.000Z","updated":"2019-08-29T10:59:28.112Z","comments":true,"path":"2019/08/29/Web-Workers-和-Comlink-的使用/","link":"","permalink":"https://www.haoming.fun/2019/08/29/Web-Workers-和-Comlink-的使用/","excerpt":"","text":"JavaScript 异步编程回顾传统的 Web 是单线程的。一条条命令会按顺序执行，完成一条再开始下一条。同步 API 简化了我们的脚本编写工作，在上一条命令完成之前不会发生任何事情。Web 中的异步 API 比如说从磁盘读取、访问网络资源，这些 API 经常依赖事件或回调来处理这些资源。Node.js 是服务端 JavaScript 环境，使用了大量异步代码，通常使用回调模式进行异步操作。 虽然回调非常有用，但遗憾的是它们会依赖于先前异步函数的结果。为了解决 “回调地狱” 这个问题，比较新的 API 往往既不使用回调也不使用事件，而是使用 Promise。Promise 使用.then 语法使回调看起来更具可读性： 12345fetch('/data.json') .then(response =&gt; response.json()) .then(data =&gt; &#123; console.log(data); &#125;); Promise 的功能和回调是一样的，但前者更具可读性，结合箭头函数可以清楚表达Promise的每一步是怎样转换上一步的输出的。Promise 的真正优势在于，他是ES7 中 async/await 语法的基础之一。 在 async 函数中，await 语句将暂停函数的执行，直到它们等待的 promise 完成或拒绝。代码写法看起来是同步的，但是行为却是异步的，不会阻塞主线程。 123456async function getData() &#123; const response = await fetch('data.json'); const data = await response.json(); console.log(data);&#125;;getData(); async 函数将返回一个 promise，它本身可以在其他 async 函数中与 await 并用。 Web Workers目前为止我们谈的都是单线程编程。就是说我们的代码运行在一个CPU线程上，这个线程复制运行JS、解析CSS、网站布局和绘图。如果JS需要运行很长时间将会阻止其他部分的工作，导致比较糟糕的用户体验。 为了绕过单个线程运行内容的限制，Web 可以通过 Web Workers 来利用多个线程。 1const worker = new Worker('/first-worker.js'); 上面的代码将下载JS文件运行在不同的线程中，使得在不阻塞主线程的前提下运行复杂的JS程序。需要注意的是，Worker 本身是无法显示数字的，因为它无法访问主脚本的变量或文档本身，它所能做的只有传回计算的最终结果。这是线程的性质决定的，它只能访问同一线程内存中的内容。 进程与线程真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。 由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。 线程共享的进程环境包括：进程代码段、进程的公有资源（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、消息队列、信号的处理器、进程的当前目录、进程用户ID、进程组ID。 线程独占资源：线程ID、寄存器组的值、用户栈、内核栈、错误返回码、线程的信号屏蔽码、线程的优先级。 一个进程中的所有线程有它们各自独立的（私有的）栈(stack)。堆(heap)的分配与栈有所不同，一般是一个进程有一个运行时堆，这个堆为本进程中所有线程共享。线程切换的时候实际上切换的是一个可以称之为线程控制块的结构，里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。 一个进程的线程共享堆区，堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 栈是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动的切换栈，就是切换 SS / ESP 寄存器。栈空间不需要在高级语言里面显式的分配和释放。 共享数据不同线程之间可以基于事件来交换信息，每个线程都会侦听message事件，并可以使用postMessage API 发送消息。利用postMessage可以共享数组、对象、字符串。发送这些数据时，浏览器以特殊的序列化格式制作数据结构的副本，然后在另一个线程中重建： 1234// In the worker:self.postMessage(someObject);// In the main thread:worker.addEventListener('message', msg =&gt; console.log(msg.data)); someObject 被克隆变转变成可传递的形式，然后主线程接收后再转换成原始对象的副本，这个过程开销比较大。常见的共享数据时传递的对象类型是ArrayBuffer。使用 postMessage 传输 ArrayBuffer 时要小心。一旦它被传输后，它在原始线程中就不能再读取或写入了，并且如果你尝试使用它将抛出错误。 使用ComlinkComlink 将 postMessage 转换成了基于 Promise 的异步 API，它体积非常小，消除了使用postMessage 的顾虑，隐藏使用 workers 的事实，它是 postMessage 和 ES6 代理的 RPC 实现。 可以这样使用： 123456789import &#123;wrap&#125; from '/comlink/comlink.js';// This web worker uses Comlink's expose to expose a functionconst MyMathLibrary = wrap(new Worker('/mymath.js'));async function main() &#123; const myMath = await new MyMathLibrary(); const result1 = await myMath.add(2,2); const result2 = await myMath.add(3,7); return await myMath.multiply(result1, result2);&#125; 使用 Comlink 可以带来的另一大性能提升是利用 ArrayBuffer 之类的可传递对象，不用再复制它们。这会显著提升性能，但用的时候也要小心，因为一旦它们被传递后就不能在原始线程中使用了。 1234567const data = [1,2,3,4];await (function () &#123; const toSend = Int16Array.from(data); return myMath.addArray( Comlink.transfer(toSend.buffer, [toSend.buffer]) );&#125;()); Comlink 的一大好处是它让开发人员可以方便地把一部分应用放到 Worker 中，而无需对代码库做大幅度改动。w我们要做的工作主要是把同步函数转换为异步函数，在 await 后调用 Worker 暴露的 api。 参考文章： Web单线程终结者：Web Workers 同一个进程的不同线程，哪个是不能共享的 进程和线程","categories":[{"name":"前端","slug":"前端","permalink":"https://www.haoming.fun/categories/前端/"}],"tags":[],"author":"Peng Fang"},{"title":"数组：在给定的成对整数数组中找出所有总和等于给定数字的组合","slug":"数组：在给定的成对整数数组中找出所有总和等于给定数字的组合","date":"2019-08-27T06:42:00.000Z","updated":"2019-08-27T09:37:01.349Z","comments":true,"path":"2019/08/27/数组：在给定的成对整数数组中找出所有总和等于给定数字的组合/","link":"","permalink":"https://www.haoming.fun/2019/08/27/数组：在给定的成对整数数组中找出所有总和等于给定数字的组合/","excerpt":"","text":"原文 问题描述今天，我们来看另一个有趣的编程问题：编写一个程序来查找和等于给定数字的所有整数对。例如，如果输入整数数组为2、6、3、9、11，并且给定和为9，则输出应为6、3。听起来很简单？也许许多人可能已经听说过这个问题，有些人可能已经知道这个问题的解决方案，但仅仅知道答案是不够的。在面试中，除了正确的解决方案，其他的一些点也很重要。例如，面试官首先要考虑的是应聘者能否提出正确的问题。因此，在直接编码之前，请留出一两秒钟时间来考虑这个问题，并清除可能存在的任何疑问。例如，您可以根据上面给出的问题描述提出以下问题： 数组是否只包含正数或负数? 如果同一对数字出现两次, 是否每次都输出吗？ 相反的数字对是否可接受？ 例如： 如果给定和是5，打印 (4,1) 和 (1,4) 是否我们只打印不相同的对? (3, 3) 是总和为6的合法对吗？ 数组的长度是多少？ 面试时问问题是好，表明您有在思考问题，这对程序员来说是非常重要的素质。为了简便，我们假设这里跟你对出现的次数打印或一次或两次，并且这一对数字不相同，比如不能是（2，2）（3，3）这样的。 问题解答能想到的第一个解决办法：暴力算法，从数组中取出一个数字，然后循环遍历数组和输出对，这些对等于给定的和。对第一个数组中的所有数字都这样做，如下面的Java程序所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;/** * Java Program to find pairs on integer array whose sum is equal to k */public class ProblemInArray&#123; public static void main(String args[]) &#123; int[] numbers = &#123; 2, 4, 3, 5, 7, 8, 9 &#125;; int[] numbersWithDuplicates = &#123; 2, 4, 3, 5, 6, -2, 4, 7, 8, 9 &#125;; prettyPrint(numbers, 7); prettyPrint(numbersWithDuplicates, 7); &#125; /** * Prints all pair of integer values from given array whose sum is is equal to given number. * complexity of this solution is O(n^2) */ public static void printPairs(int[] array, int sum) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int first = array[i]; for (int j = i + 1; j &lt; array.length; j++) &#123; int second = array[j]; if ((first + second) == sum) &#123; System.out.printf(\"(%d, %d) %n\", first, second); &#125; &#125; &#125; &#125; /** * Utility method to print input and output for better explanation. */ public static void prettyPrint(int[] givenArray, int givenSum)&#123; System.out.println(\"Given array : \" + Arrays.toString(givenArray)); System.out.println(\"Given sum : \" + givenSum); System.out.println(\"Integer numbers, whose sum is equal to value : \" + givenSum); printPairs(givenArray, givenSum); &#125;&#125; 输出结果： 123456789101112Given array : [2, 4, 3, 5, 7, 8, 9]Given sum : 7Integer numbers, whose sum is equal to value : 7(2, 5) (4, 3) Given array : [2, 4, 3, 5, 6, -2, 4, 7, 8, 9]Given sum : 7Integer numbers, whose sum is equal to value : 7(2, 5) (4, 3) (3, 4) (-2, 9) 以上方法的时间复杂度是O(n^2)，因此需要对其进行改进优化。为了在一个数组中找到和为给定值的两个数字，我们可能不需要对每个数字进行比较。我们在这里可以做的是将所有数字存储在哈希表中，并检查它是否在一对中包含第二个值。例如，如果给定的和是4，成对的一个数是3，那么另一个数必须是1或-7。您还记得我们问的第一个问题吗？如果数组只包含正数，那么我们不需要在map中检查负值。该解决方案如何优于前一个解决方案呢？这个方案需要较少的比较。只有n次迭代数组并在集合中插入值，因为在哈希表中，add()和contains()都是O(1)操作。所以解决方案的总复杂度是O(n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays;import java.util.HashSet;import java.util.Set;/** * Java Program to find two elements in an array that sum to k. */public class ArraySumUsingSet &#123; public static void main(String args[]) &#123; prettyPrint(getRandomArray(9), 11); prettyPrint(getRandomArray(10), 12); &#125; /** * Given an array of integers finds two elements in the array whose sum is equal to n. * @param numbers * @param n */ public static void printPairsUsingSet(int[] numbers, int n)&#123; if(numbers.length &lt; 2)&#123; return; &#125; Set set = new HashSet(numbers.length); for(int value : numbers)&#123; int target = n - value; // if target number is not in set then add if(!set.contains(target))&#123; set.add(value); &#125;else &#123; System.out.printf(\"(%d, %d) %n\", value, target); &#125; &#125; &#125; /* * Utility method to find two elements in an array that sum to k. */ public static void prettyPrint(int[] random, int k)&#123; System.out.println(\"Random Integer array : \" + Arrays.toString(random)); System.out.println(\"Sum : \" + k); System.out.println(\"pair of numbers from an array whose sum equals \" + k); printPairsUsingSet(random, k); &#125; /** * Utility method to return random array of Integers in a range of 0 to 15 */ public static int[] getRandomArray(int length)&#123; int[] randoms = new int[length]; for(int i=0; i&lt;length; i++)&#123; randoms[i] = (int) (Math.random()*15); &#125; return randoms; &#125;&#125; 执行结果： 123456789Random Integer array : [7, 9, 3, 6, 4, 7, 9, 10, 8]Sum : 11pair of numbers from an array whose sum equals 11(4, 7) (8, 3) Random Integer array : [0, 13, 6, 5, 14, 6, 4, 11, 11, 3]Sum : 12pair of numbers from an array whose sum equals 12(6, 6) 这里用到了HashSet，HashSet内部用到了HashMap。因此这个方案需要额外O(n)d的空间来在哈希表或集合中存储数字，所以如果数组非常大，您需要额外的空间也会非常大，这可能是个问题。更有效的不使用额外空间的就地解决方案是对数组进行排序，并使用两个指针从开始和结束两个方向扫描数组。如果这两个值的和等于给定的数字，那么我们将输出该对并将其向前推进。如果两个数字的和小于k，则增大左指针；如果和大于k，则减小右指针，直到两个指针在数组的某个部分相遇。由于排序，此解决方案的复杂性将是O（nlogn）。使用一个就地排序算法（如Quicksort）对数组进行排序，因为没有额外的空间。幸运的是，arrays.sort()方法使用双支点快速排序算法对原始数组进行排序。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Arrays;import java.util.HashSet;import java.util.Set;/** * Java Program to find all pairs on integer array whose sum is equal to k */public class PrintArrayPairs &#123; public static void main(String args[]) &#123; prettyPrint( new int[]&#123; 12, 14, 17, 15, 19, 20, -11&#125;, 9); prettyPrint( new int[]&#123; 2, 4, 7, 5, 9, 10, -1&#125;, 9); &#125; /** * Given a number finds two numbers from an array so that the sum is equal to that number k. * @param numbers * @param k */ public static void printPairsUsingTwoPointers(int[] numbers, int k)&#123; if(numbers.length &lt; 2)&#123; return; &#125; Arrays.sort(numbers); int left = 0; int right = numbers.length -1; while(left &lt; right)&#123; int sum = numbers[left] + numbers[right]; if(sum == k)&#123; System.out.printf(\"(%d, %d) %n\", numbers[left], numbers[right]); left = left + 1; right = right -1; &#125;else if(sum &lt; k)&#123; left = left +1; &#125;else if (sum &gt; k) &#123; right = right -1; &#125; &#125; &#125; /* * Utility method to print two elements in an array that sum to k. */ public static void prettyPrint(int[] random, int k)&#123; System.out.println(\"input int array : \" + Arrays.toString(random)); System.out.println(\"All pairs in an array of integers whose sum is equal to a given value \" + k); printPairsUsingTwoPointers(random, k); &#125; &#125; 运行结果输出： 12345678input int array : [12, 14, 17, 15, 19, 20, -11]All pairs in an array of integers whose sum is equal to a given value 9(-11, 20) input int array : [2, 4, 7, 5, 9, 10, -1]All pairs in an array of integers whose sum is equal to a given value 9(-1, 10) (2, 7) (4, 5) 以上探讨了三种方法，从最开始暴力算法，到后面的O(n)时间复杂度和空间复杂度，再到O(nlogn)，不断进行优化。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://www.haoming.fun/categories/算法与数据结构/"}],"tags":[{"name":" 面试题精选","slug":"面试题精选","permalink":"https://www.haoming.fun/tags/面试题精选/"}],"author":"Peng Fang"},{"title":"记最近的一些感悟（深度好文）","slug":"记最近的一些感悟（深度好文）","date":"2019-08-26T09:45:00.000Z","updated":"2019-08-26T09:51:30.087Z","comments":true,"path":"2019/08/26/记最近的一些感悟（深度好文）/","link":"","permalink":"https://www.haoming.fun/2019/08/26/记最近的一些感悟（深度好文）/","excerpt":"","text":"先以迈吉客创始人的一句话开头： 永远保持极度开放和深度思考，我们想要看到世界有什么变化，就必须先让自己有所变化。 做技术的人很容易一头扎进技术里，除了钻研技术什么也不想，想说我就把技术做牛逼了。结果这样就是：我对这个世界开的窗就这么大，只有一些关心的部分才被照射进来。也就是说，思维的开放，是否打开心灵拥抱新鲜事物，决定你的知识面以及你的格局。 这个世界的信息量太大，可能我们一辈子都没办法对其有深入的理解。有一点我想都是一样的，我们不想成为一个狭隘的人，一个浅薄的人，一个无知的人。因此这需要我们用一辈子的时间来学习和思考。如果自己成天就对着电脑，不与人接触，不输入，就类似于将自己关在窄井里，每天能看到的就是井口那么大一点天空。 然后就是深度思考，思考范围大到国家、社会、行业、公司，小到个人（自己及他人），需要多多思考，特别是深度的思考，思考现象背后的本质。 自然界有他规律，社会有他的规则。人是处在社会群体之中，群体有他的规则，那么就有制定规则的人。作为普通的人，很难去制定规则吧。但是我们可以关注行业发展历程及趋势，用户需求和心理，精通某方面业务和技术。一个规章一个规则是为了解决问题，一个产品是为了响应规则的或者满足社会群体心理。社会或行业的发展有国家政策及发展等宏观因素的影响，也有其文化历史等因素的影响，也有社会人生活生理需求的影响，归根到底是人，人组成社会，建立国家，塑造历史。我们需要考虑我们为什么生而为人，活着是为了什么，权利、地位、财富、名誉、家庭？不管怎样，我们应该都想成为一个有价值的人；一个有用的人；有成果的一个人；能够撑起家庭，有富足生活的一个人。当我们能承担好责任，实现价值，也不枉走这一遭。 前面讲到，了解这个世界，首先是开放格局，对世界open。然后就是了解人类历史文化，中西历史，中外文化，然后就是社会学，社会的运行规律，最后是人的心理分析。总之，了解这个世界就是了解社会和自己。我觉得首先是了解自己，与自己达成和解，建立稳定的人格，然后推己及人，对他人有同情心。据我观察，企业高管好多都是熟读历史，对人文有一定研究和造诣。为什么要读史，就是遇事的时候可以从历史中找到参照，指导决策。 做研发的目的就是开发一款产品，而产品的存在是为了解决问题，这个问题可能是企业的，可能是个人的。解决问题大多是为了盈利。那么为了创造价值，我们怎么能做好一款产品呢？我觉得，其中包含对行业发展的理解，对业务的钻研，以及对用户需求的把握等。提到互联网产品，还离不开对内容和IP的建设打造，离不开产品的运营，就就牵扯到商业运作，涉及到理解人性。我最近才明白，一个产品的成功，最开始靠的是想法，是创意，是商业运作，是产品设计，而技术是辅助，它被放在了一个较低的位置。有一个人告诉我：技术做得好，就只是混口饭吃！综上，做好事情需要有见识，依赖认知。就这就涉及到对思维方式的训练，以及建立自己的一套专业的合理的知识架构，当面临抉择，就用这套方法论去框去量。为什么有的人（比如说我）对问题没有看法提不出意见，就是没到那个层次，没有概念。以上是我第一方面的感悟。 现在身为一个技术人不容易，通常来讲，把技术顶尖的少数人成为架构师。为什么说做技术不容易呢？因为有太多的技术要学，不仅要学，还要精通。引用一个对架构师的定义： 细致全面善于沟通，技术上深度广度都没问题， 又喜欢这个工作，还会不时做底层实现，从业务和开发两个角度出发，搭出“架构”来是为了开发效率，为了运行效率，为了开发质量，为了业务灵活和运行稳定，为了维护方便等等这样的人，个人认为可以称为“架构师”。 那么提取以上的关键字：第一、 善于沟通第二、技术专家，大牛，技术广度、深度，绝对的动手能力（会底层，搭架构）第三、业务专家，定制化解决方案，兼顾业务和技术 除了重视技术以外，甚至应该更加重视沟通和业务，这是我第二方面的思考。 然后是对技术方向的一些思考，写业务写久了，难免不会觉得没意思没有技术含量。那什么是有含量的工作呢？就是牛逼的工作？什么工作就牛逼呢？就是很难的工作，多数人惧怕和难以完成的工作。哪些工作很难呢？比如写个编译器，撸一个框架，手动实现一些算法，做一些前沿的应用（比如混合现实）等等。因此我觉得需要做的是：关注底层原理，必要时补一些基础，不妨造造轮子撸撸框架。 首先是，重视和夯实基础，核心原理和算法其次是，阅读开源项目代码，学习好的实践，来个优化或精简版最后是，随着项目和经验的积累，理解现有的不足，根据需要作出改进，解决某些问题，从而动手实现工具框架 行胜于言，说再多想再多，不行动也是白搭。有了想法立马干，执行力要强，切记拖沓，拖延是自己给自己架起的高墙。一切落实到行动，有输出。想好了先做了再说，做出来再说，不要以为还有些欠缺，时机还未到，还有些顾虑。一件事一件事做好，有始有终，有头有尾。 为什么懂得很多道理，却依然过不好这一生？常常因为自己内心架起的高墙。我不自信，我不敢交流，不敢表达，在意他人的眼光和评价。找不准方向，不知道自己的爱好，这也行那也可以，左瞧瞧右看看，浅尝辄止，有始无终。内心有焦虑，不平和，不坚定，没有主意，容易变化。 人生漫漫，回头是岸。所谓修行，一是改变内心的想法，第二是做，做的过程中体会，然后在修改内心的想法。必要时用一些方法破除我执。想做的事情很多，到底哪些是必须做的，理清楚抓重点，然后就是做了后需要形成闭环。 “修心”： 接受自己，包容自己——允许自己做得不好，接纳一个不完美的自己，降低对自己的期望值，承认自己是个普通人。接纳自己，是爱自己的第一步。 无常，不知今天是否最后一天，所以珍惜时间吧 豁达，想想宇宙之大人如尘埃，想想死亡，终究一天我们将离去，破除我执（很难），包容他人 危机意识，如果出来创业，能不能活得了 “行路” 练习讲话，有输入和输出。读文章发表感想，录音，达到讲话听着舒服。准备一些套路（模板）。重要场合一定准备充分。呼吸非常均匀，非常舒服 坚持锻炼 读书和思考，写日志 做科学研究。有目标，理论和实践并重。关注算法、性能、安全、应用（某一方面，比如风控）。精力有限，想清楚要做的事，每天精进一点。建立自己的知识框架和方法论，争取每周有分享 学习商业模式，品牌打造，产品设计。将想法落地，出成果 相信不断修行，会有更多的领悟和收获，喜爱自己，喜爱他人，生活富足，满心欢喜。","categories":[{"name":"心得感悟","slug":"心得感悟","permalink":"https://www.haoming.fun/categories/心得感悟/"}],"tags":[],"author":"Peng Fang"},{"title":"在Centos安装MongoDB","slug":"在Centos安装MongoDB","date":"2019-08-14T11:10:00.000Z","updated":"2019-08-14T12:05:16.479Z","comments":true,"path":"2019/08/14/在Centos安装MongoDB/","link":"","permalink":"https://www.haoming.fun/2019/08/14/在Centos安装MongoDB/","excerpt":"","text":"创建yum源文件vim /etc/yum.repos.d/mongodb-org-4.0.repo添加以下内容[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc 使用 yum 安装MongoDByum install -y mongodb-org 配置MongoDBvim /etc/mongod.conf配置mongod.conf 开启远程连接： 把第30行bindIp: 127.0.0.1改为bindIp: 0.0.0.0 启动MongoDB服务systemctl start mongod服务器本地连接测试mongo –host 127.0.0.1 –port 27017 本地连接MongoDB需要开启防火墙访问策略： 附启用/停止/重启 MongoDB 服务的命令systemctl start mongod.servicesystemctl stop mongod.servicesystemctl restart mongod.service","categories":[{"name":"运维","slug":"运维","permalink":"https://www.haoming.fun/categories/运维/"}],"tags":[],"author":"Peng Fang"},{"title":"数组：如何从整数数组中找出最大和最小值","slug":"数组：如何从整数数组中找出最大和最小值","date":"2019-08-14T06:35:00.000Z","updated":"2019-08-14T09:56:41.604Z","comments":true,"path":"2019/08/14/数组：如何从整数数组中找出最大和最小值/","link":"","permalink":"https://www.haoming.fun/2019/08/14/数组：如何从整数数组中找出最大和最小值/","excerpt":"","text":"原文 前言对于任何软件开发人员来说，很好地理解数组数据结构都是非常重要的，为了增进对其理解，初学者可以做很多编程练习。其中之一是编写一个程序来查找整数数组中最小和最大的数字。Java程序员与其他程序员一样，不仅仅是理解数组，还要知道关系操作符的使用。在这个程序中，您需要编写一个方法，它将接受整数数组，然后从该数组中打印最大和最小的数字。不允许使用任何第三方库或API方法，这意味着您需要使用Java编程语言的基本工具来完成这一练习，其中包括Java语言包中的运算符、控制语句、关键字和一些类。 该问题也被称为在数组中查找最大值和最小值，这里提到的技术也可以用在任何其他编程语言中。另外，您还可以编写JUnit测试用例来测试您的方法，我没有这样做，而是依赖简单的主方法来测试我的代码，显示输出结果并保持简短，这对于任何示例或演示都是必不可少的。 问题分析我们创建了一个名为largestAndSmallest（int[]numbers）的方法来打印传递给程序的int数组中最大和最小的数字。我们使用最大和最小两个变量来存储数组中的最大值和最小值。最初，最大值初始化为integer.MIN_VALUE，最小值初始化为integer.MAX_VALUE。 在循环的每个迭代中，我们将当前数字与最大值和最小值进行比较，并相应地更新它们。因为如果一个数字大于最大值，它不能小于最小值，这意味着如果第一个条件为真您不需要继续比较，这就是为什么我们使用if else代码块，而其他部分只在第一个条件不为真时执行。 这里有另一种逻辑，从Java中找到一个数组中最大的元素，这里不是用整数。 由于Java中数组不重写toString方法，所以我们使用Arrays.toString()来打印数组的内容。记住，这个函数不属于核心逻辑，所以可以使用它。由于这是一个静态的方法，我们可以直接从Java中的主方法调用它，我们的测试代码也是如此。我们将随机数组传递给这个方法，看看该方法返回的最大和最小数字是否正确。对于自动化测试，单元测试更好，但是为了演示，可以使用主要方法。 问题解答参考代码 123456789101112131415161718192021222324252627282930313233import java.util.Arrays;/** * Java program to find largest and smallest number from an array in Java. * You cannot use any library method both from Java and third-party library. * */public class MaximumMinimumArrayDemo&#123; public static void main(String args[]) &#123; largestAndSmallest(new int[]&#123;-20, 34, 21, -87, 92, Integer.MAX_VALUE&#125;); largestAndSmallest(new int[]&#123;10, Integer.MIN_VALUE, -2&#125;); largestAndSmallest(new int[]&#123;Integer.MAX_VALUE, 40, Integer.MAX_VALUE&#125;); largestAndSmallest(new int[]&#123;1, -1, 0&#125;); &#125; public static void largestAndSmallest(int[] numbers) &#123; int largest = Integer.MIN_VALUE; int smallest = Integer.MAX_VALUE; for (int number : numbers) &#123; if (number &gt; largest) &#123; largest = number; &#125; else if (number &lt; smallest) &#123; smallest = number; &#125; &#125; System.out.println(\"Given integer array : \" + Arrays.toString(numbers)); System.out.println(\"Largest number in array is : \" + largest); System.out.println(\"Smallest number in array is : \" + smallest); &#125;&#125; 代码参考 123456789101112Given integer array : [-20, 34, 21, -87, 92, 2147483647]Largest number in array is : 2147483647Smallest number in array is : -87Given integer array : [10, -2147483648, -2]Largest number in array is : 10Smallest number in array is : -2147483648Given integer array : [2147483647, 40, 2147483647]Largest number in array is : 2147483647Smallest number in array is : 40Given integer array : [1, -1, 0]Largest number in array is : 1Smallest number in array is : -1 结语这就是如何在Java中从整数数组中找到最大和最小数的问题。正如我所说的，这个问题也可以被问到如何用Java找到数组中的最大值和最小值，所以不要混淆。顺便说一句，有更多的方法来完成相同的任务，您可以通过实践来不同地编写解决方案的代码。你能写一个不同于这个的解决方案吗？去试一试吧。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://www.haoming.fun/categories/算法与数据结构/"}],"tags":[{"name":"面试题精选","slug":"面试题精选","permalink":"https://www.haoming.fun/tags/面试题精选/"}],"author":"Peng Fang"},{"title":"数组：怎样不使用Java集合API从数组移除重复元素","slug":"数组：怎样不使用Java集合API从数组移除重复元素","date":"2019-08-13T07:00:00.000Z","updated":"2019-08-14T09:57:21.609Z","comments":true,"path":"2019/08/13/数组：怎样不使用Java集合API从数组移除重复元素/","link":"","permalink":"https://www.haoming.fun/2019/08/13/数组：怎样不使用Java集合API从数组移除重复元素/","excerpt":"","text":"原文 前言这是在Java技术面试中经常遇到的一个编程问题。问题是在不使用任何集合API类（如set或linkedhashset）的情况下从整数数组中删除重复项，这可以使此任务变得简单。一般来说，如果您需要在任何项目工作中这样做，我建议更好地使用集合接口，尤其是LinkedHashSet，因为这也保持了元素插入集合的顺序。仅从技术面试的角度来看，您需要使用循环或递归来完成这项工作，这取决于您最擅长的领域是什么。本文分享了一个naive的解决方案，如果应用到生产环境会有很多限制，它不是最好的解决方案，但仍然是一个解决方案。 主要问题不是找到重复项，而是删除它们。由于数组是静态的固定长度数据结构，因此不能更改其长度。这意味着，从数组中删除元素需要创建一个新数组并将内容复制到该数组中。 如果输入数组包含大量重复项，那么这可能会导致大量临时数组。它还增加了复制内容的成本，这可能非常糟糕。考虑到这个限制，您需要制定一个策略来最小化内存和CPU需求。 在这个编程问题中，我们没有使用任何集合类来删除数组重复项，比如使用linkedhashset的删除重复项的方法。如果面试官没有特别提到具体的集合，你仍然可以使用这个解决方案。 您需要做的只是先将数组转换为arraylist，然后从该arraylist创建一个linkedhashset。在本例中，我们通过不将重复项复制到结果数组中来从数组中删除重复项，此解决方案实际上不是删除重复项，而是用默认值替换它。 解决办法现在看看我们的Java解决方案，从整数数组中删除重复元素： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Arrays;/** * Java program to remove duplicates from this array. You don't * need to physically delete duplicate elements, replacing with null, or * empty or default value is ok. * */public class TechnicalInterviewTest &#123; public static void main(String args[]) &#123; int[][] test = new int[][]&#123; &#123;1, 1, 2, 2, 3, 4, 5&#125;, &#123;1, 1, 1, 1, 1, 1, 1&#125;, &#123;1, 2, 3, 4, 5, 6, 7&#125;, &#123;1, 2, 1, 1, 1, 1, 1&#125;,&#125;; for (int[] input : test) &#123; System.out.println(\"Array with Duplicates : \" + Arrays.toString(input)); System.out.println(\"After removing duplicates : \" + Arrays.toString(removeDuplicates(input))); &#125; &#125; /* * Method to remove duplicates from array in Java, without using * Collection classes e.g. Set or ArrayList. Algorithm for this * method is simple, it first sort the array and then compare adjacent * objects, leaving out duplicates, which is already in the result. */ public static int[] removeDuplicates(int[] numbersWithDuplicates) &#123; // Sorting array to bring duplicates together Arrays.sort(numbersWithDuplicates); int[] result = new int[numbersWithDuplicates.length]; int previous = numbersWithDuplicates[0]; result[0] = previous; for (int i = 1; i &lt; numbersWithDuplicates.length; i++) &#123; int ch = numbersWithDuplicates[i]; if (previous != ch) &#123; result[i] = ch; &#125; previous = ch; &#125; return result; &#125;&#125; 输出 12345678Array with Duplicates : [1, 1, 2, 2, 3, 4, 5]After removing duplicates : [1, 0, 2, 0, 3, 4, 5]Array with Duplicates : [1, 1, 1, 1, 1, 1, 1]After removing duplicates : [1, 0, 0, 0, 0, 0, 0]Array with Duplicates : [1, 2, 3, 4, 5, 6, 7]After removing duplicates : [1, 2, 3, 4, 5, 6, 7]Array with Duplicates : [1, 2, 1, 1, 1, 1, 1]After removing duplicates : [1, 0, 0, 0, 0, 0, 2] 结语这就是如何在不使用集合类的情况下从Java中删除重复数组的方法。正如我之前所说，这个解决方案并不完美，并且有一些严重的局限性，就当做一个练习留给您去发现吧。 关于从结果数组中永久删除重复项，一种方法可以是计算重复项的数量，然后创建一个大小正确的数组，即长度-重复项，然后将内容从中间结果数组复制到最终数组，去掉标记为重复项的元素。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://www.haoming.fun/categories/算法与数据结构/"}],"tags":[{"name":"面试题精选","slug":"面试题精选","permalink":"https://www.haoming.fun/tags/面试题精选/"}],"author":"Peng Fang"},{"title":"数组：怎样从1到100的整数数组中找出缺少的数字","slug":"：怎样从1到100的整数数组中找出缺少的数字","date":"2019-08-13T05:52:00.000Z","updated":"2019-08-14T09:58:11.252Z","comments":true,"path":"2019/08/13/：怎样从1到100的整数数组中找出缺少的数字/","link":"","permalink":"https://www.haoming.fun/2019/08/13/：怎样从1到100的整数数组中找出缺少的数字/","excerpt":"","text":"前言编程面试中最常被问及的问题之一是，编写一个程序来查找数组中缺少的数字。这种编码面试问题不仅在小型初创企业中被问到，而且在谷歌、亚马逊、Facebook、微软等一些最大的技术公司中也被问到，大多是这些公司在校园招聘毕业生时会被问到。 这个问题最简单的版本是在100个整数的区域中查找缺少的元素，该区域包含1到100之间的数字。这可以通过使用n（n+1）/2计算序列的和很容易地解决，这也是最快和最有效的方法之一，但如果数组包含多个缺少的数字或数组包含重复的数字，则不能使用它。 这时面试官可以提出后续问题，以考查候选人不同条件下解决问题的能力。所以，如果你通过了这个，他们会要求你在一个重复的数组中找到丢失的数字。这可能很棘手，但您很快就会发现在数组中查找丢失和重复数字的另一种方法是对其进行排序。 在已排序的数组中，可以比较一个数字是否等于预期的下一个数字。或者，您也可以使用Java中的BitSet来解决这个问题。 问题描述我们将1到100之间的数字放入一个整数数组中，找出缺少哪个数字的最佳方法是什么？如果面试官特别提到1到100，那么你也可以使用上面的技巧来计算这个系列的总和，如下所示。如果它有多个丢失的元素，那么您可以使用位集类，当然，只有在您的面试官允许的情况下。 1）级数和：公式：n（n+1）/2（但只适用于缺少的一个数） 2）如果数组缺少多个元素，则使用位集。 我提供了另一个目的的位集解决方案，以介绍这个不错的实用程序类。在许多采访中，我曾向Java开发人员询问过这个类，但许多人甚至没有意识到这一点。我认为这个问题是学习如何在Java中使用BITSET的好方法。 顺便说一句，如果你要去面试，除了这个问题，它还很好地知道如何在数组和程序中找到重复的数字，以在整数数组中找到第二个最高的数字。通常情况下，这些问题都会在这之后作为后续问题被问到。 问题解答参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Arrays;import java.util.BitSet; /** * Java program to find missing elements in a Integer array containing * numbers from 1 to 100. * */public class file &#123; public static void main(String args[]) &#123; // one missing number printMissingNumber(new int[]&#123;1, 2, 3, 4, 6&#125;, 6); // two missing number printMissingNumber(new int[]&#123;1, 2, 3, 4, 6, 7, 9, 8, 10&#125;, 10); // three missing number printMissingNumber(new int[]&#123;1, 2, 3, 4, 6, 9, 8&#125;, 10); // four missing number printMissingNumber(new int[]&#123;1, 2, 3, 4, 9, 8&#125;, 10); // Only one missing number in array int[] iArray = new int[]&#123;1, 2, 3, 5&#125;; int missing = getMissingNumber(iArray, 5); System.out.printf(\"Missing number in array %s is %d %n\", Arrays.toString(iArray), missing); &#125; /** * A general method to find missing values from an integer array in Java. * This method will work even if array has more than one missing element. */ private static void printMissingNumber(int[] numbers, int count) &#123; int missingCount = count - numbers.length; BitSet bitSet = new BitSet(count); for (int number : numbers) &#123; bitSet.set(number - 1); &#125; System.out.printf(\"Missing numbers in integer array %s, with total number %d is %n\", Arrays.toString(numbers), count); int lastMissingIndex = 0; for (int i = 0; i &lt; missingCount; i++) &#123; lastMissingIndex = bitSet.nextClearBit(lastMissingIndex); System.out.println(++lastMissingIndex); &#125; &#125; /** * Java method to find missing number in array of size n containing * numbers from 1 to n only. * can be used to find missing elements on integer array of * numbers from 1 to 100 or 1 - 1000 */ private static int getMissingNumber(int[] numbers, int totalCount) &#123; int expectedSum = totalCount * ((totalCount + 1) / 2); int actualSum = 0; for (int i : numbers) &#123; actualSum += i; &#125; return expectedSum - actualSum; &#125; &#125; 输出 1234567891011121314Missing numbers in integer array [1, 2, 3, 4, 6], with total number 6 is 5Missing numbers in integer array [1, 2, 3, 4, 6, 7, 9, 8, 10], with total number 10 is 5Missing numbers in integer array [1, 2, 3, 4, 6, 9, 8], with total number 10 is 5710Missing numbers in integer array [1, 2, 3, 4, 9, 8], with total number 10 is 56710Missing number in array [1, 2, 3, 5] is 4 结语您可以看到如何使用正确的数据结构轻松地解决问题，这是这个问题的关键收获，对于更多的编码问题，您可以查看《the Cracking the Coding Interviews》，这是来自谷歌、亚马逊、微软等科技公司编程面试的189个编码问题的集合。 这就是在一个由100个元素组成的数组中查找缺失元素的全部内容。正如我所说，了解这个技巧是很好的，它只需要计算数字的和，然后从实际和中减去它，但是如果数组中有多个缺少的数字，就不能使用这个技巧。另一方面，BitSet解决方案更通用，因为您可以使用它在整数数组中查找多个缺少的值。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://www.haoming.fun/categories/算法与数据结构/"}],"tags":[{"name":"面试题精选","slug":"面试题精选","permalink":"https://www.haoming.fun/tags/面试题精选/"}],"author":"Peng Fang"},{"title":"Vue 编码风格官方指南整理","slug":"风格官方指南整理","date":"2019-08-13T05:42:00.000Z","updated":"2019-08-13T05:45:32.160Z","comments":true,"path":"2019/08/13/风格官方指南整理/","link":"","permalink":"https://www.haoming.fun/2019/08/13/风格官方指南整理/","excerpt":"","text":"必要 组件名为多个单词 组件名应该始终是多个单词的，根组件 App 以及 、 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突。 12345678// 好例子Vue.component('todo-item', &#123; // ...&#125;)export default &#123; name: 'TodoItem' // ...&#125; 组件的 data 必须是一个函数 当在组件中使用 data 属性的时候 (除了 newVue 外的任何地方)，它的值必须是返回一个对象的函数。 Prop 定义应该尽量详细 在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。 123456789101112131415// 好例子props: &#123; status: &#123; type: String, required: true, validator: function (value) &#123; return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 &#125; &#125;&#125; 避免 v-if 和 v-for 用在一起 当 Vue 处理指令时， v-for 比 v-if 具有更高的优先级 推荐 组件文件 只要有能够拼接文件的构建系统，就把每个组件单独分成文件。 当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。 组件名中的单词顺序 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。 要注意在你的应用中所谓的“高级别”是跟语境有关的。 比如对于一个带搜索表单的应用来说，它可能包含这样的组件： 12345678910components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue// 上面命名难看出哪些是针对搜索的，重新命名如下：components/|- SearchButtonClear.vue|- SearchInputExcludeGlob.vue|- SettingsCheckboxLaunchOnStartup.vue 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为： 在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。 存在组件重名 (比如存在多个 ButtonDelete 组件) 的时候在编辑器里更难快速定位。 让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。 完整单词的组件名 组件名应该倾向于完整单词而不是缩写。 123SdSettings.vuevsStudentDashboardSettings.vue // 好例子 Prop 名大小写 在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。 我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。 12345678// 反例props: &#123; 'greeting-text': String&#125;// 好例子props: &#123; 'greetingText': String&#125; 多个特性的元素 多个特性的元素应该分多行撰写，每个特性一行。在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。 123456789// 好的例子&lt;img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\" &gt;&lt;my-component foo=\"a\" bar=\"b\"&gt;&lt;/my-component&gt; 简单的计算属性 应该把复杂计算属性分割为尽可能多的更简单的计算属性。 更简单、命名得当的计算属性是这样的： 易于测试当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。 易于阅读简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。 更好的“拥抱变化”任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。 谨慎使用（有潜在危险的模式） 没有在 v-if/ v-else-if/ v-else 中使用 key 如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 &lt;div&gt; 元素)。默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。 1234567891011&lt;!-- 好的例子--&gt;&lt;div v-if=\"error\" key=\"search-status\"&gt; 错误：&#123;&#123; error &#125;&#125;&lt;/div&gt;&lt;div v-else key=\"search-results\"&gt; &#123;&#123; results &#125;&#125;&lt;/div&gt; scoped 中的元素选择器 在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。大量的元素和特性组合的选择器 (比如 button[data-v-f3f3eg9]) 会比类和特性组合的选择器慢，所以应该尽可能选用类选择器。 隐性的父子组件通信 应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。 非 Flux 的全局状态管理 应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。Vuex 提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。","categories":[{"name":"编码规范","slug":"编码规范","permalink":"https://www.haoming.fun/categories/编码规范/"}],"tags":[{"name":"编码规范","slug":"编码规范","permalink":"https://www.haoming.fun/tags/编码规范/"}],"author":"Peng Fang"},{"title":"vs code 常用快捷键","slug":"vs-code-常用快捷键","date":"2019-07-30T10:48:00.000Z","updated":"2019-07-30T11:05:47.906Z","comments":true,"path":"2019/07/30/vs-code-常用快捷键/","link":"","permalink":"https://www.haoming.fun/2019/07/30/vs-code-常用快捷键/","excerpt":"","text":"一次搜索所有文件的文本 12Windows: Ctrl + Shift + FMac: Command + Shift + F 设置主题皮肤，Tab强调色 使用 Material Theme 来扩展 VsCode 的主题； 快捷键 Ctrl + Shift + P，选择 Material Theme: Set accent color并从列表中选择一个颜色，它将更改选项卡的下划线颜色 重新打开 关闭的编辑页面 12Windows: Ctrl + Shift + TMac: command + Shift + T 集成终端 12Windows: Ctrl + `Mac: control + ` 通过 Ctrl + ` 可以打开或关闭终端 查看正在运行的插件 按下快捷键Ctrl + Shift + P，并输入`Show running extensions来查看所有你安装的正在运行的插件 将选项卡交换到不同的组 通过按Ctrl + Alt +右箭头（Mac：Control + Option +右箭头）将标签移动到右侧的组，或者按Ctrl + Alt + 左箭头将标签转移到单独的标签组 （Mac：Control + Option +左箭头））将标签移动到左侧的组 选择左侧/右侧的所有内容 你可以选择光标右侧或左侧的所有内容： 12Windows: Ctrl + Shift + Home/EndMac: command + Shift + Home/End 苹果笔记本没home键，可以用组合键实现 1234567fn键+左方向键是HOMEfn键+右方向键是ENDfn+上方向键是page upfn+下方向键是page down 删除上一个单词 要删除前一个单词，可以按Ctrl + Backspace (Mac: option + delete)。这在你打错字的时候非常有用。 逐个选择文本 可以通过快捷键Ctrl + Shift +右箭头(Mac: option + Shift +右箭头)和Ctrl + Shift +左箭头(Mac: option + Shift +左箭头)逐个选择文本 重复的行 复制行只需按 Shift + Alt + 向下箭头 (Mac: command + Shift + 向下箭头) 移至文件的开头/结尾 使光标移到文件的第一行或最后一行，最快的方法是按Ctrl + Home(Mac: command + Home)键开头，然后按Ctrl + End (Mac: command + End)键结尾 批量修改文本 可以选择任何一组文本，如果该选中文本出现多个，可以通过按Ctrl + F2 (Mac: command + F2)一次改所有出现的文本。 向上/向下移动一行 按Alt + 向上箭头(Mac: command+ 向上箭头)当前行向上移动，按Alt + 向下箭头(Mac: command+ 向下箭头))当前行向下移动 删除一行 使用Ctrl + X剪切命令(Mac：command + X)来删除一行 或者使用 Ctrl + Shift + K(Mac: command + Shift + K)命令 将编辑器向左或向右移动 通过 Ctrl+Shift+PgUp/PgDown(Mac: command + +Shift+PgUp/PgDown)向左/向右移动编辑器 复制光标向上或者向上批量添加内容 按Ctrl + Alt +向上箭头(Mac: Control + Option +向上箭头)将光标添加到上面，按Ctrl + Alt +向下箭头(Mac: Control + Option + 向下箭头)将光标添加到下面 选中了多行的光标后，可以按左右键或者End键，然后可以在多个光标位置，批量添加内容。 以上，try and enjoy it！","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://www.haoming.fun/tags/IDE/"}],"author":"Peng Fang"},{"title":"中止HTTP请求或文件上传的方法解析","slug":"中止HTTP请求或文件上传的方法解析","date":"2019-06-30T14:23:00.000Z","updated":"2019-06-30T14:24:17.437Z","comments":true,"path":"2019/06/30/中止HTTP请求或文件上传的方法解析/","link":"","permalink":"https://www.haoming.fun/2019/06/30/中止HTTP请求或文件上传的方法解析/","excerpt":"","text":"某些场景，比如切换TAB、关闭窗口或手动触发中止时，我们想取消正在执行中的HTTP请求，特别当上传大文件时候会有中止上传的需求。开始以为中断通信，当socket传输数据时比较好处理。后来一查原来ajax请求中也能处理。 先看用原生js如何中断http请求API：XMLHttpRequest.abort()如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。示例：12345678var xhr = new XMLHttpRequest(), method = \"GET\", url = \"https://developer.mozilla.org/\";xhr.open(method,url,true);xhr.send();xhr.abort(); 然后想到axios拦截器应该也能中断请求吧 Axios拦截器如何中止HTTP请求Axios能使用一个取消token来取消一个请求 Axios 取消token API 基于 JS可取消去异步操作的建议 可以使用CancelToken.source工厂来生成一个cancel token： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // handle error &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// cancel the request (the message parameter is optional)source.cancel('Operation canceled by the user.'); 注意，get请求的时候，cancelToken是放在第二个参数里；post的时候，cancelToken是放在第三个参数里。每次执行CancelToken.source()，就会返回一个包含新的“CancelToken”的对象。调用source.cancel()以后，实际执行的是以下函数： 12345678function cancel(message) &#123; if (token.reason) &#123; // Cancellation has already been requested return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason);&#125; 上面方法一旦resolvePromise以后，就会触发promise的then方法： 123456789101112if (config.cancelToken) &#123; // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; request.abort(); reject(cancel); // Clean up request request = null; &#125;); &#125; 实际上执行abort方法来中止请求，同时调用reject让外层的promise失败。 jQuery上传文件中执行取消jQuery通常上传文件会用到jquery.fileupload.js，那么用它上传文件的时候，怎么取消呢？同第一点那样可以通过XMLHttpRequest.abort()来取消，示例代码如下：123456789101112131415161718192021222324$( &apos;#fileUpload&apos; ).fileupload( &#123; dataType: &apos;json&apos;, add: function( e, data ) &#123; var abortBtn = $( &apos;&lt;a/&gt;&apos; ) .attr( &apos;href&apos;, &apos;javascript:void(0)&apos; ) .append( &apos;Abort&apos; ) .click( function() &#123; data.abort(); data.context.remove(); &#125; ); data.context = $( &apos;&lt;div/&gt;&apos; ) .appendTo( document.body ); data.context.append( $( &apos;&lt;p/&gt;&apos; ) ) .append( &apos;Uploading &apos; + data.files[0].name ) .append( abortBtn ); data.submit(); &#125;, done: function( e, data ) &#123; /* ... */ &#125; &#125;); 上面介绍了中止HTTP请求或文件上传的两种请情况。 参考文献https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort https://github.com/axios/axios#cancellation http://www.qiutianaimeili.com/html/page/2019/03/8grudzwvfmq.html https://stackoverflow.com/questions/26218571/how-to-add-a-cancel-upload-button-to-jquery-file-upload-basic-plugin","categories":[{"name":"前端","slug":"前端","permalink":"https://www.haoming.fun/categories/前端/"}],"tags":[{"name":"经验总结","slug":"经验总结","permalink":"https://www.haoming.fun/tags/经验总结/"}],"author":"Peng Fang"},{"title":"如何使用GraphQL,Koa和MongoDB建立强大的API","slug":"如何使用GraphQL-Koa和MongoDB建立强大的API","date":"2019-06-30T14:16:00.000Z","updated":"2019-06-30T14:21:43.229Z","comments":true,"path":"2019/06/30/如何使用GraphQL-Koa和MongoDB建立强大的API/","link":"","permalink":"https://www.haoming.fun/2019/06/30/如何使用GraphQL-Koa和MongoDB建立强大的API/","excerpt":"","text":"构建API是很有趣的，特别当你可以在项目中使用诸如koa、graphql和mongodb等技术的时候。 和Express一样，koa是一个Node框架，很多功能需要借助第三方中间件解决，由于其基于ES6 generator特性的异步流程控制，解决了”回调地狱”和麻烦的错误处理问题，大受开发者欢迎。Express采用callback来处理异步，Koa v1采用generator，Koa v2采用async/await。enerator和async/await使用同步的写法来处理异步，明显好于callback和promise，而async/await在语义化上又要比generator更强。 Koa Github 仓库Express Github 仓库 准备工作构建API的先决条件如下： 安装Node IDE，建议VS code 命令行终端 浏览器 如果具备了上述的条件，可以继续下面的工作了；如果没有的话，请安装它们。 打开终端，创建一个node项目，像这样：目前为止， 我们创建了项目目录，初始化一个新的node项目。接下来我们通过npm包来安装Koa、Mongo和GraphQL。首先安装koa： 1npm i koa 启动一个新的Koa服务非常简单。我们需要一个server.js文件，它的内容如下： 123456const Koa = require('koa');const app = new Koa();app.listen(9000);app.on('error', err =&gt; &#123; log.error('server error', err)&#125;); 用Node启动项目： 1node server.js GraphQL我们需要使用koa-mount和koa-graphql两个包来安装GraphQL，后者创建Graphql HTTP服务，前者将Koa应用挂载为中间件（挂载到某个路径上）,然后安装依赖包graphql 1npm i koa-mount koa-graphql graphql GraphQL需要传递初始的模式（schema）给GraphQL服务。下面创建一个：将Graphql schema放到graphql/schema.js里面。 1234567const &#123; buildSchema &#125; = require('graphql');const schema = buildSchema(` type Query &#123; hello: String &#125;`);module.exports = schema; 将Query类传给buildSchema函数，这里它的参数使用了模版字符串。现在我们能将初始的schema传给graphql服务了。 1234app.use(mount('/graphql', graphqlHTTP(&#123; schema: schema, graphiql: true&#125;))) 不要忘了导入koa-mount、koa-graphql，以及schema.js 123const mount = require('koa-mount');const graphqlHTTP = require('koa-graphql');const schema = require('https://www.haoming.fun/images/graphql/schema'); 通过node启动server.js以后，在浏览器地址栏访问localhost:9000/graphql最初的构建完成，但还不是很有用。我们还想通过 grahql API 来查询 MongoDB 保存的数据。 安装MongoDB为了使用GraphQL来读写数据，我们需要有个读写的来源，这就是MongoDB。下面介绍如何在Centos上安装MongoDB。 创建yum源文件vim /etc/yum.repos.d/mongodb-org-4.0.repo添加以下内容 123456[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc 使用 yum 安装MongoDByum install -y mongodb-org 配置MongoDBvim /etc/mongod.conf配置mongod.conf来开启远程连接： 把第30行bindIp: 127.0.0.1改为bindIp: 0.0.0.0 启动MongoDB服务systemctl start mongod服务器本地连接测试mongo --host 127.0.0.1 --port 27017 本地连接MongoDB需要开启防火墙访问策略： 另外附上：启用/停止/重启 MongoDB 服务的命令123systemctl start mongod.service systemctl stop mongod.service systemctl restart mongod.service 创建MongoDB用户创建数据库用户，可以参考MongoDB 用户权限管理 创建数据库在 MongoDB 中默认数据库是：test。 如果还没有创建过任何数据库，则集合/文档将存储在test数据库中。新建数据库可以参考怎么创建MongoDB数据库 数据库连接测试连接MongoDB的客户端很多，这里选择Robo 3T，新建MongoDB连接如下： 现在我们能使用Mongoose来和MongoDB配对。远程连接数据库的URL像这样： 1mongodb://$&#123;mongoAuth.user&#125;:$&#123;mongoAuth.pass&#125;@$&#123;ip&#125;:$&#123;port&#125;/$&#123;db&#125;&amp;authMechanism=SCRAM-SHA-256?authSource=admin 安装mongoose 1npm i mongoose 创建一个专门用来连接数据库的文件database.js 1234567891011121314const mongoose = require('mongoose');const initDB = () =&gt; &#123; mongoose.connect( 'mongodb://admin:password@47.99.xx.xx/test?authSource=admin&amp;authMechanism=SCRAM-SHA-256', &#123; useNewUrlParser: true &#125; ); mongoose.connection.once('open', () =&gt; &#123; console.log('connected to database'); &#125;);&#125;module.exports = initDB; 注意：MongoDB的连接字符串保证是能验证通过的。上面的代码块完成数据库连接的测试。我们需要将database.js引入到server.js，并调用initDB。server.js加入以下代码： 123const initDB = require('https://www.haoming.fun/images/database');initDB(); 如果以上的各个步骤都正确完成，控制台会打印“connected to databse”。 怎样可以不用每次修改代码以后，重新启动server呢？我们可以安装PM2来达到热加载的目的。先全局安装pm2包。 1npm install pm2 -g 再在package.json中添加启动脚本如下： 123\"scripts\": &#123; \"start\": \"pm2 start server.js\"&#125;, 执行yarn run start命令来启动我们的node服务。这样服务就在后台运行了，如果想杀掉进程，可以使用pm2 kill。现在我们不必一直重启我们的服务，pm2会自动刷新服务。 MongoDB 模型如果你以前使用过Mongo，你应该知道MongoDB让我们为数据创建模型。对于我们来说，这是一个很好的方法来构造数据的结构。创建一个models目录，下面创建一个文件gadget.js 1234567891011121314const mongoose = require('mongoose');const Schema = mongoose.Schema;/* 注意这里没有ID字段. 因为MongoDB会为所有Schema分配默认ID*/const GadgetSchema = new Schema(&#123; name: String, release_date: Date, by_company: String, price: Number,&#125;);module.exports = mongoose.model('Gadget', GadgetSchema); 接下来需要在数据库添加一个集合和一次测试数据，对应的集合名必须是复数，这里用gadgets. GraphQL 查询GrpahQL需要我们创建类型，可以将它类比为计算机指令一样。https://www.haoming.fun/images/graphql/gadgetType.js 1234567891011const graphql = require('graphql');const &#123; GraphQLObjectType, GraphQLString &#125; = graphql;const GadgetType = new GraphQLObjectType(&#123; name: 'Gadget', fields: () =&gt; (&#123; &#125;)&#125;);module.exports = GadgetType; 我们创建了一个graphql类型，然后再具体定义给定类型内部的属性。 1234567891011121314const graphql = require('graphql');const &#123; GraphQLObjectType, GraphQLString &#125; = graphql;const GadgetType = new GraphQLObjectType(&#123; name: 'Gadget', fields: () =&gt; (&#123; id: &#123; type: GraphQLString &#125;, name: &#123; type: GraphQLString &#125;, release_date: &#123; type: GraphQLString &#125;, by_company: &#123; type: GraphQLString &#125;, price: &#123; type: GraphQLString &#125; &#125;)&#125;);module.exports = GadgetType; 注意将GraphQLObjectType和GraphQLObjectType从graphql解构出来，它们是graphql的基本类型。创建GraphQL类型使得创建查询语句时会有类型提示。 最后一件事情是重构schema.js。我们想通过id查询gadget。向schema.js导入模型Gadget，从graphql导入``GraphQLSchema、GraphQLObjectType、GraphQLString，以及导入graphql类型gadgetGraphQLType`。 123const &#123; GraphQLSchema, GraphQLObjectType, GraphQLString&#125; = require('graphql');const gadgetGraphQLType = require('https://www.haoming.fun/images/gadgetType');const Gadget = require('.https://www.haoming.fun/images/models/gadget'); 接下来需要一个根查询，每个graphql查询都以花括号开头。 123456789101112const RootQuery = new GraphQLObjectType(&#123; name: 'RootQueryType', fields: &#123; gadget: &#123; type: gadgetGraphQLType, args: &#123; id: &#123; type: GraphQLString &#125;&#125;, resolve(parent, args) &#123; return Gadget.findById(args.id) &#125; &#125; &#125;&#125;) gadget查询里面有三个属性： type-查询的类型 args-提供给graphql查询的参数 resolve-查询完成后要做什么？这里是按照id返回gadget 最后导出schema： 123module.exports = new GraphQLSchema(&#123; query: RootQuery&#125;); 在浏览器地址栏输入 http://localhost:9000/graphql ，然后编写查询语句： 123456789&#123; gadget(id: \"5cc5109a41aedb25d85c211d\") &#123; name price by_company release_date id &#125;&#125; 最后的查询结果应该是这样： 参考https://www.cnblogs.com/sybboy/p/6418526.htmlhttps://www.cnblogs.com/haoliansheng/p/4390267.htmlhttps://www.cnblogs.com/damingge/p/6507605.htmlhttps://www.yiibai.com/mongodb/mongodb_create_database.htmlhttps://www.strilliant.com/2019/01/27/how-to-setup-a-powerful-api-with-graphql-koa-and-mongodb/","categories":[{"name":"前端","slug":"前端","permalink":"https://www.haoming.fun/categories/前端/"}],"tags":[{"name":"API","slug":"API","permalink":"https://www.haoming.fun/tags/API/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://www.haoming.fun/tags/GraphQL/"},{"name":"Koa","slug":"Koa","permalink":"https://www.haoming.fun/tags/Koa/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.haoming.fun/tags/MongoDB/"}],"author":"Peng Fang"},{"title":"IE下将Web中的SVG导出PNG图片","slug":"IE下将Web中的SVG导出PNG图片","date":"2019-04-29T12:15:00.000Z","updated":"2019-06-30T04:11:36.662Z","comments":true,"path":"2019/04/29/IE下将Web中的SVG导出PNG图片/","link":"","permalink":"https://www.haoming.fun/2019/04/29/IE下将Web中的SVG导出PNG图片/","excerpt":"","text":"目的本文的目的是介绍一种将Web中SVG元素导出成PNG图片的方法，并阐述如何通过修改插件源码做到兼容IE浏览器（IE10以及以上）。 前言图形一般分为两种：矢量图和栅格图。所谓栅格图就是由固定数量的正方形像素（简称“图元”）组成，每个像素填充一种颜色。JPG、PNG、GIF格式的数组图像都属于栅格图。栅格图有一个明显的特征，即缩放时会变得模糊，更确切地说，是像素化。这是由其渲染方式造成的。而矢量图不会被像素化，SVG可缩放矢量图形，是W3C XML的分支语言之一，用于标记可缩放的矢量图形，已经成为一项Web标准技术，IE8以上主流浏览器能够解析其提供的绘图指令。因为SVG可缩放的特性以及实现了DOM接口，我们会利用其提供的元素和接口编程绘制复杂的组合图形。目前我们有一个功能需求就是将Web中复杂的SVG图形导出成PNG这样的图片文件。我们在页面上绘制的SVG图形包含若干矩形、圆、线、文本、嵌入的svg图片等。 SVG图形导出PNG图片需要将D3.js绘制的图形导出并下载成为PNG图片文件，通过查阅资料发现saveSvgAsPng.js对嵌入图片的SVG图形和图形中设定的样式支持较好，在Chrome中能将Web的Svg图形导出Png图片成功。 安装使用saveSvgAspng安装1npm install save-svg-as-png 先决条件SaveSvgAsPng依赖JavaScript的promise，所以不支持标准Promise对象的浏览器需要有个polyfill（IE说你们都看我干嘛？！）。下面是在项目中安装和配置babel/polyfill，它提供完整ES2015+环境所需的polyfill(垫片)： 安装依赖 install --save @babel/polyfill```122. 在入口文件main.js引入依赖```import &apos;@babel/polyfill&apos; 修改babel.config.js 12345678910module.exports = &#123; presets: [ [ &apos;@vue/app&apos;, &#123; useBuiltIns: &apos;entry&apos; &#125; ] ],&#125; 修改 .browserslistrc 目标浏览器配置根据提供的目标浏览器的环境来，智能添加css前缀，js的polyfill垫片,来兼容旧版本浏览器。避免不必要的兼容代码，以提高代码的编译质量。 123&gt; 1%last 2 versionsnot ie &lt;= 9 使用为了保存png图片，在页面中包含saveSvgAsPng.js脚本，然后用一个SVG节点和一个文件名作为参数来调用saveSvgAsPng函数。示例代码： 12import &#123; svgAsDataUri, saveSvgAsPng &#125; from &apos;saveSvgAsPng&apos; // 导入方法saveSvgAsPng(document.getElementById(&quot;diagram&quot;), &quot;diagram.png&quot;) // 保存png图片 如果想获得SVG的dataURL，然后定义一个回调。我们可以将SVG节点，options，回调函数作为参数来调用svgAsDataUri方法，像这样： 1234567import canvg from &apos;canvg&apos;svgAsPngUri(document.querySelector(`#$&#123;id&#125; svg`), &#123; backgroundColor: &apos;#fff&apos;, canvg: canvg &#125;, (uri) =&gt; &#123; // 回调自定义处理逻辑 const imageName = &apos;pngFileName.png&apos; downloadImage(imageName, uri) // url下载成png图片 loading.close() // 关闭loading&#125;) 示例代码的选项说明如下： backgroundColor - 创建一个PNG采用设定的背景颜色，默认是透明的 canvg - 如果传入canvg参数，用来将SVG转为Canvas，以支持IE 其他参见插件README IE下saveSvgAsPng的兼容问题虽然saveSvgAsPng提供了canvg参数以兼容IE，实际经过IE11的测试发现：即便传入canvg参数，在插件调用canvas的toDataURL方法时仍然会抛出SecurityError异常。为了兼容IE，我们还要借助canvg插件，它是Canvas上SVG的解析器和渲染器，它获取SVG文件的URL或者文本，用JavaScript解析，并在Canvas元素上呈现结果。 源码分析通过分析saveSvgAsPng的源码得知它svgAsPngUri方法的执行有三个步骤： 将获取传入svg节点中的所有image元素，也就是内部嵌入的图片元素，通过在canvas上绘制改图形的办法来获取内联图片的dataURL，将其设置为图片href属性。 获取页面中的所有css样式，并将svg节点克隆一份，创建style标签，将所有的css样式代码插入到style标签内，将style标签插入到克隆节点的后面，将它们(HTML)一起作为src返回 按照以上步骤完成准备工作以后，将上面的src作为内容绘制到canvas上面，再调用canvas的toDataURL方法获得uri并返回给回调函数。这一步需要判断是否传入canvg参数，如果传入的话则调用canvg方法将src转换为canvas，以达到调用canvas.toDataURL()不会报错。解决IE下导出图片文件报错经过进一步分析得知，在上面第一步中获取内联图片的dataURL时在IE下会报错，那么解决办法是增加是否获取uri的参数，并作如下判断，如果需要获取uri参数（IE下不获取，也就是有设置canvg参数选项），才调用toDataURL方法。 解决导出图片无背景问题经过以上的处理，在IE下可以正常导出图片，但是导出的png没有背景颜色（呈黑色背景）。经过查询资料发现：利用canvas的toDataURL创建图像，如果图像类型支持透明（比如PNG），那么背景颜色则会是透明，否则是黑色。w3c的说明参考这里在上面第三步返回dataURL的时候，我们判断如果没有传入canvg参数，正常调用canvas的toDataURL方法，否则我们这样处理： 从canvas中得到ImageData 将globalCompositeOperation属性设置为destination-over. 这将会在当前存在的图形之下绘制新的图形 画一个整个canvas大小的rectangle，填充你想要的背景色 生成canvas的dataURL 清空整个canvas（包含背景） 拷贝原来的绘图数据到canvas 重置globalCompositeOperation为你开始想要的值 结语以上我们介绍了如何增加垫片使得ES6的API能在IE下兼容运行，以及修改saveSVGAsPng的源码来使得IE下能正常将svg元素导出为png图片。 参考文献 图说D3数据可视化利器从入门到进阶 Vue CLI 3 配置兼容IE10 saveSvgAsPng github canvg github canvas w3c Setting the background color when generating images from Canvas.toDataURL","categories":[{"name":"可视化","slug":"可视化","permalink":"https://www.haoming.fun/categories/可视化/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://www.haoming.fun/tags/源码分析/"}],"author":"Peng Fang"},{"title":"记一次crontab执行scp异常解决","slug":"记一次crontab执行scp异常解决","date":"2018-10-22T07:57:00.000Z","updated":"2019-06-30T04:11:36.670Z","comments":true,"path":"2018/10/22/记一次crontab执行scp异常解决/","link":"","permalink":"https://www.haoming.fun/2018/10/22/记一次crontab执行scp异常解决/","excerpt":"","text":"Python执行shell命令时的奇怪问题通过crontab命令，周期性执行Python脚本。简单来说，用Python脚本实现的是将一些指定目录下的文件scp到远程主机的某个目录下。奇怪的是，该scp命令在命令行中执行没问题，通过上述的方式执行就不能成功，日志记录的是“scp传输失败” 问题具体一些我们通过crontab命令，可以在固定的间隔时间执行指定的系统指令或shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。任务定义格式：.—————- minute (0 - 59)| .————- hour (0 - 23)| | .———- day of month (1 - 31)| | | .——- month (1 - 12) OR jan,feb,mar,apr …| | | | .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat| | | | |* * * * * user-name command to be executed 例如：每五分钟执行一次验证脚本*/5 * * * * python /data/mgxy/scripts/verify.py MGSM ZL BLXY crontab有个用户域，也就是说当前用户可以设置自己的crontab命令，设置成功可以通过crontab -l命令查看当前用户设置的任务，不能看到其他用户设置的任务。通过crontab -e命令来编辑当前用户的crontab，也就是在执行命令后的编辑器中输入上面的验证脚本，然后保存后会将编辑的crontab文件提交给cron进程执行。 “verify.py”中执行scp命令是采用免密方式，免密登录是通过sshpass来实现的，用-p参数指定明文密码： 1sshpass -p loginPassord scp -oUserKnownHostsFile=/dev/null -oStrictHostKeyChecking=no /sourcePath/sourceFile username@targetIp:/targetPath/ 每次ssh访问过的计算机公钥都会记录在~/.ssh/known_hosts，方便下次访问该计算机时核对。记得首次ssh登录一个主机的时候，命令行都会提示：“RSA key fingerprint is *****. Are you sure you want to continue connecting (yes/no)?”，如果回复yes,ssh客户端就会继续登录，将主机key存在文件~/.ssh/known_hosts中，如果回复no，连接就会中断。 scp 可以通过-o来指定ssh选项。StrictHostKeyChecking=no，该选项会禁用掉上面的交互提示，自动将主机key添加到文件~/.ssh/known_hosts中。如果我们确认远程主机密码更改时合法的，我们可以跳过主机密钥的校验，通过设置UserKnownHostsFile=/dev/null将密钥发送到一个null的known_hosts文件中。 一些尝试 将实际执行的命令，放到命令行中执行结果：能够正常执行。猜想： 会不会命令行用户和执行脚本的用户不同导致？实际这两个都同一个用户。 会不会是Python脚本的问题？python脚本在另一台机器运行正常。 不用crontab命令，将Python脚本在命令行执行结果：脚本正常执行。说明是crontab执行任务的问题。涛哥指导：crontab的用户比较特殊，尽可能使用绝对路径 crontab命令中将python改为绝对路径结果：*/5 * * * * /usr/bin/python xxx问题依然存在设想：会不会是python脚本中执行的scp命令也要换成绝对路径 将python中执行的命令换成绝对路径结果：成功！能够正常拷贝文件。解决办法想想修改python中的命令为绝对路径，这不是通用办法。有没有通用点的办法，不用修改python脚本呢。然后我谷歌了一下，发现/etc/contab中可以设置环境变量，如：1PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin 很多命令就在以上的$PATH中啊。想想该怎么设置环境变量呢，在哪里设置呢？他们以前会不会也有这样的问题呢？是怎么解决的呢？所以我去线上环境crontab -l看了一下，发现类似的设置： 1*/10 * * * * . /etc/profile;/bin/sh xxx.sh 然后百度了一下，有这么一段描述(来自博客)： 当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 最后，我在crontab命令按照以上配置（crontab命令设置绝对路径是好习惯）： 1*/5 * * * * . /etc/profile;/usr/bin/python xxx.py xxx 并在/etc/profile中设置环境变量：PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$PATHbingo, 成功！ 参考资料https://www.cnblogs.com/chenlaichao/p/7727554.htmlhttps://www.shellhacks.com/disable-ssh-host-key-checking/https://stackoverflow.com/questions/2388087/how-to-get-cron-to-call-in-the-correct-pathshttps://www.cnblogs.com/intval/p/5763929.html","categories":[{"name":"运维","slug":"运维","permalink":"https://www.haoming.fun/categories/运维/"}],"tags":[{"name":"异常解决","slug":"异常解决","permalink":"https://www.haoming.fun/tags/异常解决/"}],"author":"Peng Fang"},{"title":"Hive2Hbase入库逻辑","slug":"Hive2Hbase入库逻辑","date":"2018-09-19T12:21:00.000Z","updated":"2019-06-30T04:11:36.661Z","comments":true,"path":"2018/09/19/Hive2Hbase入库逻辑/","link":"","permalink":"https://www.haoming.fun/2018/09/19/Hive2Hbase入库逻辑/","excerpt":"","text":"Parquet格式hdfs文件根据规则生成HFile 创建和设置habse参数 清楚输出目录下HFile文件 创建mapreduce job 设置mapper：job.setJarByClass, job.setMapperClass, job.setMapOutputKeyClass, job.setMapOutputValueClass； 设置Parquet格式的解析器； 设置合并方法：job.setCombinerClass(Combiner.class)，Combiner继承自Reducer，reduce方法用于数据去重； 设置写HFile的reduce：HFileOutputFormat2.configureIncrementalLoad, HFileOutputFormat2.setOutputPath; job.setReducerClass(KeyValueSortReducer.class)：设置reducer class, 如KeyValue、Put、Text，以正确地对输入值进行排序。configureIncrementalLoad中会根据前面设置的MapOutputKeyClass来设置ReducerClass，见下面的源代码。 提交job，轮询等到其完成，退出程序执行。第7步configureIncrementalLoad源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void configureIncrementalLoad(Job job, HTableDescriptor tableDescriptor, RegionLocator regionLocator, Class&lt;? extends OutputFormat&lt;?, ?&gt;&gt; cls) throws IOException, UnsupportedEncodingException &#123; Configuration conf = job.getConfiguration(); job.setOutputKeyClass(ImmutableBytesWritable.class); job.setOutputValueClass(KeyValue.class); job.setOutputFormatClass(cls); // Based on the configured map output class, set the correct reducer to properly // sort the incoming values. // TODO it would be nice to pick one or the other of these formats. if (KeyValue.class.equals(job.getMapOutputValueClass())) &#123; job.setReducerClass(KeyValueSortReducer.class); &#125; else if (Put.class.equals(job.getMapOutputValueClass())) &#123; job.setReducerClass(PutSortReducer.class); &#125; else if (Text.class.equals(job.getMapOutputValueClass())) &#123; job.setReducerClass(TextSortReducer.class); &#125; else &#123; LOG.warn(\"Unknown map output value type:\" + job.getMapOutputValueClass()); &#125; conf.setStrings(\"io.serializations\", conf.get(\"io.serializations\"), MutationSerialization.class.getName(), ResultSerialization.class.getName(), KeyValueSerialization.class.getName()); // Use table's region boundaries for TOP split points. LOG.info(\"Looking up current regions for table \" + tableDescriptor.getTableName()); List&lt;ImmutableBytesWritable&gt; startKeys = getRegionStartKeys(regionLocator); LOG.info(\"Configuring \" + startKeys.size() + \" reduce partitions \" + \"to match current region count\"); job.setNumReduceTasks(startKeys.size()); configurePartitioner(job, startKeys); // Set compression algorithms based on column families configureCompression(conf, tableDescriptor); configureBloomType(tableDescriptor, conf); configureBlockSize(tableDescriptor, conf); configureDataBlockEncoding(tableDescriptor, conf); TableMapReduceUtil.addDependencyJars(job); TableMapReduceUtil.initCredentials(job); LOG.info(\"Incremental table \" + regionLocator.getName() + \" output configured.\");&#125; 加载HFile到HBase表 加载配置文件hbase-site.xml 读取hdfs配置文件hbase-hdfs-site.xml，然后配置hbase-site.xml的一些参数：● 配置dfs.ha.namenodes.[nameservice ID]，让DataNode知道每个集群的所有NameNode● 配置dfs.client.failover.proxy.provider.[nameservice ID]，该参数定义HDFS客户端用来和活动的namenode节目联系的java类。配置的java类是用来给HDFS客户端判断哪个namenode节点是活动的，当前是哪个namenode处理客户端的请求。● 配置dfs.namenode.rpc-address.[nameservice ID].[name node ID] ， 即配置每个namenode监听的RPC地址。● 配置dfs.nameservices–自定义的HDFS服务名，在NameNode节点的集群中，对HDFS集群访问的入口是NameNode所在的服务器。但是在两个NameNode节点的HA集群中，无法配置单一服务器入口。所以需要指定一个逻辑上的服务名，这个服务名是自定义的。当外界访问HDFS集群时，入口就变为这个服务。用户不必关心当前具体是哪台服务器在提供服务（Active状态），只要访问这个服务就可以了。● 配置mapreduce.job.hdfs-servers.token-renewal.exclude为名字服务id的数组，ResourceManager为应用程序更新委托令牌。只有当令牌的更新者是非空字符串时，此行为才被更新为令牌。MapReduce作业可以指示ResourceManager通过指定具有配置mapreduce.job.hdfs-servers.token-renewal.exclude = ，，..，的主机来跳过从某些主机获取的令牌的更新。 向HBASE表加载数据123HTable table = new HTable(conf, tableB);LoadIncrementalHFile loader = new LoadIncrementalHFile(conf);loader.doBulkLoad(new Path(outputPathOnHbase), table); // outputPathOnHbase是HBASE的hdfs上HFile的路径 API解释如下： 1234567891011121314Class LoadIncrementalHFiles：Tool to load the output of HFileOutputFormat into an existing table.public void doBulkLoad(org.apache.hadoop.fs.Path hfofDir, Admin admin, Table table, RegionLocator regionLocator) throws TableNotFoundException, IOExceptionPerform a bulk load of the given directory into the given pre-existing table. This method is not threadsafe.Parameters:hfofDir - the directory that was provided as the output path of a job using HFileOutputFormattable - the table to load intoThrows:TableNotFoundException - if table does not yet existIOException 参考：https://blog.csdn.net/book_mmicky/article/details/25714339https://segmentfault.com/a/1190000007239743http://www.searchdoc.cn/hadoop/hadoop.apache.org/docs/r3.0.0-alpha1/hadoop-project-dist/hadoop-common/release/3.0.0-alpha1/RELEASENOTES.3.0.0-alpha1.com.coder114.cn.htmlhttps://www.programcreek.com/java-api-examples/index.php?api=org.apache.hadoop.hbase.mapreduce.KeyValueSortReducer","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.haoming.fun/categories/大数据/"}],"tags":[{"name":"数据入库","slug":"数据入库","permalink":"https://www.haoming.fun/tags/数据入库/"},{"name":"Hbase","slug":"Hbase","permalink":"https://www.haoming.fun/tags/Hbase/"}],"author":"Peng Fang"},{"title":"2018-2019技术书单","slug":"2018-2019技术书单","date":"2018-09-18T12:42:00.000Z","updated":"2019-06-30T04:11:36.654Z","comments":true,"path":"2018/09/18/2018-2019技术书单/","link":"","permalink":"https://www.haoming.fun/2018/09/18/2018-2019技术书单/","excerpt":"","text":"2018到2019书单 —— 计算机系统化学习，大神进化之路 数学具体数学图论及其应用矩阵理论线性代数与空间解析几何最优化理论与方法组合数学深入浅出统计学 机器学习统计学习方法机器学习(西瓜书)机器学习(经典) 大数据Hadoop权威指南 编程语言css世界Java核心技术(卷一)深入理解Java虚拟机webkit技术内幕高性能JavaScript 数据结构及算法算法导论算法：C语言实现算法心得数据结构与算法分析——C语言描述 网络TCP/IP详解计算机网络自顶向下方法 操作系统深入理解计算机系统Linux内核设计与实现(第三版)Linux程序设计实践Unix操作系统设计老码识途 数据库数据库系统概论MySQL DBA修炼之道高性能MySQL","categories":[{"name":"基础科学","slug":"基础科学","permalink":"https://www.haoming.fun/categories/基础科学/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://www.haoming.fun/tags/书单/"}],"author":"Peng Fang"},{"title":"怎样更有竞争力","slug":"怎样更有竞争力","date":"2018-09-18T12:34:00.000Z","updated":"2019-06-30T04:11:36.669Z","comments":true,"path":"2018/09/18/怎样更有竞争力/","link":"","permalink":"https://www.haoming.fun/2018/09/18/怎样更有竞争力/","excerpt":"","text":"做选择时选择难的，大家认为难的往往有竞争力 只有思考过总结出来记录下来的才是自己的 不在于愿望有多强烈，而在于每天达成一个个小目标 建立自己的个人品牌和影响力 凡事主动，主动思考，主动询问，主动了解 搞技术最难的不是怎么用它，而是为什么用它，它是怎么实现的，实现用到了哪些技术，基于什么样的原理 研究一门技术思考的是它的核心 大数据的核心是mr.hdfs 后端的核心是框架源码和jvm 前端的核心是框架源码，组件源码和编译原理，运行时环境 机器学习核心是神经网络，矩阵理论，概率统计，优化 系统性学习，建立知识框架 写PPT的能力，做汇报的能力(写和讲) 学习基础科学计划：操作系统、计算机网络、编译原理、算法与数据结构","categories":[{"name":"感悟","slug":"感悟","permalink":"https://www.haoming.fun/categories/感悟/"}],"tags":[{"name":"竞争力","slug":"竞争力","permalink":"https://www.haoming.fun/tags/竞争力/"}],"author":"Peng Fang"},{"title":"webcola介绍","slug":"webcola介绍","date":"2018-09-12T12:18:00.000Z","updated":"2019-06-30T04:11:36.665Z","comments":true,"path":"2018/09/12/webcola介绍/","link":"","permalink":"https://www.haoming.fun/2018/09/12/webcola介绍/","excerpt":"","text":"cola.js是一个开源的JavaScript库，使用基于约束的优化技术组织HTML5文档和图表。它可以和D3.js、SVG.js以及Cytoscape.js类似的很好配合。核心布局是基于libcola的C++库重写的。它也适配于d3.js，允许你使用cola作为D3力布局的一个核心替代。不同于D3力布局，通过一个简单的退火策略使其布局收敛到局部最优，因此与D3力布局相比： Cola实现更高质量的布局 在交互式应用程序中更稳定（没有”抖动”） 它允许用户指定约束，例如对齐和分组 它能自动生成约束来 避免节点重叠 为有向图提供流布局 对于非常大的图，它可能不太好扩展然而，图上节点少于100个的情况下工作得很好，见Unix家族树 注意，虽然使用D3力布局，为了获得合理的节点分离，你可能要必须处理”charge”这样的参数。cola在最终布局中指定的链接距离方面做得更好。这是因为cola直接试着最小化理想链接距离和图中实际链接距离中的方差。换句话说，仅仅根据节点大小设置合理的链接距离。 为了了解一些可选的参数，我们可以像这样开始布局： 1234567d3cola .nodes(graph.nodes) .links(graph.links) .constraints(graph.constraints) .symmetricDiffLinkLengths(5) .avoidOverlaps(true) .start(10,15,20); 我们像D3力布局一样指定节点和链接。constraints是一个新参数，它是一个包含约束的数组，像这样： 1&#123;\"axis\":\"y\", \"left\":0, \"right\":1, \"gap\":25&#125; 这就是说，graph.nodes[0]的中心必须与graph.nodes[1]的中心距离25个像素以上。更精确地讲，约束要求满足这样的不等式： 1graph.nodes[0].y + gap &lt;= graph.nodes[1].y 设置avoidOverlaps(true)，在布局进行时动态生成约束，以防止节点的边框彼此重叠。symmetricDiffLinkLengths(5) ，使用5作为基本长度，计算每个链路上的理想长度，为的是在高度节点周围创造额外的空间。或者，你也可以将自己的函数f传递给linkDistance，返回每个链接的特定长度。start()方法现在包含多达三个整数参数。在上面的例子中，start最初将应用10次没有约束的布局迭代，15次仅具有结构（用户指定的）约束的迭代，以及20次包含反重叠约束的具有所有约束的布局迭代。指定这样一个计划是有用的，使得图形在其被严格约束前展开。 在cytoscape.js中使用cola.jsCytoscape.js通过扩展已经完全支持Cola.js.Cytoscape.js拥有一个完全的图理论模型，高度可定制的样式和布局。Cola.js在Cytoscape.js中运行只需要一行代码： 123cy.layout(&#123; name: 'cola' /* and maybe some other options */ &#125;); 翻译自https://ialab.it.monash.edu/webcola","categories":[{"name":"可视化","slug":"可视化","permalink":"https://www.haoming.fun/categories/可视化/"}],"tags":[{"name":"webcola","slug":"webcola","permalink":"https://www.haoming.fun/tags/webcola/"}],"author":"Peng Fang"},{"title":"Hbase基础知识点梳理","slug":"Hbase基础知识点梳理","date":"2018-09-10T12:09:00.000Z","updated":"2019-06-30T04:11:36.661Z","comments":true,"path":"2018/09/10/Hbase基础知识点梳理/","link":"","permalink":"https://www.haoming.fun/2018/09/10/Hbase基础知识点梳理/","excerpt":"","text":"整体架构从HBase部署架构来说，HBase有两种服务器：Master服务器和RegionServer服务器。一般一个HBase集群有一个Master服务器和几个RegionServer服务器。Master服务器负责维护表结构信息，Master挂到后还能查询数据，只是不能新建表或修改表。实际的数据存储在RegionServer服务器上，RegionServer保存的表数据是直接存储在Hadoop的HDFS上。客户端获取数据是由客户端直接连接RegionServer服务器。RegionServer非常依赖ZooKeeper服务。ZooKeeper在HBase中扮演管家角色，管理了HBase所有RegionServer的信息，包括具体的数据段存放在哪个RegionServer上。客户端每次与HBase连接，先与ZooKeeper通信，查询出需要与哪个RegionServer连接，然后再连接RegionServer。整体架构图如下： Region是什么Region就是一段数据的集合。HBase中的表一般拥有一个到多个Region。Region有几个特性： Region不能跨服务器 当数据量大的时候，HBase会拆分region HBase负载均衡的时候，可能会把Region从一个RegionServer移动到另一个上 Region是基于HDFS的，所有数据存取操作都是调用了HDFS的客户端接口来实现的 RegionServer是什么RegionServer是存放Region的容器，直观来说就是服务器上的一个服务。一般来说，一个服务器只会安装一个RegionServer服务。当客户端从ZooKeeper获取RegionServer的地址后，它会直接从RegionServer获取数据，插入、删除等数据操作也是经过它。 Master是什么HBase中Master角色不像领导，更像是打杂的。Master负责各种协调工作，比如建表、删表、移动Region、合并等操作。它们的共性就是需要跨RegionServer，由哪个RegionServer来执行都不合适，所以HBase将这些操作放到Master上。这种结构大大降低了集群对Master的依赖，即使Master宕机了，也不影响数据操作。 存储架构HBase最基本的存储单位是列。行跟行的列可以完全不一样，行与行的数据，甚至同一行的列可以存储在不同的机器上。若干个列被归类为一个列族。存储架构图如下： 行键是什么rowkey是由用户指定的一串不重复字符串。rowkey是决定row存储顺序的唯一凭证。HBase是根据字典排序的。比如：row-1, row-11, row-2。 列族是什么建表的时候不需要指定列，但需要确定列族，这就是说一个表有几个列族是一开始确定好的。此外，表的很多属性，比如过期时间、数据块缓存以及是否压缩等都是定义在列族上，而不是定义在表上或者列上。同一个表里的不同列族可以有完全不同的属性配置，但是同一个列族内的所有列都会有相同属性。列名称规范是列族：列名，如brother:age。列族的意义是：HBase会把相同的列族尽量放在同一台机器上，所以说，如果想让某一个列被放在一起，就给他们定义相同的列族。一个表设置多少个列族合适？官方的建议是：越少越好，因为Hbase虽然是分布式数据库，但是数据在同一台机器上仍然会加速数据的查询过程。所以请根据实际需要制定列族，列族太多会极大降低数据库性能。 单元格是什么一个列上可以存储多个版本的值，多个版本的值被存储在多个单元格里面，多个版本之间用版本号（Version）来区分。所以唯一确定一条结果的表达式应该是行键：列族：列：版本号(rowkey:column family:column:version)。不过版本号是可以省略的，如果不写版本号，HBase默认获取最后一个版本的数据并返回。每个列或者单元格的值都被赋予一个时间戳，这个时间戳默认是由系统指定的，也可以由用户显示指定。 Region跟行的关系一个Region就是多个行的集合。在Region中行的排序按照行键（rowkey）字典排序。表结构图如下： 传统数据库insert语句可以把整行的数据一次性写在行语句里面，而在HBase里面如果一行有10列，那么存储一行的数据得写10行的语句。存储语句必须精确写出数据被存储到哪个单元格，根据表：列族：行：列来定义。行的概念被弱化到只有一个抽象的存在，rowkey是其唯一的体现。 讲讲ZooKeeperZooKeeper不知Hadoop的HA模式（HA的作用是保证一个namenode挂掉的时候，另外一个namenode能立即启动将其代替，这样就不会发生单点故障的问题）用到，HBase也会用到。ZooKeeper是Apache旗下的一个开源项目，它是一个开源的分布式应用程序协调服务，它可以为分布式应用提供一致性服务，提供的功能包括：配置服务、域名服务、分布式同步、组服务等。ZooKeeper负责维护HBase的所有节点，如果ZooKeeper宕掉了，集群的一个节点都连不上。ZooKeeper最大的功能之一就是知道某个节点是否宕机了，那么ZooKeeper是如何知道某个节点宕机的呢？答案是，每一个机器在ZooKeeper中都有一个会话（Session），如果某个机器宕机了，这个会话（Session）就会过期，与此同时，ZooKeeper就知道该节点已宕机。多少个节点最好？节点越多容灾能力就越强，不过节点数最好是奇数个，这样有利于仲裁。ZooKeeper的容灾机制：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。如果有5个节点，有2个集群宕掉，集群依然可以运行。这是我们称该集群容灾能力是2。目前节点数是6，只要有3个机器宕掉那么集群就宕掉了，此时的容灾能力仍是2。ZooKeeper应该存储在一个独立的磁盘上，避免当磁盘出现IO问题的时候ZooKeeper被波及。 HBase常用命令 list查看数据库中有哪些表 describe查看表属性 create &amp; altercreate ‘test’, ‘cf’ # 建立一个叫test的表，这个表有一个列族叫cfalter ‘test’, ‘cf2’ # 新增一个列族在生产环境更改表之前，最好先停用（disable）这个表。因为对列族的所有操作都会同步到所有拥有这个表的RegionServer上。当有很多客户端都在连着的时候，直接新增一个列族对性能的影响较大。 putput ‘test’, ‘row1’, ‘cf:name’, ‘jack’意思是往test表插入一个单元格，这个单元格的rowkey为row1，也就是说它是属于row1这个行中的一个列。该单元格的列族是cf，单元格的列名是name，数据值是jack。 关于时间戳每一个单元格可以存储多个版本的值。它用timestamp来存储该条记录的时间戳，这个时间戳就用来当版本号使用。timestamp虽然是时间的标定，其实可以输入任意的数字，比如1，2，3等。当用scan命令的时候HBase会显示拥有最大（最新）的timestamp的数据版本。创建表时默认版本是1，也就是说在一个单元格插入多个版本的数据的时候，HBase只会保留最后一个版本。能够在scan操作的结果集看到多个版本的前提是建表时设定的VERSIONS参数要大于1，这样表才能保存设定VERSIONS数个历史记录。修改版本数的命令：alter ‘test’, {NAME=&gt;’cf’,VERSION=&gt;5} # NAME为要修改的列族的名称，后面跟要修改的属性，我们修改VERSION为5put ‘test’,’row2’,’cf:name’,’ted’put ‘test’,’row2’,’cf:name’,’billy’,2222222222222 #自定义时间戳晚于当前时间scan ‘test’ # 只能看到时间戳最大的那条结果get ‘test’,’row2’,{COLUMN=&gt;’cf:name’, VERSIONS=&gt;3} #查询所有版本的数据 scanscan ‘表名’，这样输入的话，会从第一条数据开始把所有数据全部显示一遍。在HBase中我们用起始行（STARTROW）和结束行（ENDROW）来限制记录的条数。scan ‘test’,{STARTROW=&gt;’row3’} # 显示所有rowkey大于等于row3的记录scan ‘test’,{ENDROW=&gt;’row4’} # 小于row4(不包括)的记录两个参数一起用就是显示 &gt;= STARTROW 并且 &lt;ENDROW中的那段数据scan ‘表名’,{COLUMNS=&gt;[‘列1’,’列2’,…]} # 只遍历指定列scan ‘表名’,{STARTROW=&gt;’起始行键’,ENDROW=&gt;’结束行键’} # 指定行键范围scan ‘表名’,{LIMIT=&gt;行数量} # 指定最大返回行数量scan ‘表名’,{TIMERANGE=&gt;[最小时间戳,最大时间戳]} # 找出单元格的历史版本数据scan ’表名’,{VERSION=&gt;’版本数’} # 指定版本数，显示单元格多个版本值scan ‘表名’,{FILTER=&gt;’过滤器’} # scan ‘table1’ { FILTER=&gt; “PrefixFilter(‘row1’)” } getscan可以查询表的多条数据，get只能查询一个单元格的记录。在数据量大的时候，get的查询熟读远远高于scan。get ‘test’,’row7’,’cf:name’ # 查询某个单元格的记录get ‘test’,’row7’,{COLUMN=&gt;’cf:name’,VERSION=&gt;5} # 把查询版本数设定为5scan ‘test’,{VERSION=&gt;5} # scan跟上VERSIONS参数也可以查询出多个版本的数据 count计算表的行数 deletedelete ‘表名’,’行键’,’列名’delete ‘表名’,’行键’,’列名’,时间戳 split拆分(split)指定的Region，除了可以等到Region大小达到阈值后触发自动拆分机制来拆分Region，还可以手动拆分指定的Region，如 split ‘region名’。 merge_region合并（merge）两个Region和一个Region compact调用指定表的所有Region或者指定列族的所有Region的合并（compact）机制。通过compact机制可以合并该Region或者Region的列族下的所有HFile（StoreFile），以此来提高读取性能。compact跟合并（merge）并不一样。merge操作是合并2个Region为1个，而compact操作更新的单元StoreFile，一个Region可以含有一个或多个StoreFile，compact操作的目的在于减少StoreFile的数量以增加读取性能。 快照快照就是表在某个时刻的结构和数据。可以使用快照来将表恢复到某个时刻的结构和数据，恢复过程很快，往往只有数秒。HBase是怎么做到的呢？其实快照并不直接复制数据，而是保持一份文件列表，通过修改表所链接的文件夹来改变表的数据，好处是：速度极快；不额外占用磁盘空间。HBase要求在恢复快照之前必须要先停用（disable）需要恢复的表，才能恢复快照，避免不必要的麻烦。先停用，然后恢复快照，再启用（enable）。通过snapshot命令可以创建指定表的快照。disable ‘mgdmcredit:userblack_temp’snapshot ‘mgdmcredit:userblack_temp’, ‘userblack_temp_snapshot’disable ‘mgdmcredit:userblack’drop ‘mgdmcredit:userblack’clone_snapshot ‘userblack_temp_snapshot’ ‘mgdmcredit:userblack’enable ‘mgdmcredit:userblack_temp’truncate ‘mgdmcredit:userblack_temp’delete_snapshot ‘userblack_temp_snapshot’clone_snapshot使用快照的数据创建一张新表，创建的过程很快，因为使用的方式不是复制数据，并且修改新表的数据不会影响旧表的数据。 客户端API在HBase中有一个理念：所有数据皆为bytes。在HBase中数据最终都会被序列化为bytes[]保存。 put方法123456try(Connection connection = ConnectionFactory.createConnection(config)) &#123; Table table = connection.getTable(TableName.valueOf(\"myTable\")); Put put = new Put(Bytes.toBytes(\"row1\")); put.addColumn(Bytes.toBytes(\"mycf\"), Bytes.toBytes(\"name\"), Bytes.toBytes(\"ted\")); table.put(put);&#125; 新增和修改类型，修改就是往同一个rowkey再执行一次put操作，将之前的数据覆盖掉。JDK的try-with-resources，上面例子中看到try(…){….}，{….}中的代码执行完毕会自动释放资源，不需要手动写finally语句块了。 get方法get不像scan，并不能用多种条件去查找，只能用行键去查找。不过HBase一行有可能很大，我们可以通过设置参数让get只获取其中一部分的数据，以提高查询性能。 123456789Get get = new Get(Bytes.toBytes(\"row1\"));get.setMaxVersions(10);Result result = table.get(get);List&lt;Cell&gt; cells = result.getColumnCells(Bytes.toBytes(\"mycf\"), Bytes.toBytes(\"name\"));for(Cell c: cells) &#123; // 用CellUtil.cloneValue来获取数据而不是getValue bytes[] cValue = CellUtil.cloneValue(c); System.out.println(Bytes.toString(cValue));&#125; 用CellUtil.cloneValue来获取数据而不用getValue的原因：根据目前getValue的实现代码，每次调用它都会获取整个Cell的数组备份，比较消耗性能。所以当需要获取Cell中的值时，请使用CellUtil.cloneValue方法。 Scan扫描查询多条数据我们会想到用scan。默认的scan是从表头一直遍历到表尾，非常耗时好性能，实际工作中，我们至少要定义一下遍历的起始rowkey，如果知道遍历的结束rowkey就好了。举个栗子：1234Scan scan = new Scan(Bytes.toBytes(\"row1\"));ResultScanner rs = table.getScanner(scan);...rs.close(); // 使用完了关闭 这里为什么是getScanner()而不是scan()？因为Table通过传入scan之后返回的结果扫描器（ResultScanner）并不是实际的查询结果。获取结果扫描器（ResultScanner）的时候并没有实际去查询数据。真正要获取数据的时候要打开扫描器，然后遍历它，这个时候才真正地查询了数据。这个ResultScanner就像关系型数据库中的ResultSet一样是需要持续占用资源的，所以用完后务必记得关闭它。 缓存HBase在扫描的时候已经默认开启了缓存。具体来讲，每一次的next()操作都会产生一次完整的RPC请求，而这次RPC请求可以获取多少数据是通过hbase-site.xml中的hbase.client.scanner.caching参数配置的。比如配置为1，遍历了10个结果就会发送10次请求。可以在表的层面修改缓存条数，也可以在扫描层面去修改。表的层面修改时通过hbase-site.xml中的配置: 1234&lt;property&gt;&lt;name&gt;hbase.client.scanner.caching&lt;/name&gt;&lt;value&gt;1000&lt;/value&gt;&lt;/property&gt; hbase.client.scanner.caching的默认配置是100.在扫描层面修改缓存可以使用Scan.setCaching(int caching)方法设置一次next获取的数据条数，这个配置的优先级比配置文件内的hbase.client.scanner.caching高。 HBase二层查询架构从0.96版本之后三层查询架构被改成了二层查询架构。直接把.META.表所在的RegionServer信息存储到zk中的/hbase/meta-region-server去了。上图可以总结成以下流程： 客户端先通过ZooKeeper的/hbase/meta-region-server节点查询到哪台RegionServer上有hbase:meta表。 客户端连接含有hbase:meta表的RegionServer。hbase:meta表存储了所有Region的行键范围信息，通过这个表可以查询出你要存放的rowkey属于哪个Region的范围里面，以及这个Region又属于哪个RegionServer。 获取这些信息后，客户端就可以直连其中一台用于你要存取的rowkey的RegionServer，并直接对其操作。 客户端会把meta信息缓存起来，下次操作就不需要进行以上加载habse:meta的步骤了。 过滤器过滤器就是在Get或Scan的时候过滤结果用的，可以把他看成SQL中的where语句。HBase中过滤器被用户创建出来以后会被序列化我可以网络传输的格式，然后被分发到各个RegionServer。在RegionServer中Filter被还原出来。这样在Scan的遍历过程中，不满足过滤条件的结果将不会被返回客户端。 前缀过滤器这种过滤器可以根据行键的前缀匹配同样是这个前缀的行。运用它能提高查询性能，因为前缀过滤器在遇到扫描的行键的前缀大于所指定的前缀时，立即停止扫描。就算用了前缀过滤器也依然要结合上STARTROW使用，否则scan还是会从第一条记录开始扫描，浪费了大量的性能。当我们用Scan扫描数据的时候，如果使用STOPROW来指定终止行，结果集中并不会包含终止行。如果想在结果中包含终止行可以有两种方式：（1）在终止行的rowkey上增加一个字节的数据，然后把增加一个字节的rowkey作为STOPROW（2）使用包含结尾过滤器（InclusiveStopFilter） Region的拆分通过查询hbase:meta我们可以形象地看到，一个Region就是一个表的一段rowkey的数据集合。当Region太大的时候HBase会拆分它。为什么要拆分Region？因为当某个Region太大的时候读取效率太低了。我们可以想想为什么从MySQL、Oracle转移到NoSQL来？最根本的原因就是这些关系型数据库把数据放到一个地方，而当数据量增大到上亿的时候同一个磁盘已经无法应付这些数据的读取了，因为遍历一遍数据的时间实在太长了。用NoSQL的理由就是其能把大数据分拆到不同的机器上，然后像查询一个完整的数据一样查询他们。当Region太大的时候，一样会遇到跟传统数据库一样的问题，所以要拆分Region。 IncreasingToUpperBounRegionSplitPolicy策略（默认）计算公式：Math.min(tableRegionsCount^3 * initialSize, defaultRegionMaxFileSzie) tableRegionsCount：表在所有RegionServer上拥有的Region数量总和 initialSize：如果定义了hbase.increasing.policy.initial.size，则使用这个数值，否则，就使用memstore的刷写大小的2倍，即hbase.hregion.memstore.flush.size *2 defaultRegionMaxFileSzie：ConstantSizeRegionSplitPolicy所用到的hbase.hregion.max(一般是10G) 一开始可以先定义拆分点，但是当书记开始工作起来后会出现热点不均的情况，所以推荐的方法是： 用预拆分导入初始数据 然后用自动拆分来让HBase自动管理RegionRegion的拆分对性能的影响还是很大的，默认的策略已经适用于大多数情况。可以尝试哪种策略最好。 Region的合并Region的合并（merge）并不是为了性能考虑，更多地出于维护的目的。啥时候才会用到合并呢？比如删了大量的数据，每个Region都变小了，这个时候分成这么多个Region就有点浪费，可以把Region合并起来。通过Merge类来合并叫冷合并，就是要把HMaster和所有的HRegionServer全部停掉，再执行才可以；通过online_merge命令叫做热合并 HFile的合并除了Region会合并和拆分，在Region中的单个Store中也会发生合并（compaction）。HFile为什么要合并？但凡存储在磁盘上的东西都涉及到一个操作：寻址。传统硬盘是磁头的移动寻址，是一个很慢的动作。当HFile一多，每次读取数据的时候寻址动作就多了，效率就降低了。所以我们要适当减少碎片文件，进而需要合并操作。HFile的合并操作就是在一个store里面找到需要合并的HFile，把他们合并起来，再把之前的碎文件移除。 0.96版本之后的合并算法待合并文件挑选条件该文件 &lt; （所有文件大小总和 - 该文件大小）* 比例因子如果该文件大小小于最小合并大小(minCompactSize)，直接进入待合并列表。最小合并大小配置项：hbase.hstore.compaction.min.size，如果没有设定该项，则使用hbase.hregion.memstore.flush.size. 以组合作为计算单元新的算法不再按文件为单元进行比较了，而是挑出多个文件组合。挑选组合的条件：被挑选的文件必须能通过以上提到的筛选条件，并且组合内含有的文件数必须大于hbase.hstore.compaction.min，小于hbase.hstore.compaction.max.挑选完组合后，比较哪个文件组合包含的文件更多，则合并哪个组合。如果出现平局，就挑选哪个文件尺寸总和更少的组合。 调整HFile合并策略，让HFile的数量尽量减小，以减少每次Scan的跨HFile的次数，但同时又要保证该合并策略适用于场景，并且不用太频繁。 读取性能优化性能有两方面的提高空间： 调整对于API的用法 调整系统配置 参考《Mysql不睡觉书》","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.haoming.fun/categories/大数据/"}],"tags":[{"name":"Hbase","slug":"Hbase","permalink":"https://www.haoming.fun/tags/Hbase/"}],"author":"Peng Fang"},{"title":"D3.js数据可视化实践（精简）","slug":"D3-js数据可视化实践（精简）","date":"2018-07-01T11:03:00.000Z","updated":"2019-06-30T04:11:36.657Z","comments":true,"path":"2018/07/01/D3-js数据可视化实践（精简）/","link":"","permalink":"https://www.haoming.fun/2018/07/01/D3-js数据可视化实践（精简）/","excerpt":"","text":"D3数据可视化实践 方鹏 2018/07/05 前言在我们的APP上线后，经过数据分析，实时获取反映使用情况的活跃用户数；活跃数可分为总的日活或月活，分APP的日活或月活，分APP分省的日活或月活等等。想把这些数据表达清楚，可能会涉及实时的动态的变化数据；数据的按维度分类展示；如何按数字大小或者属性进行区分，着重展示我们感兴趣的数据。以上涉及到的就是我们常说的数据可视化。数据可视化的目的就是对数据进行可视化处理，以使得明确有效地传递信息。利用图表来对数据进行可视化是我们熟知的方式。产品经理对可视化需求进行分析，选择合适的图表来表达和传递信息。而我们作为前端开发人员，也需要理解需求及设计，选用能满足需求的图表组件或可视化方案来实现产品设计。选择技术方案的时候，我们或许会发现，因为图表内容复杂，没有现成的图表组件能够利用；或者现有的图表组件不能满足我们的部分需求；或者因为大数据量的场景，造成图表渲染较慢。解决这些需求中的痛点，我们就得思考用何种技术方案，怎样解决遇到的问题。思考为什么选择这个方案，它能帮助我们解决什么问题，或者说它有什么优势。 怎么选择现有的可视化库很多，像Echarts，Highcharts，D3这些我们多少都在项目中经常使用或者听说过大名。Echarts等可视化库封装层次很高，能够简单地制作图表，但是给予开发者控制和设计的空间较少。D3在这一点上取得了平衡。D3提供了极度灵活的Web标准化能力，例如CSS3, HTML5, SVG。试想用原生的HTML、SVG、Canvas来实现数据绘图是困难和繁琐的。D3封装了这些能力，使开发者专注布局和逻辑。那么方案怎么选择呢？我们应该熟悉各可视化库的优势，在满足需求的同时也要考虑开发成本。 关于D3.js什么是D3.jsD3 全称是Data-Driven Document，直译为数据驱动文档。 数据由用户或开发者提供文档指的是基于web的文档，即Web浏览器可以渲染的任何元素，例如HTML、SVG、Canvas由D3来驱动数据和文档。从某种意义上说，它将文档和数据联系起来。 D3是一个JavaScript函数库，是用来做数据可视化的。 用D3.js的创始人Mike Bostock 其开源地址：https://github.com/d3/d3 历史及版本比较 2011年2月，Mike Bostock发布了v1.0.0版本。 2012年12月，v3.0.0版本发布，网上3.x的资料比较多。 2016年6月，v4.0.0版本发布，开始支持Canvas，采用模块化设计模式。 v3.x v4.x 嵌套结构 模块化 稳定，资料多 有优化，资料相对较少 只支持SVG渲染 支持Canvas渲染 注意：两个版本的代码不兼容 D3的优势 相对比较底层数据和元素捆绑。DOM里含有数据，数据更新时重绘。同时支持SVG和Canvas。 更像数学库强大的图形计算能力，D3的“布局”封装了提供力直方图、饼图、树图、力导向图等。D3的“比例尺”提供线性、指数、对数、序数等多种关于对应关系的计算。还提供“地图”功能。 即封装操作，也给予自由计算和绘图相互独立。计算是算出节点的位置、线段端点、弧线角度等；绘图是将计算所得的节点、线段绘制到网页上。 D3部分模块 模块 描述 依赖 d3-axis 坐标轴 d3-scale, d3-selection, d3-transition d3-color 颜色集操作和呈现 None. d3-format 数字格式化 None. d3-interpolate 插值函数 d3-color d3-path 路径生成 None. d3-polygon 二维多边形几何操作 None. d3-request XMLHttpRequest封装 d3-dsv, d3-dispatch d3-scale XMLHttpRequest封装 d3-dsv, d3-dispatch d3-request 从抽象到具体数据的映射 d3-array, d3-collection, d3-color, d3-format, d3-interpolate, d3-time, d3-time-format d3-selection 通过选择和加入数据进行DOM转换 d3-dsv, d3-dispatch d3-transition D3.js选择集的动画过渡 d3-ease, d3-timer, d3-interpolate, d3-selection D3基础SVG基础SVG（可缩放矢量图形），除了IE8之前的版本外，绝大部分浏览器支持SVG，可以直接嵌入HTML显示。位图与矢量图的区别：位图缩放后失真，矢量图缩放不失真；位图色彩表现力较丰富，矢量图图形色彩较简单；矢量图占用空间较小，位图较大；矢量图容易转化为位图，反之不容易。 SVG图形元素SVG预定义七种形状元素：矩形&lt;rect&gt;、圆形&lt;circle&gt;、椭圆形&lt;ellipse&gt;、线段&lt;line&gt;、折线&lt;polyline&gt;、多边形&lt;polygon&gt;、路径&lt;path&gt;路径指令： M=moveto L=lineto H=horizontal lineto V=vertical lineto C=curveto 画三次贝塞尔曲线经两个指定控制点到达终点 S=smooth curveto 与前一条三次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称 Q=quadratic curveto 画二次贝塞尔曲线经一个指定控制点到达终点 T=smooth quadratic Bezier curvto 与前一条二次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称，只需输入终点，即可绘制一条二次贝塞尔曲线SVG 示例 文字在SVG中可以使用&lt;text&gt;标签绘制文字dx: 相对当前位置在x方向上平移的距离，dy同理。text-anchor属性 1234&lt;text class=\"label-2\" text-anchor=\"end\" dy=\".35em\" rank=\"B\"&gt; &lt;tspan x=\"0\" dy=\"0.35em\"&gt;(不知情定制B004)内容战&lt;/tspan&gt; &lt;tspan x=\"0\" dy=\"1.0499999999999998em\"&gt;略合作伙伴分类不合规&lt;/tspan&gt;&lt;/text&gt; D3数据选择和属性设定我们要对DOM中的元素执行一个行为，例如移动位置，改变颜色,更新数据中的值，首先要选中它。d3.select()是选中单个元素；d3.selectAll()是选中多个元素。选择集是一个或多个页面元素的组合，能够与数据集相关联。利用D3提供的方法设置元素属性和样式值： 123d3.selectAll(\"circle.a\").style(\"fill\", \"red\").attr(\"cx\", 100)d3.select(\"circle\").attr(\"class\", \"active\");d3.select(\"circle\").classed(\"active\", true); // 添加或者移除命名的样式 有部分属性不能用attr()设定和获取，最典型的就是文本框的value属性，这样情况可以用property()来设定，例如： 1d3.select(\"#someCheckbox\").property(\"checked\", true); 方法链，也叫链式调用。和JQuery写法类似。 1d3.selectAll(\"div\").data(someData).enter().append(\"div\").html(\"Wow\").append(\"span\").html(\"Even More Wow\").style(\"font-weight\", \"900\"); 可以给.style(), .attr(), .property(), .html()设置匿名函数调用或者其他提供数据绑定的选择器的函数。 123456789var someColors = [\"blue\", \"red\", \"chartreuse\", \"orange\"];someColors = someColors.filter(function(d) &#123;return d.length &lt; 5&#125;);d3.select(\"body\").selectAll(\"div\") .data(someColors) .enter() .append(\"div\") .style(\"background\", function(d) &#123;return d&#125;) .attr(\"cx\", function(d,i) &#123;return i&#125;) .html(function(d) &#123;return d&#125;) D3数据处理 数据映射数字数据仅仅同图形化元素在屏幕上的尺寸和位置相关。Scales（比例尺）有一个定义域domain和一个值域range。我们使用d3.scale()函数来归一化数据。例如我们通过线性比例尺，将 500,000到13,000,000的城市人口相同的线性变化映射到0到500px宽的画布上。12345678var newRamp = d3.scaleLinear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // 返回20，可以将一千万人口的国家放在20px处newRamp(9000000); // 返回340newRamp.invert(313); // 求逆，返回8325000var newRamp = d3.scaleLinear().domain([500000,13000000]).range([\"blue\", \"red\"]);newRamp(1000000); // 返回\"#0a00f5\"，可以将一百万人口的城市用深紫色表示newRamp(9000000); // 返回\"#ad0052\"newRamp.invert(\"#ad0052\"); // 因为invert函数只接受数字，因此返回NaN 我们也能使用d3.scaleLog(), d3.scalePow(), d3.scaleOrdinal()等其他对数据集来说更加适合的比例尺来映射数据。 数据分类将定量数据分类，是将值按范围分或者组装到一起。一种分类方法是将数组均分几份。12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scaleQuantile().domain(sampleArray).range([0,1,2]);qScale(423); // 返回2qScale(20); // 返回0qScale(10000); // 返回2 嵌套允许数组中的元素被组织为分层树型结构；类似SQL语句里面的GROUP BY方法。下面的例子，将示例数据首先按year分组再按variety分组，如下： 12345678var yields = [&#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]var nest = d3.nest() .key(function(d) &#123; return d.year; &#125;) .key(function(d) &#123; return d.variety; &#125;) .entries(yields); 返回的嵌套数组中,以键值对的形式对数据进行分组: 123456789[&#123;key: 1931, values: [ &#123;key: \"Manchuria\", values: [ &#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]&#125;, &#123;key: \"Glabron\", values: [ &#123;yield: 43.07, variety: \"Glabron\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 55.20, variety: \"Glabron\", year: 1931, site: \"Waseca\"&#125;, ...]&#125;, ...]&#125;, &#123;key: 1932, values: ...&#125;] 在数据格式化以后，需要测量它，以确保创建的图形尺寸合适，位置是基于数据集的参数。那你将会一直用到d3.extent，d3.min，d3.max，d3.mean。 数据测量在加载你的数据以后，首要的事情之一是应该对数据进行测量和排序。很重要的是知道特殊属性值的分布，以及最大最小值和属性名称。D3提供一个数组的函数集合能帮助理解数据。加入想从cities.csv获取城市人口的最小，最大，平均值：12345d3.csv(\"cities.csv\", data =&gt; &#123; d3.min(data, el =&gt; +el.population); d3.max(data, el =&gt; +el.population); d3.mean(data, el =&gt; +el.population);&#125;); d3.extent方便地将d3.min()和d3.max()在一个数组中返回： 1d3.extent(data, el =&gt; +el.population); // 返回[500000, 1300000] 现在，我们已经加载、格式化、测量了我们的数据，那我们就可以创建数据可视化了。 简单数据可视化示例 D3数据绑定过程一个选择集是由DOM中一个或多个元素构成。能使用选择器创建和删除元素，更改样式和内容。 123456789101112131415d3.csv(\"cities.csv\", (error,data) =&gt; &#123; if (error) &#123; console.error(error) &#125; else &#123; dataViz(data) &#125;&#125;);function dataViz(incomingData) &#123; d3.select(\"body\").selectAll(\"div.cities\") .data(incomingData) // 绑定数据到选择集 .enter() // 定义当选择集中的数据多于DOM元素时如何响应 .append(\"div\") // 在当前选择集中创建一个元素 .attr(\"class\", \"cities\") // 设置新创建元素class .html(d =&gt; d.label); // 设置创建div的内容&#125; 经常传入id没有匹配到任何元素，那么称其为空选择集。当数据值的数量大于选择器中元素的数量，.enter()函数触发，允许你为每一个没有相应DOM元素的值定义一个执行行为。这里需要将选中的DOM元素同一个数组联系起来。数据集里的每一个城市同选择集中的一个DOM元素相联系，关联数据是存在元素的data属性中。 1document.getElementsByClassName(\"cities\")[0].__data__ // 返回一个指向对象的指针 如果数组长度大于元素数量，则部分还不存在的元素“即将进入可视化（enter）” 如果数组长度小于元素数量，则多余的元素“即将退出可视化（exit）” 如果数组长度等于元素数量，则绑定数据的元素“即将被更新（update）” 大多数情况，.enter()函数触发，使用.append()来添加元素；.exit()函数触发，使用.remove()来移除元素。 交互颜色插值D3支持颜色插值 123var ybRamp = d3.scaleLinear() .interpolate(d3.interpolateHsl) .domain([0, maxValue]).range([\"yellow\", \"blue\"]); 离散颜色比例尺：d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, and d3.schemeCategory20c序数比例尺，映射离散值为特殊的颜色。一个有用的特征是它的unknown方法，当传入一个不存在的值的时候，返回设定值。Color Scales 1234var tenColorScale = d3.scaleOrdinal() .domain([\"UEFA\", \"CONMEBOL\"]) .range(d3.schemeCategory10) .unknown(\"#c4b9ac\") 事件监听D3选择器可以通过on来为事件添加监听器：selection.on(type[, listener[, capture]]) 123selection.on(\"click\", function () &#123; console.log(d3.mouse(this)); // 输出相对坐标&#125;) 在当前选择的每个元素，为指定的类型type，添加或删除事件监听器listener 。type是一个字符串事件类型的名称，如“click”、“mouseover”、“keydown”、“touchstart”。基本上支持任何DOM事件，如鼠标、键盘、触屏事件。为了在侦听器内访问当前事件，使用全局函数d3.event。 如果所选择的元素相同类型的一个事件监听已经注册了，新的侦听加入之前的现有侦听被除去。为注册相同事件类型的多个监听器，该类型可以跟一个可选的命名空间，如“click.first”和“click.second”。 要删除一个监听器，传递null给listener如：selection.on(click”, null)。 行为下面给出拖拽和缩放的例子：拖拽简单示例缩放简单示例 布局D3 3.x提供了12种布局：饼状图（Pie）、力导向图（Force）、弦图（Chord）、树图（Tree）、集群图（Cluster）、捆图（Bundle）、打包图（Pack）、直方图（Histogram）、分区图（Partition）、堆栈图（Stack）、矩阵树图（Treemap）、层级图（Hierarchy）。力导向图（Force-Directed Graph），是一种常用的绘图算法。d3-force, 力布局这个模块基于Verlet integration(韦尔莱积分法)实现了物理粒子之间的作用力的仿真。模拟的作用力有电荷之间的吸引排斥力，重力，链接吸引力。 力导向图的绘制 生成数据 设置力导向图 添加绘制方法 添加交互 力导向图示例 总结Ben Fry提出的数据可视化七个步骤：获取、解析、过滤、挖掘、表现、改善、交互。D3数据可视化也会经历这几个过程。首先D3读取源数据，进行解析得到需要处理的对象数组，然后将得到的数据进行过滤返回我们感兴趣的数据，然后对过滤得到的数据进行格式化，分类或分组，方便利用数据来驱动文档。通常我们根据数据数值大小或时间远近等熟悉转换为图形上元素的大小或者位置。如果需要生成网络图谱等可视化图表，我们可以利用D3提供的布局来绘制。以力导向图为例，首先构建节点和连线的对象数据，然后将其设定给力导向图，力导向图为给节点连线生成初始的位置信息，然后根据节点和连线对象数据来自定义（绘制）节点和内容。同时我们利用tick机制绑定tick回调函数，在回调函数中定义机制对节点和连线的坐标进行更新，并更新图表。D3.js是一种很强大的可视化利器，在GitHub数据可视化分类中关注度最高的。在AI+物联网时代，数据可视化或者说人机交互将会越来越重要。掌握常见的数据可视化技术，理解可视化中的图形图像算法对于想在可视化方向深耕的小伙伴来说是很有必要的。 参考资料 D3 API 中文文档 D3 js in action 精通D3.js（第二版） D3.js 4.x Data Visualization(Third Edition) 图说D3数据可视化利器从入门到进阶","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://www.haoming.fun/categories/数据可视化/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://www.haoming.fun/tags/D3-js/"}],"author":"Peng Fang"},{"title":"D3.js数据可视化实践（讲义）","slug":"D3-js数据可视化实践（讲义）","date":"2018-06-29T11:01:00.000Z","updated":"2019-06-30T04:11:36.658Z","comments":true,"path":"2018/06/29/D3-js数据可视化实践（讲义）/","link":"","permalink":"https://www.haoming.fun/2018/06/29/D3-js数据可视化实践（讲义）/","excerpt":"","text":"D3数据可视化实践 方鹏 2018/06/29 目标了解D3常用API和重要知识点，能阅读和编写简单的D3.js可视化程序。 内容 D3简介 基础知识点（SVG + D3） 数据处理（涉及加载数据、处理数据） 数据绑定 交互 布局 什么是D3D3 全称是Data-Driven Document，直译为数据驱动文档。 数据由用户或开发者提供文档指的是基于web的文档，即Web浏览器可以渲染的任何元素，例如HTML、SVG它们由D3来驱动。从某种意义上说，它将文档和数据联系起来。 只要记住：D3是一个JavaScript函数库，是用来做数据可视化的。 其开源地址：https://github.com/d3/d3 用D3.js的创始人Mike Bostock的话说：D3提供了极度灵活，Web标准化的能力，例如CSS3, HTML5, SVG。试想用原生的HTML、SVG、Canvas来实现数据变成图形是困难和繁琐的。D3封装了这些能力，使开发者专注布局和逻辑。 D3简史 2011年2月，Mike Bostock发布了v1.0.0版本。 2012年12月，v3.0.0版本发布，网上3.x的资料比较多。 2016年6月，v4.0.0版本发布，开始支持Canvas，采用模块化设计模式。 D3的优势Echarts等封装层次很高，能够简单地制作图表，但是给予开发者控制和设计的空间较少。D3在这一点上取得了平衡。 相对比较底层数据和元素捆绑。DOM里含有数据，数据更新时重绘。同时支持SVG和Canvas。 更像数学库强大的图形计算能力，D3的“布局”封装了提供力直方图、饼图、树图、力导向图等。D3的“比例尺”提供线性、指数、对数、序数等多种关于对应关系的计算。还提供“地图”功能。 即封装操作，也给予自由计算和绘图相互独立。计算是算出节点的位置、线段端点、弧线角度等；绘图是将计算所得的节点、线段绘制到网页上。 应用截图如下： 适用范围数据可视化七个步骤：获取、解析、过滤、挖掘、表现、改善、交互表现、改善、交互属于D3的适用范围 它不能干什么 D3不能生成预定义的或者封装好的可视化效果，也就是不提供预先配置的图表类型。 D3不支持老的浏览器。 D3代码在客户端执行，因此不能隐藏源数据。如果担心数据泄露，最好不要可视化，可视化的目的是交流数据。 SVGSVG（可缩放矢量图形），除了IE8之前的版本外，绝大部分浏览器支持SVG，可以直接嵌入HTML显示。位图与矢量图的区别：位图缩放后失真，矢量图缩放不失真；位图色彩表现力较丰富，矢量图图形色彩较简单；矢量图占用空间较小，位图较大；矢量图容易转化为位图，反之不容易。 SVG图形元素SVG预定义七种形状元素：矩形&lt;rect&gt;、圆形&lt;circle&gt;、椭圆形&lt;ellipse&gt;、线段&lt;line&gt;、折线&lt;polyline&gt;、多边形&lt;polygon&gt;、路径&lt;path&gt;路径指令： M=moveto L=lineto H=horizontal lineto V=vertical lineto C=curveto 画三次贝塞尔曲线经两个指定控制点到达终点 S=smooth curveto 与前一条三次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称 Q=quadratic curveto 画二次贝塞尔曲线经一个指定控制点到达终点 T=smooth quadratic Bezier curvto 与前一条二次贝塞尔曲线相连，第一个控制点与前一条曲线的第二个控制点对称，只需输入终点，即可绘制一条二次贝塞尔曲线示例 文字在SVG中可以使用&lt;text&gt;标签绘制文字dx: 相对当前位置在x方向上平移的距离，dy同理。text-anchor属性 1234&lt;text class=\"label-2\" text-anchor=\"end\" dy=\".35em\" rank=\"B\"&gt; &lt;tspan x=\"0\" dy=\"0.35em\"&gt;(不知情定制B004)内容战&lt;/tspan&gt; &lt;tspan x=\"0\" dy=\"1.0499999999999998em\"&gt;略合作伙伴分类不合规&lt;/tspan&gt;&lt;/text&gt; D3数据选择和属性设定我们要对DOM中的元素执行一个行为，例如移动位置，改变颜色,更新数据中的值，首先要选中它。d3.select()是选中单个元素；d3.selectAll()是选中多个元素。选择集是一个或多个页面元素的组合，能够与数据集相关联。利用D3提供的方法设置元素属性和样式值： 123d3.selectAll(\"circle.a\").style(\"fill\", \"red\").attr(\"cx\", 100)d3.select(\"circle\").attr(\"class\", \"active\");d3.select(\"circle\").classed(\"active\", true); // 添加或者移除命名的样式 有部分属性不能用attr()设定和获取，最典型的就是文本框的value属性，这样情况可以用property()来设定，例如： 1d3.select(\"#someCheckbox\").property(\"checked\", true); 方法链，也叫链式调用。和JQuery写法类似。 1d3.selectAll(\"div\").data(someData).enter().append(\"div\").html(\"Wow\").append(\"span\").html(\"Even More Wow\").style(\"font-weight\", \"900\"); 可以给.style(), .attr(), .property(), .html()设置匿名函数调用或者其他提供数据绑定的选择器的函数。 123456789var someColors = [\"blue\", \"red\", \"chartreuse\", \"orange\"];someColors = someColors.filter(function(d) &#123;return d.length &lt; 5&#125;);d3.select(\"body\").selectAll(\"div\") .data(someColors) .enter() .append(\"div\") .style(\"background\", function(d) &#123;return d&#125;) .attr(\"cx\", function(d,i) &#123;return i&#125;) .html(function(d) &#123;return d&#125;) Hello World 示例 使用数据D3数据处理流程： 加载数据D3提供几个方法来导入和处理数据。一样的是，d3.csv()和d3.json()生成一个JSON对象数组，而d3.xml()会创建一个XML文档。 12d3.csv(\"cities.csv\", (error, data) =&gt; &#123; console.log(error, data) &#125;);d3.json(\"tweets.json\", data =&gt; console.log(data)); error变量是可选项 数据格式化 数据映射数字数据仅仅同图形化元素在屏幕上的尺寸和位置相关。Scales（比例尺）有一个定义域domain和一个值域range。我们使用d3.scale()函数来归一化数据。例如我们通过线性比例尺，将 500,000到13,000,000的城市人口相同的线性变化映射到0到500px宽的画布上。12345678var newRamp = d3.scaleLinear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // 返回20，可以将一千万人口的国家放在20px处newRamp(9000000); // 返回340newRamp.invert(313); // 求逆，返回8325000var newRamp = d3.scaleLinear().domain([500000,13000000]).range([\"blue\", \"red\"]);newRamp(1000000); // 返回\"#0a00f5\"，可以将一百万人口的城市用深紫色表示newRamp(9000000); // 返回\"#ad0052\"newRamp.invert(\"#ad0052\"); // 因为invert函数只接受数字，因此返回NaN 我们也能使用d3.scaleLog(), d3.scalePow(), d3.scaleOrdinal()等其他对数据集来说更加适合的比例尺来映射数据。 数据分类将定量数据分类，是将值按范围分或者组装到一起。一种分类方法是将数组均分几份。12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scaleQuantile().domain(sampleArray).range([0,1,2]);qScale(423); // 返回2qScale(20); // 返回0qScale(10000); // 返回2 嵌套允许数组中的元素被组织为分层树型结构；类似SQL语句里面的GROUP BY方法。下面的例子，将示例数据首先按year分组再按variety分组，如下： 12345678var yields = [&#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]var nest = d3.nest() .key(function(d) &#123; return d.year; &#125;) .key(function(d) &#123; return d.variety; &#125;) .entries(yields); 返回的嵌套数组中,以键值对的形式对数据进行分组: 123456789[&#123;key: 1931, values: [ &#123;key: \"Manchuria\", values: [ &#123;yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"&#125;, &#123;yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"&#125;, ...]&#125;, &#123;key: \"Glabron\", values: [ &#123;yield: 43.07, variety: \"Glabron\", year: 1931, site: \"University Farm\"&#125;, &#123;yield: 55.20, variety: \"Glabron\", year: 1931, site: \"Waseca\"&#125;, ...]&#125;, ...]&#125;, &#123;key: 1932, values: ...&#125;] 在数据格式化以后，需要测量它，以确保创建的图形尺寸合适，位置是基于数据集的参数。那你将会一直用到d3.extent，d3.min，d3.max，d3.mean。 测量数据在加载你的数据以后，首要的事情之一是应该对数据进行测量和排序。很重要的是知道特殊属性值的分布，以及最大最小值和属性名称。D3提供一个数组的函数集合能帮助理解数据。加入想从cities.csv获取城市人口的最小，最大，平均值： 12345d3.csv(\"cities.csv\", data =&gt; &#123; d3.min(data, el =&gt; +el.population); d3.max(data, el =&gt; +el.population); d3.mean(data, el =&gt; +el.population);&#125;); d3.extent方便地将d3.min()和d3.max()在一个数组中返回： 1d3.extent(data, el =&gt; +el.population); // 返回[500000, 1300000] 现在，我们已经加载、格式化、测量了我们的数据，那我们就可以创建数据可视化了。 简单数据可视化示例 数据可视化接下来将更深入解释选择器是如何与数据绑定一起创建元素的，以及创建后如何改变这些元素。 data工作过程一个选择集是由DOM中一个或多个元素构成。能使用选择器创建和删除元素，更改样式和内容。 123456789101112131415d3.csv(\"cities.csv\", (error,data) =&gt; &#123; if (error) &#123; console.error(error) &#125; else &#123; dataViz(data) &#125;&#125;);function dataViz(incomingData) &#123; d3.select(\"body\").selectAll(\"div.cities\") .data(incomingData) // 绑定数据到选择集 .enter() // 定义当选择集中的数据多于DOM元素时如何响应 .append(\"div\") // 在当前选择集中创建一个元素 .attr(\"class\", \"cities\") // 设置新创建元素class .html(d =&gt; d.label); // 设置创建div的内容&#125; 经常传入id没有匹配到任何元素，那么称其为空选择集。当数据值的数量大于选择器中元素的数量，.enter()函数触发，允许你为每一个没有相应DOM元素的值定义一个执行行为。这里需要将选中的DOM元素同一个数组联系起来。数据集里的每一个城市同选择集中的一个DOM元素相联系，关联数据是存在元素的data属性中。 1document.getElementsByClassName(\"cities\")[0].__data__ // 返回一个指向对象的指针 如果数组长度大于元素数量，则部分还不存在的元素“即将进入可视化（enter）” 如果数组长度小于元素数量，则多余的元素“即将退出可视化（exit）” 如果数组长度等于元素数量，则绑定数据的元素“即将被更新（update）” 大多数情况，.enter()函数触发，使用.append()来添加元素；.exit()函数触发，使用.remove()来移除元素。 文档驱动设计及交互D3v4 有几个方法帮助DOM上下移动：selection.raise 和 selection.lower. 使用这些方法来移动选择的元素到DOM兄弟节点的末尾或者移动到开头位置。 12d3.select(\"g.overallG\").raise()d3.select(\"g.overallG\").lower() 禁用元素的鼠标事件： 1teamG.select(\"text\").style(\"pointer-events\",\"none\"); 使用颜色d3.rbg()的使用如下： 1234teamColor = d3.rgb(\"red\");teamColor = d3.rgb(\"#ff0000\");teamColor = d3.rgb(\"rgb(255,0,0)\");teamColor = d3.rgb(255,0,0); 这些颜色对象有两个有用的方法：.darker() 和 .brighter()，返回比初始值更亮或更暗的值。 123d3.selectAll(\"g.overallG\").select(\"circle\") .style(\"fill\", p =&gt; p.region === d.region ? teamColor.darker(.75) : teamColor.brighter(.5)) // rgb.brighter([k]),每个颜色通道值将乘以0.7 ^ -k d3.hsl, d3.lab, d3.cubehelix, d3.hcl可以呈现不同的颜色空间D3支持颜色插值 123var ybRamp = d3.scaleLinear() .interpolate(d3.interpolateHsl) .domain([0, maxValue]).range([\"yellow\", \"blue\"]); 离散颜色比例尺：d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, and d3.schemeCategory20c序数比例尺，映射离散值为特殊的颜色。一个有用的特征是它的unknown方法，当传入一个不存在的值的时候，返回设定值。Color Scales 1234var tenColorScale = d3.scaleOrdinal() .domain([\"UEFA\", \"CONMEBOL\"]) .range(d3.schemeCategory10) .unknown(\"#c4b9ac\") 监听器D3选择器可以通过on来为事件添加监听器：selection.on(type[, listener[, capture]]) 123selection.on(\"click\", function () &#123; console.log(d3.mouse(this)); // 输出相对坐标&#125;) 在当前选择的每个元素，为指定的类型type，添加或删除事件监听器listener 。type是一个字符串事件类型的名称，如“click”、“mouseover”、“keydown”、“touchstart”。基本上支持任何DOM事件，如鼠标、键盘、触屏事件。为了在侦听器内访问当前事件，使用全局函数d3.event。 如果所选择的元素相同类型的一个事件监听已经注册了，新的侦听加入之前的现有侦听被除去。为注册相同事件类型的多个监听器，该类型可以跟一个可选的命名空间，如“click.first”和“click.second”。 要删除一个监听器，传递null给listener如：selection.on(click”, null)。 行为下面给出拖拽和缩放的例子：拖拽简单示例缩放简单示例 布局D3 3.x提供了12种布局：饼状图（Pie）、力导向图（Force）、弦图（Chord）、树图（Tree）、集群图（Cluster）、捆图（Bundle）、打包图（Pack）、直方图（Histogram）、分区图（Partition）、堆栈图（Stack）、矩阵树图（Treemap）、层级图（Hierarchy） 力导向图力导向图（Force-Directed Graph），是绘图的一种算法。d3-force, 力布局这个模块基于Verlet integration(韦尔莱积分法)实现了物理粒子之间的作用力的仿真。模拟的作用力有电荷之间的吸引排斥力，重力，链接吸引力。 力导向图示例 项目案例分析参考资料 D3 API 中文文档 D3 js in action 精通D3.js（第二版） D3.js 4.x Data Visualization(Third Edition) 图说D3数据可视化利器从入门到进阶","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://www.haoming.fun/categories/数据可视化/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://www.haoming.fun/tags/D3-js/"}],"author":"Peng Fang"},{"title":"《D3.js in Action Data visualization with JavaScript(2nd)》部分章节摘要","slug":"《D3-js-in-Action-Data-visualization-with-JavaScript-2nd-》部分章节摘要","date":"2018-06-27T10:58:00.000Z","updated":"2019-06-30T04:11:36.664Z","comments":true,"path":"2018/06/27/《D3-js-in-Action-Data-visualization-with-JavaScript-2nd-》部分章节摘要/","link":"","permalink":"https://www.haoming.fun/2018/06/27/《D3-js-in-Action-Data-visualization-with-JavaScript-2nd-》部分章节摘要/","excerpt":"","text":"什么是D3为满足Web可访问的，复杂的数据可视化需求而生。假如你公司使用了BI工具，但是他们不能满足团队需求用来显示数据的类型模式。那么你就需要量身定制地构建一个客户化的看板来精确展示具体领域客户的行为。这个数据看板需要快速、可交互、能在组织内分享。那么可以使用D3来做这个事情。D3.js的创始人Mike Bostock，用他的话说：提供极度灵活，Web标准化的能力，例如CSS3,HTML5,SVG. 最新迭代版本D3.v4 D3怎样工作怎样使用D3来处理和呈现数据，也是增加交互性，优化数据可视化。理解D3选择器、数据绑定、D3怎样与DOM中的SVG和HTML交互。 数据可视化不仅仅是图表你或许认为数据可视化仅限于饼图、线图、以及其他各类图表。远远不止如此。D3.js核心能力之一是为传统图表创建矢量图形，创建地理空间和网络可视化，以及丰富的动画和交互性。数据可视化这种广泛的方法中，地图或者网络图谱或表格是数据的一种表现形式，也是D3.js库提供的核心能力。学习D3是因为它提供能力实现几乎每个主要的数据可视化技术，也提供能力创建你自己的数据可视化技术。 D3数据选择和绑定selection是数据和元素的组合。我们对group中的元素执行一个行为，例如移动或者改变颜色。同样也可以更新数据中的值。尽管我们以页面元素和数据分离的方式工作，D3真正强大来自于使用选择器来合并数据和web页面元素。 1d3.selectAll(\"circle.a\").style(\"fill\", \"red\").attr(\"cx\", 100) 使用d3.select()选择单个元素；使用d3.selectAll()选中多个元素选择器是一个或多个页面元素的组合能够与数据集相关联，例如下面的代码是绑定数组[1,5,11,3]元素到样式名为market的div： 1d3.selectAll(\"div.market\").data([1,5,11,3]) D3遍历选择器中的元素，使用绑定数据执行相同的行为，导致不同的图形化效果。行为相同，效果不同。决定一个元素的行为和呈现分别是：样式、属性attributes、特性properties。样式决定不透明度、颜色、尺寸、边框等。属性包含ID、类名、交互行为。特性涉及状态，例如单选框的选中。D3有三个函数来定义这些值： 123d3.select(\"#someDiv\").style(\"border\", \"5px darkgray dashed\");d3.select(\"#someDiv\").attr(\"id\", \"newID\");d3.select(\"#someCheckbox\").property(\"checked\", true); DOM决定了元素在屏幕上的绘制顺序，孩子元素在父元素的里面及之后绘制。尽管传统HTML中可以使用z-index来控制，但是在SVG2规范实现之前，设置z-index对SVG元素来说不管用。 SVGHTML5一个主要的特性就是集成支持SVG。SVG允许图像简单的数字呈现如缩放，这并应用到动画和交互中。D3提供一个抽象层绘制SVG。SVG绘制复杂形状的指令如路径，从画布的一个点开始向另一个点画线。如果想绘制曲线，将绘制曲线的坐标设置为path的d属性。 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;script src=\"d3.v4.min.js\"&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=\"infovizDiv\"&gt;&lt;svg style=\"width:500px;height:500px;border:1px lightgray solid;\"&gt;&lt;path d=\"M 10,60 40,30 50,50 60,30 70,80\"style=\"fill:black;stroke:gray;stroke-width:4px;\" /&gt;&lt;polygon style=\"fill:gray;\"points=\"80,400 120,400 160,440 120,480 60,460\" /&gt;&lt;g&gt;&lt;line x1=\"200\" y1=\"100\" x2=\"450\" y2=\"225\"style=\"stroke:black;stroke-width:2px;\"/&gt;&lt;circle cy=\"100\" cx=\"200\" r=\"30\"/&gt;&lt;rect x=\"410\" y=\"200\" width=\"100\" height=\"50\"style=\"fill:pink;stroke:black;stroke-width:1px;\" /&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; svg提供一系列的通用形状集合：&lt;CIRCLE&gt;, &lt;RECT&gt;, &lt;LINE&gt;, &lt;POLYGON&gt;，每个形状都有元素决定它的尺寸和位置。&lt;RECT&gt;有x和y属性决定形状左上角的位置。&lt;CIRCLE&gt;的x和y属性决定圆心的位置，r属性决定圆半径。&lt;LINE&gt;x1和y1作为起点坐标，x2和y2决定中的坐标位置。任何形状的颜色、外轮廓、不透明度能被改变来适应形状的样式，fill决定形状区域的颜色，stroke,stroke-width,stroke-dasharray决定其外轮廓。能像下面这样改变矩形的样式： 1fill:purple;stroke-width:5px;stroke:cornflowerblue; &lt;TEXT&gt;,SVG提供写文本的能力。如果想要实现基本的格式化，可以在&lt;TEXT&gt;中嵌套&lt;TSPAN&gt;。&lt;G&gt;或者组元素，区别于之前的SVG元素，它没有图形化呈现的能力，不存在一个边界空间。可以使用它来表示一个逻辑分组。当创建一个图形对象，有几个形状的图形和文本组成，就可以将它们放在&lt;G&gt;标签内。在画板内移动&lt;G&gt;元素，可以通过transform属性，它接受一个结构化的描述就是translate()，传一对坐标x和y，表示其向右和向下移动的像素数。transform属性还接受scale()，用来改变图形渲染的比例。 CSS.css文件能被引入到HTML页当中，或者直接嵌入HTML当中，或者同js控制。 123d3.select(#someElement).style(opacity, .5);d3.select(\"circle\").attr(\"class\", \"tentative\");d3.select(\"circle\").classed(\"active\", true); 通过.classed()，不必重写存在的样式，而是从样式列表中添加或者移除命名的样式。 JavaScript方法链，也叫链式调用。这和我们平时聊天有点像。 1d3.selectAll(\"div\").data(someData).enter().append(\"div\").html(\"Wow\").append(\"span\").html(\"Even More Wow\").style(\"font-weight\", \"900\"); 可以给.style(), .attr(), .property(), .html()设置匿名函数调用或者其他提供数据绑定的选择器的函数。 123456789var someColors = [\"blue\", \"red\", \"chartreuse\", \"orange\"];someColors = someColors.filter(function(d) &#123;return d.length &lt; 5&#125;);d3.select(\"body\").selectAll(\"div\").data(someColors).enter().append(\"div\").style(\"background\", function(d) &#123;return d&#125;).attr(\"cx\", function(d,i) &#123;return i&#125;).html(function(d) &#123;return d&#125;) 数据标准因为不同目的数据被格式化为不同的形式，但是它倾向存在于我们认识的类型：表格数据，嵌套数据，网络数据，地理数据，裸数据，对象。 第一个D3 APP1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;&lt;script src=\"https://d3js.org/d3.v4.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"vizcontainer\"&gt;&lt;svg style=\"width:500px;height:500px;border:1px lightgray solid;\" /&gt;&lt;script&gt;d3.select(\"svg\").append(\"circle\").attr(\"r\", 20).attr(\"cx\",20).attr(\"cy\",20).style(\"fill\",\"red\");d3.select(\"svg\").append(\"text\").attr(\"id\", \"a\").attr(\"x\",20).attr(\"y\",20).style(\"opacity\", 0).text(\"HELLO WORLD\");d3.select(\"svg\").append(\"circle\").attr(\"r\", 100).attr(\"cx\",400).attr(\"cy\",400).style(\"fill\",\"lightblue\");d3.select(\"svg\").append(\"text\").attr(\"id\", \"b\").attr(\"x\",400).attr(\"y\",400).style(\"opacity\", 0).text(\"Uh, hi.\");d3.select(\"#a\").transition().delay(1000).style(\"opacity\", 1);d3.select(\"#b\").transition().delay(3000).style(\"opacity\", .75);d3.selectAll(\"circle\").transition().duration(2000).attr(\"cy\", 200);&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用数据 加载数据不管什么样的数据源，都可能被格式化成XML，CSV，或者JSON这样的格式。D3提供几个方法来导入和处理数据。一样的是，d3.csv()和d3.json()生成一个JSON对象数组，而d3.xml()会创建一个XML文档。 12d3.csv(\"cities.csv\", (error,data) =&gt; &#123; console.log(error, data) &#125;);d3.json(\"tweets.json\", data =&gt; console.log(data)); error变量是可选项 数据格式化在我们加载数据集以后，我们需要定义方法以致于数据的属性同颜色、尺寸和位置的设定相关。比如想展示导入的CSV文件格式的城市数据，假如使用圆来表示，根据人口数量来设置圆的大小，根据几何坐标设置位置。在做数据可视化的时候，我们需要理解数据形式，通常可以分为数量的，类别的，几何的，临时的，拓扑的或者未加工的。 进一步更改数据数字数据仅仅同图形化元素在屏幕上的尺寸和位置相关。使用d3.scale()函数来归一化数据。Scales（比例尺）有一个定义域domain和一个值域range。例如，从cities.csv里面取出人口数字的最小值和最大值，通过线性比例尺我们能将它们的不同很容易地展示到500px的画布上。下图所示，将 500,000到13,000,000相同的线性变化映射到0到500. 12345678var newRamp = d3.scaleLinear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // 返回20，可以将一千万人口的国家放在20px处newRamp(9000000); // 返回340newRamp.invert(313); // 求逆，返回8325000var newRamp = d3.scaleLinear().domain([500000,13000000]).range([\"blue\", \"red\"]);newRamp(1000000); // 返回\"#0a00f5\"，可以将一百万人口的城市用深紫色表示newRamp(9000000); // 返回\"#ad0052\"newRamp.invert(\"#ad0052\"); // 因为invert函数只接受数字，因此返回NaN 我们也能使用d3.scaleLog(), d3.scalePow(),d3.scaleOrdinal(), 以及其他不太通用但对数据集来说更加适合的比例尺来映射数据。将定量数据分类，将值按范围分或者组装到一起，是挺有用的。一种分类方法是将数组均分几份。 12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scaleQuantile().domain(sampleArray).range([0,1,2]);qScale(423); // 返回2qScale(20); // 返回0qScale(10000); // 返回2 嵌套背后的观点是数据的共享属性能被用来排序成离散的类别和子类。 123456d3.json(\"tweets.json\", data =&gt; &#123;var tweetData = data.tweets;var nestedTweets = d3.nest().key(d =&gt; d.user).entries(tweetData);&#125;); d3.nest()合并推特账户到新的对象下的数组，这些新对象由唯一的用户属性值标记。在数据格式化以后，需要测量它，以确保创建的图形尺寸合适，位置是基于数据集的参数。那你将会一直用到d3.extent，d3.min，d3.max，d3.mean. 测量数据在加载你的数据以后，首页的事情之一是你应该将它测量和排序。很重要的是知道特殊属性值的分布，以及最大最小值和属性名称。D3提供一个数组的函数集合能帮助你理解数据。 1234var testArray = [88,10000,1,75,12,35];d3.min(testArray, el =&gt; el); // return 1d3.max(testArray, el =&gt; el); // 返回10000d3.mean(testArray, el =&gt; el); // 返回平均值1701.83 加入想从cities.csv获取人口的最小，最大，平均值： 12345d3.csv(\"cities.csv\", data =&gt; &#123; d3.min(data, el =&gt; +el.population); d3.max(data, el =&gt; +el.population); d3.mean(data, el =&gt; +el.population);&#125;); d3.extent方便地将d3.min()和d3.max()在一个数组中返回： 1d3.extent(data, el =&gt; +el.population); // 返回[500000, 1300000] 现在，我们已经加载、格式化、测量了我们的数据，那我们就可以创建数据可视化了。 数据可视化接下来将更深入解释选择器是如何与数据绑定一起创建元素的，以及创建后如何改变这些元素。第一个例子使用cities.csv中的数据。 选择器及绑定使用D3选择器来改变web页的结构和呈现。一个选择器是由DOM中一个或多个元素构成。你能使用选择器创建和删除元素，更改样式和内容。 12345678910111213141516d3.csv(\"cities.csv\", (error,data) =&gt; &#123; if (error) &#123; console.error(error) &#125; else &#123; dataViz(data) &#125;&#125;);function dataViz(incomingData) &#123; d3.select(\"body\").selectAll(\"div.cities\") .data(incomingData) // 绑定数据到选择器 .enter() // 定义当选择中的数据多于DOM元素时如何响应 .append(\"div\") // 在当前选择器中创建一个元素 .attr(\"class\", \"cities\") // 设置新创建元素class .html(d =&gt; d.label); // 设置创建div的内容&#125; d3.selectAll()传入对应于DOM一部分的CSS id选择器。经常传入id没有匹配到任何元素，那么称其为空选择器，使用.enter()函数在页面上创建新元素。需要指明一个选择器如何创建或更改一个具体DOM元素的孩子元素。注意子选项不会自动生成父节点。父亲必须已经存在，或者需要使用.append()创建一个。这里需要将选中的DOM元素同一个数组联系起来。数据集里的每一个城市通选中器中的一个DOM元素想联系，关联数据是存在元素的data属性中。 1document.getElementsByClassName(\"cities\")[0].__data__ // 返回一个指向对象的指针 当数据值的数量大于选择器中元素的数量，.enter()函数触发，允许你为每一个没有相应DOM元素的值定义一个执行行为。当存在的数据值比较少，.enter()函数会触发当两者数量一样，则都不会触发当你知道将不会有更少的数据元素，则不必为.exit()定义处理行为。.append()函数允许你添加更多元素，定义添加哪个元素。通过.insert()你能控制新元素添加的地方。.attr()函数是用来改变样式和属性.html()函数可以设置DOM元素的内容 使用内联函数访问数据在选择器中使用一个内联匿名函数，自动提供两个变量的访问，这对数据呈现很关键。一个是数据值本身，一个是该数据在数组中的位置。直方图是分类表达数据数值最简单最有效的方法。 1234567891011d3.select(\"svg\") .selectAll(\"rect\") .data([15, 50, 22, 8, 100, 10]) .enter() .append(\"rect\") .attr(\"height\", d =&gt; d) .style(\"fill\", \"#FE9922\") .style(\"stroke\", \"#9A8B7A\") .style(\"stroke-width\", \"1px\") .attr(\"x\", (d,i) =&gt; i * 10) .attr(\"y\", d =&gt; 100 - d); 多线性比例尺是在domain和range带有多个点的线性比例尺。比如我们对1到100范围内的值特别感兴趣，对100到1000内的值有时候感兴趣。偶尔会得到相当大的异常值。我们能这样表示： 12var yScale = d3.scaleLinear().domain([0,100,1000,24500]).range([0,50,75,100]); 例如，有一些调查返回的数据，我们认为大于500就表示成功。我们仅仅想显示0到500内的数据，同时用比例尺强调0到100的变化。 12var yScale = d3.scaleLinear().domain([0,100,500]).range([0,50,100]);yScale(1000); // 返回162.5 通常D3比例尺会推断最小值到最大值之外的值。如果想设置小于最小值的取最小值，大于最大值的取最大值。可以使用.clamp()函数： 12345var yScale = d3.scaleLinear() .domain([0,100,500]) .range([0,50,100]) .clamp(true);yScale(1000); // 返回100 scale函数使决定位置、尺寸、数据可视化元素颜色的关键。 数据呈现123456789101112131415161718d3.csv(\"cities.csv\",(error, data) =&gt; &#123; dataViz(data) &#125;);function dataViz(incomingData) &#123; var maxPopulation = d3.max(incomingData, d =&gt; parseInt(d.population)) // 人口数最大值 var yScale = d3.scaleLinear().domain([0, maxPopulation]).range([0,460]); d3.select(\"svg\").attr(\"style\", \"height: 480px; width: 600px;\"); d3.select(\"svg\") .selectAll(\"rect\") .data(incomingData) .enter() .append(\"rect\") .attr(\"width\", 50) .attr(\"height\", d =&gt; yScale(parseInt(d.population))) .attr(\"x\", (d,i) =&gt; i * 60) .attr(\"y\", d =&gt; 480 - yScale(parseInt(d.population))) .style(\"fill\", \"#FE9922\") .style(\"stroke\", \"#9A8B7A\") .style(\"stroke-width\", \"1px\")&#125; 1234567891011121314151617181920212223d3.json(\"tweets.json\",(error, data) =&gt; &#123; dataViz(data.tweets) &#125;); function dataViz(incomingData) &#123; var nestedTweets = d3.nest() .key(d =&gt; d.user) .entries(incomingData); nestedTweets.forEach(d =&gt; &#123; d.numTweets = d.values.length; // 创建一个新属性 &#125;) var maxTweets = d3.max(nestedTweets, d =&gt; d.numTweets); var yScale = d3.scaleLinear().domain([0,maxTweets]).range([0,500]); d3.select(\"svg\") .selectAll(\"rect\") .data(nestedTweets) .enter() .append(\"rect\") .attr(\"width\", 50) .attr(\"height\", d =&gt; yScale(d.numTweets)) .attr(\"x\", (d,i) =&gt; i * 60) .attr(\"y\", d =&gt; 500 - yScale(d.numTweets)) .style(\"fill\", \"#FE9922\") .style(\"stroke\", \"#9A8B7A\") .style(\"stroke-width\", \"1px\");&#125; 设置通道channel多变量是另一种表示具有多个数据特征的数据点的方式。channel是一个图形如何直观表达数据的技术术语，它取决于你正在使用的数据，不同的通道适用于来表达不同的数据可视化。下面通过时间和影响因子两个维度来呈现数据： 12345678910111213141516171819202122232425function dataViz(incomingData) &#123; incomingData.forEach(d =&gt; &#123; d.impact = d.favorites.length + d.retweets.length; d.tweetTime = new Date(d.timestamp); &#125;) var maxImpact = d3.max(incomingData, d =&gt; d.impact); var startEnd = d3.extent(incomingData, d =&gt; d.tweetTime); var timeRamp = d3.scaleTime().domain(startEnd).range([20, 480]); var yScale = d3.scaleLinear().domain([0, maxImpact]).range([0, 460]); var radiusScale = d3.scaleLinear() .domain([0, maxImpact]).range([1, 20]); var colorScale = d3.scaleLinear() .domain([0, maxImpact]).range([\"white\", \"#75739F\"]); d3.select(\"svg\") .selectAll(\"circle\") .data(incomingData) .enter() .append(\"circle\") .attr(\"r\", d =&gt; radiusScale(d.impact)) .attr(\"cx\", d =&gt; timeRamp(d.tweetTime)) .attr(\"cy\", d =&gt; 480 - yScale(d.impact)) .style(\"fill\", d =&gt; colorScale(d.impact)) .style(\"stroke\", \"black\") .style(\"stroke-width\", \"1px\"); &#125;; Enter, update, mergem, exit.enter()已经用到很多次了。现在让我们近距离看看它， 以及与它配对的.exit()。它们只有在绑定数据个数和选择器中DOM元素个数不匹配时才会触发。使用selection.enter() 定义怎样基于绑定数据创建新元素，使用selection.exit()定义元素相关的数据被删除时，如何移除选择器中的元素。更新绑定数据时，会基于数据重新创建图形元素。大多数情况，使用.enter()事件，就会使用.append()来添加元素。 1d3.selectAll(\"g\").data([1,2,3,4]).exit().remove(); 这个代码会删除四个元素。选择器前四个元素绑定了新数据，其余的属于.exit()函数。大多数情况下，不会遇到这样的绑定数组完全不同情况，一般通过用户交互或者其他行为触发数据过滤界面呈现变化后会看到初始化数据的重新绑定。d3.merge()允许合并两个选择器，以致于可以同时操作它们。通常.data()绑定基于数据值在数组中的位置。如果不想依赖位置，而是依赖你绑定的键值，使用有意义的键值，例如数据对象本身的值。所有对象都被当做[object object]对待，所有可以使用JSON.stringify函数。 1234567891011121314151617181920212223242526272829function dataViz(incomingData) &#123; incomingData.forEach(d =&gt; &#123; d.impact = d.favorites.length + d.retweets.length; d.tweetTime = new Date(d.timestamp); &#125;) var maxImpact = d3.max(incomingData, d =&gt; d.impact) var startEnd = d3.extent(incomingData, d =&gt; d.tweetTime) var timeRamp = d3.scaleTime().domain(startEnd).range([ 50, 450 ]); var yScale = d3.scaleLinear().domain([ 0, maxImpact ]).range([ 0, 460 ]); var radiusScale = d3.scaleLinear() .domain([ 0, maxImpact ]) .range([ 1, 20 ]); d3.select(\"svg\").selectAll(\"circle\") .data(incomingData, JSON.stringify) .enter().append(\"circle\") .attr(\"r\", d =&gt; radiusScale(d.impact)) .attr(\"cx\", d =&gt; timeRamp(d.tweetTime)) .attr(\"cy\", d =&gt; 480 - yScale(d.impact)) .style(\"fill\", \"#75739F \") .style(\"stroke\", \"black\") .style(\"stroke-width\", \"1px\"); var filteredData = incomingData.filter(d =&gt; d.impact &gt; 0) d3.selectAll(\"circle\") .data(filteredData, d =&gt; JSON.stringify(d)) .exit() .remove();&#125;以上代码，会将影响因子不大于0的元素移除。如果使用转化为字符串的对象，改变数据的话将不起作用，因为它不再与原始绑定的字符串相关。如果计划做重要的改变和更新，数据对象需要一个唯一ID作为绑定键值。 文档驱动设计及交互D3v4 有几个方法帮助DOM上下移动：selection.raise 和 selection.lower. 使用这些方法来移动选择的元素到DOM兄弟节点的末尾或者移动到开头位置。 12d3.select(\"g.overallG\").raise()d3.select(\"g.overallG\").lower() 禁用元素的鼠标事件： 1teamG.select(\"text\").style(\"pointer-events\",\"none\"); 使用颜色d3.rbg()的使用如下： 1234teamColor = d3.rgb(\"red\");teamColor = d3.rgb(\"#ff0000\");teamColor = d3.rgb(\"rgb(255,0,0)\");teamColor = d3.rgb(255,0,0); 这些颜色对象有两个有用的方法：.darker() 和 .brighter()，返回比初始值更亮或更暗的值。 123d3.selectAll(\"g.overallG\").select(\"circle\") .style(\"fill\", p =&gt; p.region === d.region ? teamColor.darker(.75) : teamColor.brighter(.5)) d3.hsl, d3.lab, d3.cubehelix, d3.hcl可以呈现不同的颜色空间D3支持颜色插值 123var ybRamp = d3.scaleLinear() .interpolate(d3.interpolateHsl) .domain([0,maxValue]).range([\"yellow\", \"blue\"]); 离散颜色比例尺：d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, and d3.schemeCategory20c序数比例尺，映射离散值为特殊的颜色。一个有用的特征是它的unknown方法，当传入一个不存在的值的时候，返回灰色值。 1234var tenColorScale = d3.scaleOrdinal() .domain([\"UEFA\", \"CONMEBOL\"]) .range(d3.schemeCategory10) .unknown(\"#c4b9ac\") 预生成内容图片使用insert()替代append()，是告诉D3在文本元素前面嵌入图片，使得标签文字在新添加的图片后被绘制。 1234d3.selectAll(\"g.overallG\").insert(\"image\", \"text\") .attr(\"xlink:href\", d =&gt; `images/$&#123;d.team&#125;.png`) .attr(\"width\", \"45px\").attr(\"height\", \"20px\") .attr(\"x\", -22).attr(\"y\", -10) SVG1234567891011d3.html(\"resources/icon_1907.svg\", loadSVG);function loadSVG(svgData) &#123; d3.selectAll(\"g\").each(function() &#123; var gParent = this; d3.select(svgData).selectAll(\"path\").each(function() &#123; gParent.appendChild(this.cloneNode(true)) &#125;); &#125;);&#125;;d3.selectAll(\"path\").style(\"fill\", \"#93C464\") .style(\"stroke\", \"black\").style(\"stroke-width\", \"1px\"); 效果图 参考资料 D3 js in action","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://www.haoming.fun/categories/数据可视化/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://www.haoming.fun/tags/D3-js/"}],"author":"Peng Fang"},{"title":"HTTPS证书及Nginx配置相关","slug":"HTTPS证书及Nginx配置相关","date":"2018-06-08T10:11:00.000Z","updated":"2019-06-30T04:11:36.659Z","comments":true,"path":"2018/06/08/HTTPS证书及Nginx配置相关/","link":"","permalink":"https://www.haoming.fun/2018/06/08/HTTPS证书及Nginx配置相关/","excerpt":"","text":"本文档包括：Nginx支持HTTPS，自签名证书生成，配置Nginx支持HTTPS，客户端证书导入。作者：方鹏 Nginx安装SSL模块 安装依赖包 1yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel 执行编译解压安装包，进入目录，执行命令： 12./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake install 自签名证书生成 [root@vultr ~]# openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout bcp.key -out bcp.crt Generating a 2048 bit RSA private key ...................................................&gt; ................................+++ ....................+++ writing new private key to &apos;bcp.key&apos; ------ You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &apos;.&apos;, the field will be left blank. Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:SICHUAN Locality Name (eg, city) [Default City]:CHENGDU Organization Name (eg, company) [Default Company Ltd]:MIGU Organizational Unit Name (eg, section) []:TSG Common Name (eg, your name or your server&apos;s hostname) []:10.146.50.22 #注意：这里填服务端的IP地址 Email Address []:fangpeng@address.cn 配置Nginx支持HTTPS12345678910111213141516171819202122# HTTPS server server &#123; listen 443 ssl; server_name localhost; ssl on; ssl_certificate /usr/local/nginx/key/bcp.crt; #证书文件存放路径 ssl_certificate_key /usr/local/nginx/key/bcp.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:8080/; #后端服务地址 proxy_redirect off; &#125; &#125; 客户端证书导入如果在调用服务的客户端没有导入自签名证书，那么可能在接口调用时会出现如下错误： 12sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 导入证书： 1keytool -import -alias $&#123;alias&#125; -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -file $&#123;path-to-certificate-file&#125; 12cd $&#123;JAVA_HOME&#125;/jre/lib/security/sudo keytool -import -alias 5022-cert -keystore cacerts -file ~/server.crt server.crt：服务端自签名的证书文件keystore密码：默认changit如果导入过证书，alias相同，会出现错误提示：Certificate not imported, alias &lt;xxx&gt; already exists.从keystone删除证书： 1sudo keytool -delete -keystore cacerts -alias &apos;bcp-cert&apos; 导入后调用依然出现异常： 1javax.net.ssl.SSLException: Certificate for XXX doesn&apos;t match common name of the certificate subject: XXX 原因：需要连接服务器的域名或IP和证书中的common name不一致。重新生成证书，Common Name 填服务器IP。 证书文件也可以通过命令请求远端站点获取 获取远程网站（服务器）的根证书和中间证书 1openssl s_client -showcerts -connect 10.146.50.22:443 保存证书文件保存证书hash（上图中包含–BEGIN CERTIFICATE–到–END CERTIFICATE–部分）为文件，例如server.crt 证书导入keystore使用keytool import 命令导入根证书和中间证书到JAVA信任的根证书中（通常叫cacerts) 1sudo keytool -importcert -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -storepass changeit -file ~/server.crt -alias &quot;5022-cert&quot; 证书添加到keystore参考文章","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.haoming.fun/categories/Nginx/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.haoming.fun/tags/HTTPS/"}],"author":"Peng Fang"},{"title":"从接口调用安全考虑","slug":"从接口调用安全考虑","date":"2018-05-17T10:09:00.000Z","updated":"2019-06-30T04:11:36.666Z","comments":true,"path":"2018/05/17/从接口调用安全考虑/","link":"","permalink":"https://www.haoming.fun/2018/05/17/从接口调用安全考虑/","excerpt":"","text":"在数据通信时，需要考虑接口访问的合法性和安全性： 用户身份的合法性校验 接口调用的合法性校验 敏感数据加密 用户身份的合法性校验用户身份校验一般通过用户名和密码。这里要考虑明文如何加密为密文。具体应用中RSA加密比较常见。RSA的密钥n长度一般是1024位，长度越长就越难被破解，目前被破解最长的RSA密钥是768位。 n能分解为两个质数的乘积，即n = p * q,这样我们就可以计算出欧拉函数φ(n) = (p-1)*(q-1) 随机选择一个整数e，条件是1&lt; e &lt; φ(n)且与φ(n)互为质数 计算模反元素d，使得ed被φ(n)除的余数为1。如果n能被因数分解，那么d可以被算出，意味着私钥被破解。加密的公钥是(n,e)，解密的私钥是(n,d)用户合法性认证以后，在整个会话过程中，必须携带服务端返回的令牌token，以保证会话的合法性。 接口调用的合法性校验为了防止接口调用中，参数被篡改或者防止重放攻击，需要在参数中加上签名。在参数中可以加上imei(设备唯一Id)、timestamp，以确保签名sign的唯一性。sign=md5(path?query&amp;imei&amp;tamp&amp;SIGN_KEY)服务端接收到请求后，首先根据参数和SIGN_KEY验证签名结果是否一致，然后验证时间戳是否是在一定时间范围内，比如5分钟之内，如果超过则视为无效请求，如果在时间范围内，需要检查签名是否存在Redis中以防止重放攻击，如果不存在则存入Redis中5分钟。因为签名的唯一性，如果Redis中已存在相同的签名，那么很可能是重放攻击。 敏感数据加密HTTP协议通信是不安全的，敏感数据传输采用基于SSL的HTTPS会更安全。另外敏感数据最好加密（加盐）传输，防止被篡改。 参考如何确保服务端的接口调用安全","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://www.haoming.fun/categories/系统设计/"}],"tags":[{"name":"接口设计","slug":"接口设计","permalink":"https://www.haoming.fun/tags/接口设计/"}],"author":"Peng Fang"},{"title":"常见的Web安全漏洞介绍及解决办法","slug":"常见的Web安全漏洞介绍及解决办法","date":"2017-08-14T10:01:00.000Z","updated":"2019-06-30T04:11:36.668Z","comments":true,"path":"2017/08/14/常见的Web安全漏洞介绍及解决办法/","link":"","permalink":"https://www.haoming.fun/2017/08/14/常见的Web安全漏洞介绍及解决办法/","excerpt":"","text":"本文对常见的Web漏洞的原因、关注点、解决办法做简要介绍，整理自Web安全培训笔记。 SQL注入解决办法：参数化查询 失效的身份认证和会话管理 原因：Session相关的数据没有被完整替换导致的安全问题 关注点：Login通过后，立刻把当前Session（包含Session、Cache、Cookie）失效掉，把需要保持到Session的value重新开一个Session保存；Logout功能中，除了把当前Session失效掉外，还要把Session相关的Cache也remove掉。 登录: 登录验证通过后，要把Session.Abort()，再保存新值 注销：Session要Abort，相关缓存要clear，额外的cookie也有被clear | XSS（跨站脚本） 简介：XSS是指攻击者利用网站程序对用户输入过滤不足，输入可以显示子在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 关注点：HTML输入输出编码、JavaScript的编码、URL的编码 解决办法：对用户输出的数据要过滤特殊字符，对输出到客户端的数据也要过滤特殊字符。HTML、js、URL过滤方法不同。js中使用escape函数来过滤特殊字符，包括元素value、元素Attribute，都有encode起来，相关函数有escape、encodeURI、encodeURIComponent。PHP中有htmlspecialchars 函数。下面是js中特殊字符编码的一种写法：1234567891011function escapeHtml(text) &#123; var map = &#123; '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '\"': '&amp;quot;', \"'\": '&amp;#039;' &#125;; return text.replace(/[&amp;&lt;&gt;\"']/g, function(m) &#123; return map[m]; &#125;);&#125; 另外一种办法是增加cookie安全：启用httponly和secure secure属性是防止信息在传递的过程中被监听捕获后信息泄漏。当设置为true时，表示创建的cookie会被以安全的形式向服务器传输，也就是只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以不会被窃取到cookie的具体内容。HttpOnly属性不允许通过脚本访问cookie，只能用于传输，目的是防止程序获取cookie后进行攻击。 敏感数据暴露 原因：敏感信息需要加密保存（内存、数据库、客户端中）+加密传输（HTTPS）+不缓存（只是尽量，看情况） 解决关注点：登录、付款这样的页面要用HTTPS保护传输。密码可采用单向加密，信用卡账号采用可逆的加密方式。 Base64算法：Base64只是一种编码方式，并不是一种加密算法，不要使用Base64来加密数据。 Hash算法：具有不可逆性是一种单向密码体制，只能加密不能解密，可以用来加密用户登录密码等凭证。有的开源项目采用md5加盐的方式加密如md5(md5(pwd)+salt)，但是不建议使用MD5等算法，MD5可用因子碰撞暴力破解，建议采用SHA-256算法。不要使用哈希函数作为对称加密算法的签名，字符串串接后再做哈希要注意（URL签名）。 对称加密：加解密使用同一个密钥，计算耗时短，通常用来加密数据。推荐使用AES算法 非对称加密：加解密使用不同的密钥，计算耗时长，通常利用来加密密钥。注意密钥长度不要低于512，建议2048位的密钥长度。 为了确保安全性，有时多种加密算法混合使用。如非对称-&gt;hash-&gt;对称 CSRF（跨站请求伪造）利用合法用户的身份，在合法用户的终端调用请求。解决关注点：重要操作不用使用get方式，要使用post方式；为每个能进行post动作的form增加token，并且在服务端检查token的合法性，合法则进行操作。正确的防御方式： 第一步，新建CSRF令牌添加进用户每次登陆以及存储在httpsession里，这种令牌至少对每个用户会话应是唯一的，或者是对每个请求是唯一的。 第二步，令牌可以包含在URL中或作为一个URL参数记/隐藏字段。 第三步，在服务器端检查提交令牌与用户会话对象令牌是否匹配。 第四步，在注销和会话超时，删除用户对象会话和会话销毁。 未验证的重定向和转发原因：当系统接受重定向参数，如http://www.a.com/login.aspx?returnUrl=default.aspx，只要修改只要修改这个url为http://www.a.com/login.aspx?returnUrl=http://wwv.a.com/login.aspx，这样会被重定向到假冒站点的login界面，用户再次输入密码，此时密码就被假冒站点保存起来了。解决关注点：对于returnUrl这种参数值进行判断，只要在白名单中的url才能redirect，尽量使用相对路径来redirect。 会话安全 Session会话ID要足够长足够随机 认证用户后应开启一个全新的用户ID 限制会话闲置时间 限制会话生命周期 允许用户自行注销会话 会话结束后清除数据 安全基础应当在完全不信任用户输入和客户端提交的数据的前提下开发应用程序。 输入验证 集中式输入验证 服务器端输入验证 建议采用白名单放弃黑名单 验证输入长度、格式、字符合法性等 验证所有的输入 防范元字符攻击 防范元字符攻击 SQL注入 跨站脚本 路径操纵 命令注入 日志欺骗 数据库连接安全 使用参数化SQL语句 数据库中的数据也是不可信的 确保数据库资源能够被释放 减少编码逻辑漏洞执行操作时需要权限判断 文件安全严格控制文件上传 文件类型验证（白名单验证） 存储路径安全（把握原则：可执行目录不可写，可写目录不可执行） 防范rar压缩炸弹 限制文件大小 严格分配文件访问权限策略安全的临时文件访问竞争条件开发调试日志 集中日志记录 使用时间戳 记录每个重要行为 保护日志文件 调试 上线产品删除调试代码 产品中不包含后门代码 清除备份和调试文件 错误日志错误处理 保证整个团队使用一个共同的异常处理方法 禁用或限制详细错误处理信息（可以暴露错误状态码，而错误详细信息不应被暴露） 多个错误同一时间内返回相似或同样的出错信息 各种应用层会返回错误或异常结果 有必要创建一个默认的错误处理机 可以用总是返回“200”错误代码来覆盖默认的错误输出 不安全的加密存储 不要自己创建加密算法。 应使用已经被证明的公开加密算法，例如AES，RAS公钥加密，和SHA-256或更好的HASH算法。 不要使用弱加密算法，比如MD5/SHA1。 建议使用更安全的加密算法，比如SHA-256或更其它的选择。 不安全的通讯 对所有传输认证或传输数据的连接启用SSL 确保web服务器和数据库之间的通讯安全恰当的加密 限制敏感数据的生命周期问题 使用对象来存储敏感数据，但使用后没清除或回收 具有可以被操作系统按需交换到磁盘的内存页面 在缓冲区中有敏感数据 使用了一些反射机制来控制敏感数据 通过调试信息、日志文件、环境变量等方式暴露敏感数据 不要在客户端存储未经加密的数据确保安全敏感方法被调用时参数经过验证不要使用不安全的弱加密算法身份鉴别用户ID管理 用户名是唯一的 注册判断重命等逻辑放在服务器端 Insert之前判断用户名是否存在 密码管理 密码长度不小于8个字符密码至少包含大小写字母、数字及特殊符号。密码与账户名不同存储过程中不能使用明文以及不安全的存储在密码传输工程中不能使用明文，短信验证码设置有效期输入密码时不显示密码管理账户没弱口令，删除测试账户 认证限制 用户身份认证尝试超限锁定功能如果用户名易被猜测，对同一ip多次认证失败锁定认证期间不透露用户ID是否存在关键系统双因子认证认证需要采用有效挑战应答机制 注意的漏洞 Struts2框架任意代码执行 Java反序列化化漏洞 容错处理不当致信息泄露 mybatis(ibatis)框架存在的SQL注入，正确的写法： 1select * from user where username like concat('%',#username#,'%') mybatis框架$存在的SQL注入尽量使用#描述参数，如果一定要使用$，则需要自己过滤用户输入。因为使用$参数MyBatis不会修改或转义字符串。 Hibernate存在的SQL注入正确的写法： 名称绑定 12String queryString = \"from Item item where item.description like :searchString and item.date &gt; :minDate\";List result = session.createQuery(queryString).setString(\"searchString\", searchString).setDate(\"minDate\", minDate).list(); 位置绑定 12String queryString = \"from Item item where item.description like ? and item.date &gt; ?\";List result = session.createQuery(queryString).setString(0, searchString).setDate(1, minDate).list();","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.haoming.fun/categories/Web安全/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.haoming.fun/tags/Web安全/"}],"author":"Peng Fang"},{"title":"Linux下离线安装node和npm","slug":"Linux下离线安装node和npm","date":"2017-08-10T09:56:00.000Z","updated":"2019-06-30T04:11:36.663Z","comments":true,"path":"2017/08/10/Linux下离线安装node和npm/","link":"","permalink":"https://www.haoming.fun/2017/08/10/Linux下离线安装node和npm/","excerpt":"","text":"本文记录在Linux环境下怎样离线安装node和npm环境。 上传安装包到服务器 从Download Node.js and npm下载Linux Binaries可运行uname -a查看系统的位数，如x86_64为64为系统。先上传安装包到FTP，用root账号登录服务器后从FTP下载安装包 执行安装命令 解压安装包到想要安装node的目录 1234sudo mkdir /usr/lib/nodejssudo tar -xJvf node-v8.2.1-linux-x64.tar.xz -C /usr/lib/nodejscd /usr/lib/nodejssudo mv node-v8.2.1-linux-x64/ node-v8.2.1 设置环境变量设置环境变量vi ~/.profile，在最后添加下面的shell命令 123# Nodejsexport NODEJS_HOME=/usr/lib/nodejs/node-v8.2.1export PATH=$NODEJS_HOME/bin:$PATH 执行source ~/.profile使环境变量生效 创建软链接配置了环境变量，有可能出现npm命令找不到的情况。我的办法是添加软链接：123sudo ln -s /usr/lib/nodejs/node-v8.2.1/bin/node /usr/bin/nodesudo ln -s /usr/lib/nodejs/node-v8.2.1/bin/node /usr/lib/nodesudo ln -s /usr/lib/nodejs/node-v8.2.1/bin/npm /usr/bin/npm 注意在Windows下运行过npm install安装了node组件的，到Linux下面删除node_components目录重新运行npm install。 测试安装执行下面的命令测试安装是否成功1node -v 这里输出： v8.2.1 1npm version 这里输出： { &apos;vue-riskaudit&apos;: &apos;1.0.5&apos;, npm: &apos;5.3.0&apos;, ares: &apos;1.10.1-DEV&apos;, cldr: &apos;31.0.1&apos;, http_parser: &apos;2.7.0&apos;, icu: &apos;59.1&apos;, modules: &apos;57&apos;, node: &apos;8.2.1&apos;, openssl: &apos;1.0.2l&apos;, tz: &apos;2017b&apos;, unicode: &apos;9.0&apos;, uv: &apos;1.13.1&apos;, v8: &apos;5.8.283.41&apos;, zlib: &apos;1.2.11&apos; }","categories":[{"name":"环境安装","slug":"环境安装","permalink":"https://www.haoming.fun/categories/环境安装/"}],"tags":[{"name":"前端环境","slug":"前端环境","permalink":"https://www.haoming.fun/tags/前端环境/"}],"author":"Peng Fang"},{"title":"基于VUE+VUEX+ELEMENT-UI的项目结构","slug":"基于VUE-VUEX-ELEMENT-UI的项目结构","date":"2017-07-31T09:54:00.000Z","updated":"2019-06-30T04:11:36.667Z","comments":true,"path":"2017/07/31/基于VUE-VUEX-ELEMENT-UI的项目结构/","link":"","permalink":"https://www.haoming.fun/2017/07/31/基于VUE-VUEX-ELEMENT-UI的项目结构/","excerpt":"","text":"分析了石头哥的VUE模板工程（基于VUE+VUEX+ELEMENT-UI）的项目结构，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364mock-server // 模拟数据| api.json // 配置请求响应的数据| server.js // mock数据响应node_modules // 组件安装存放目录src // 源文件目录|---actions // 分模块定义接口调用| | articles.js| | index.js| | root.js|---components // 组件| | Select.vue| | Table.vue|---constants // 定义一些常量| | actions.js| | api.js|---containers // 页面| | Article.vue|---layouts // 布局 |---css |---core | | base.less | | common.less | | font.less | | index.less | | normalize.less | | reset.less |---mixins | | compatibility.less | | iconfont.less | | index.less | | opacity.less | | size.less |---themes | | default.less index.less |---fonts |---antd | | iconfont.eot | | iconfont.svg // ... |---img|---mutations // 更改state| | article.js| | index.js| | root.js|---plugins| | element.js // 注册需要的element组件|---store| | index.js // 创建Vuex的Store实例|---utils| | api.js // 暴露一些请求Api以及createAction方法| | misc.js // 公用方法| App.vue // 主页| index_dev.html // 开发环境的首页| index_prod.html // 生产环境的首页| root.js // 入口文件，创建Vue实例| router.js // 创建VueRouter实例.babelrc babel配置文件.editorconfig IDE编辑器配置文件package-lock.json npm更改操作自动生成package.json 项目相关的各种元数据(依赖的模块)proxy.js 配置代理webpack.config.js 根据是否是生产环境设置webpack的配置文件webpack.dev.config.js 开发环境配置文件webpack.prod.config 生产环境配置文件","categories":[{"name":"vue","slug":"vue","permalink":"https://www.haoming.fun/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.haoming.fun/tags/vue/"}],"author":"Peng Fang"},{"title":"webpack中文文档摘要","slug":"webpack中文文档摘要","date":"2017-07-31T09:49:00.000Z","updated":"2019-06-30T04:11:36.663Z","comments":true,"path":"2017/07/31/webpack中文文档摘要/","link":"","permalink":"https://www.haoming.fun/2017/07/31/webpack中文文档摘要/","excerpt":"","text":"首先给出webpack中文文档的地址这是我目前见过的翻译最好的webpack文档，清晰明了。 webpack在webpack之前，前端开发人员会使用grunt和gulp等工具来处理资源，并将它们从/src文件夹移动到/dist或/build目录中。同样的方式也被用于Javascript模块。但是像webpack这样的工具，将动态打包所有的依赖项（创建所谓的依赖图），避免打包未使用的模块。webpack最出色的功能之一就是除了JavaScript，还可以通过loader因人员任何其他类型的文件。webpack打包命令默认选择使用一个配置文件叫webpack.config.js，改文件存在于根目录下。配置文件具有更强的灵活性，我们可以通过配置方式指定loader规则(loader rules)、插件(plugins)、解析选项(resolve options)，以及许多其他增强功能。初始化npm (npm init -y)会生成一个package.json，其中可以配npm 脚本和项目所需的依赖等。使用npm的scripts，我们可以通过模块名，来引用本地安装的npm包，而不是写出完整路径。例如： 1234567&#123; ... \"scripts\": &#123; \"build\": \"webpack\" &#125;, ...&#125; 我们直接调用webpack这样的别名，而不是去调用./node_modules/.bin/webpack通过向npm run build命令和我们的参数之间添加两个中横线，可以将自定义参数传递给webpack，例如: npm run build – –colors 管理输出加载CSS为了从JavaScript模块中import一个css文件，你需要在webpack.config.js的module配置中安装并添加style-loader和css-loader。webpack根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的loader。这样可以在依赖此样式的文件中import某个样式文件，当模块运行时，含有CSS字符串的&lt;style&gt;标签将被插入到HTML文件的&lt;head&gt;中。 可以生产环境中进行CSS分离达到节省加载时间的目的。 加载图片试想下载CSS的时候，如果其中有图片文件，那要如何处理呢？使用file-loader可以轻松地将内容混合到CSS中。当我们import oneImage from ‘./my-image.png’，该图像将被处理并添加到output目录，并且oneImage变量将包含该图片名在被处理后的最终URL。例如当使用css-loader， css中url(‘./my-image.png’)中的路径被替换为输出目录中图片的最终路径。 查看image-webpack-loader和url-loader了解压缩和优化图像等功能。 加载字体file-loader和url-loader可以接收并加载任何文件，然后将其输出到构建目录，当然也包括字体文件。 加载数据数据文件一般包含JSON文件、CSV、TSV和XML。类似于NodeJS，JSON支持实际上是内置的，import一个json文件默认将正常运行。我们可以使用csv-loader和xml-loader来处理其余三类文件，csv-loader处理csv和tsv。这样import四类文件中的任何一类，所导入的变量将包含可直接使用的已解析JSON 在使用d3等工具来实现某些数据可视化时，预加载数据会非常有用。构建过程中将数据提前载入并打包到模块中，以便浏览器加载模块后，可以立即从模块中解析数据。 全局资源上述内容最出色之处是，以这种方式加载资源，可以更直观地将模块和资源组合在一起，无需依赖于含有全部资源的/asset目录，而是将资源与代码组合在一起。例如：类似这样的结构非常有用： 123456+ |– /components+ | |– /my-component+ | | |– index.jsx+ | | |– index.css+ | | |– icon.svg+ | | |– img.png 这种配置方式会使你的代码更具备可移植性，现有统一放置的方式会造成所有资源紧密耦合在一起。假如在想在另一个项目中使用/my-component，只需将其复制或移动到/components目录下。只要你安装了扩展依赖，并且配置过相同的loader，那么项目应该可以良好运行。但是这样的缺点是无法使用新的开发方式或者在多个组件之间共享资源。仍然可以将这些资源存储在公共目录中，甚至配合使用alias来使它们更方便导入。","categories":[{"name":"webpack","slug":"webpack","permalink":"https://www.haoming.fun/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.haoming.fun/tags/webpack/"}],"author":"Peng Fang"},{"title":"利用travis自动化部署博客项目","slug":"利用travis自动化部署博客项目","date":"2017-07-25T09:36:00.000Z","updated":"2019-06-30T04:11:36.666Z","comments":true,"path":"2017/07/25/利用travis自动化部署博客项目/","link":"","permalink":"https://www.haoming.fun/2017/07/25/利用travis自动化部署博客项目/","excerpt":"","text":"目的本文记录如何用travis实现自动化部署GitHub仓库中的博客项目，并完成域名访问。 travis登录和授权travis可以用GitHub账号登录，登录后在profile页授权允许travis访问的仓库。 比如我这里的GitHub仓库是vue-ghpages-blog，也是我准备部署的博客项目。 GitHub pages的一点概念搭建项目站点的两种方式： 一种是创建一个名为 GitHub用户名.github.io的仓库，在外网以该仓库名作为地址进行访问就可以访问到仓库里面的静态页面了。另一种是给仓库创建一个gh-pages分支，将运行npm run build命令编译生成到项目dist目录下的文件push到gh-pages分支。访问GitHub用户名.github.io/仓库名如https://github.com/MGTfang/vue-ghpages-blog，也能访问到编译项目生成的静态文件。 travis自动化部署的条件在授权travis访问仓库（项目）的前提下，还需要在仓库的根目录下有个.travis.yml文件，部分内容如下： 1234567891011121314151617script: - npm testafter_success: - npm run build - cd dist - echo \"dtechvoi.com\" &gt; CNAME - cp index.html 404.html - git add --all . - git commit --message \"Automatically update from travis-ci\" - git push --quiet \"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\" gh-pages:gh-pages# Note: you should set Environment Variables here or 'Settings' on travis-ci.orgenv: global: - GH_REF: github.com/MGTfang/vue-ghpages-blog.git # - GH_TOKEN: 'Your GitHub Personal access tokens, via https://github.com/settings/tokens' 当将更改的文件push到远端仓库（这里是vue-ghpages-blog的develop分支）的时候，travis会自动执行一次build，build操作根据.travis.yml内容来进行。例如根据上面的脚本（有部分省去了），先设置环境变量GH_REF、GH_TOKEN，再更新nvm，运行npm install、npm test。 我这里报错：没有找到electron这个包，因此运行`npm install electron --save`进行安装 在`npm run test`成功以后，会将build生成的文件推送到gh-pages分支。 这里可能会出现没权限访问远端仓库的error，这样需要通过`https://github.com/settings/tokens`来设置访问token，特别主要要将repo勾选，不然照样没有权限。 域名绑定在域名的解析设置下添加三条记录： 记录类型 主机记录 解析线路(运营商) 记录值 CNAME @ 默认 MGTfang.github.io. A www 默认 192.30.252.153 A www 默认 192.30.252.154 包括两条A记录和一条CNAME记录，A记录指向以www开头的域名，记录值是GitHub的IP地址，CNAME的记录值是可以访问GitHub pages的地址。除了绑定域名，还需要在访问仓库额根目录下创建一个CNAME文件，并在其中写入绑定的域名，这样直接访问域名就能访问gh-pages分支下的静态页面。","categories":[{"name":"博客","slug":"博客","permalink":"https://www.haoming.fun/categories/博客/"}],"tags":[{"name":"自动化部署 博客","slug":"自动化部署-博客","permalink":"https://www.haoming.fun/tags/自动化部署-博客/"}],"author":"Peng Fang"}]}