<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青桥雨之木芳</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.haoming.fun/"/>
  <updated>2020-02-08T10:55:58.128Z</updated>
  <id>https://www.haoming.fun/</id>
  
  <author>
    <name>Peng Fang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>客户端字体放大问题解决</title>
    <link href="https://www.haoming.fun/2020/02/08/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%97%E4%BD%93%E6%94%BE%E5%A4%A7%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://www.haoming.fun/2020/02/08/客户端字体放大问题解决/</id>
    <published>2020-02-08T10:38:00.000Z</published>
    <updated>2020-02-08T10:55:58.128Z</updated>
    
    <content type="html"><![CDATA[<p>华为手机，或者苹果手机能设置手机端的字体大小，字体大小的变动就足以导致页面布局乱掉，导致文本不居中、文字折行、布局混乱等问题。解决办法参考<a href="https://www.cnblogs.com/axl234/p/7753187.html" target="_blank" rel="noopener">这篇文章</a>  </p><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>用户修改手机字体设置大小，影响App里打开的web页面。</p><h4 id="Android端解决办法"><a href="#Android端解决办法" class="headerlink" title="Android端解决办法"></a>Android端解决办法</h4><p>手机字体设置大小，影响App的页面。<br>Android的可以通过webview配置webview.getSettings().setTextZoom(100)就可以禁止缩放，按照百分百显示。</p><h4 id="H5解决办法"><a href="#H5解决办法" class="headerlink" title="H5解决办法"></a>H5解决办法</h4><p>Android因为改变的是字体的大小，所以可以考虑将字体大小在设置的时候进行等比例缩小。例如，一个文字希望以10px来进行渲染，当webview被放大两倍时，此时font-size会变为20px。因此我们可以在取到这个放大比例之后，对原样式进行等比缩小，比如将原文字大小设置为5px，渲染的时候就变成了10px。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机字体放大或缩小的情况，恢复根字体的大小</span></span><br><span class="line"><span class="keyword">let</span> $dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">$dom.style = <span class="string">'font-size:16px;'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($dom);</span><br><span class="line"><span class="comment">// 计算出放大后的字体大小</span></span><br><span class="line"><span class="keyword">const</span> scaledFontSize = <span class="built_in">parseInt</span>(<span class="built_in">window</span>.getComputedStyle($dom, <span class="literal">null</span>).getPropertyValue(<span class="string">'font-size'</span>));</span><br><span class="line"><span class="built_in">document</span>.body.removeChild($dom);</span><br><span class="line"><span class="comment">// 计算原字体和放大后字体的比例</span></span><br><span class="line"><span class="keyword">const</span> scaleFactor = <span class="number">16</span> / scaledFontSize;</span><br><span class="line"><span class="comment">// 获取当前已经缩放的根元素字体大小</span></span><br><span class="line"><span class="keyword">const</span> originRootFontSize = <span class="built_in">parseInt</span>(<span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.documentElement, <span class="literal">null</span>).getPropertyValue(<span class="string">'font-size'</span>));</span><br><span class="line"><span class="comment">// 乘以scaledFontSize是原来的html字体大小</span></span><br><span class="line"><span class="comment">// 再次乘以scaledFontSize是为了经过手机缩放后显示为想要的大小</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = originRootFontSize * scaleFactor * scaleFactor + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p>通过改变根元素字体来影响文档中元素字体大小的方法，对字体单位是rem的才有效。因此如果字体单位是vw，该方法并不能一劳永逸。这里能想到的办法是讲显示错乱的地方的字体单位vw转换成rem。怎样转换比较方便呢？我们采用的是less这个css预编译处理语言，能不能写一个单位转换的方法，在less 中调用呢？在网上找到了<a href="https://blog.csdn.net/weixin_34146986/article/details/91430581" target="_blank" rel="noopener">一篇文章</a>，结合这篇文章，我们这里的实现是这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.remMixin</span>() &#123;</span><br><span class="line">    @functions: ~`(function() &#123;</span><br><span class="line">        var clientWidth = 375;</span><br><span class="line">        <span class="selector-tag">function</span> <span class="selector-tag">convert</span>(<span class="selector-tag">size</span>) &#123;</span><br><span class="line">            return typeof size === 'string' ?</span><br><span class="line">                +size.replace('px', '').replace('vw', '') : size;</span><br><span class="line">        &#125;</span><br><span class="line">        this.rem = function(size) &#123;</span><br><span class="line">            return (convert(size) / 16).toFixed(3) + 'rem';</span><br><span class="line">        &#125;</span><br><span class="line">        this.vw2rem = function(size) &#123;</span><br><span class="line">            return this.rem(convert(size) * clientWidth / 100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()`;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.remMixin</span>();</span><br></pre></td></tr></table></figure><p>这里对less 的一个语法进行介绍：为了表示Javascript，必须用反引号包装代码。执行此操作时，Less讲计算表达式并讲结果作为字符串返回。它做到了“原样”返回。因此如果返回的是字符串的话，会带有引号。如果想将返回结果中的引号删除，可以在反引号前加上波浪号。<br>实际使用的时候，比如设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-size: ~`vw2rem(&apos;3.2vw&apos;)`;</span><br></pre></td></tr></table></figure><p>经过转换后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-size: 0.75rem;</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/axl234/p/7753187.html" target="_blank" rel="noopener">https://www.cnblogs.com/axl234/p/7753187.html</a><br><a href="https://blog.csdn.net/weixin_34146986/article/details/91430581" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34146986/article/details/91430581</a><br><a href="https://www.bennadel.com/blog/2638-executing-javascript-in-the-less-css-precompiler.htm" target="_blank" rel="noopener">https://www.bennadel.com/blog/2638-executing-javascript-in-the-less-css-precompiler.htm</a>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;华为手机，或者苹果手机能设置手机端的字体大小，字体大小的变动就足以导致页面布局乱掉，导致文本不居中、文字折行、布局混乱等问题。解决办法参考&lt;a href=&quot;https://www.cnblogs.com/axl234/p/7753187.html&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="移动端开发" scheme="https://www.haoming.fun/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>【工作杂记】20200204</title>
    <link href="https://www.haoming.fun/2020/02/08/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%9D%82%E8%AE%B0%E3%80%9120200204/"/>
    <id>https://www.haoming.fun/2020/02/08/【工作杂记】20200204/</id>
    <published>2020-02-08T09:58:00.000Z</published>
    <updated>2020-02-08T10:55:13.815Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>获取根节点font size   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getComputedStyle(<span class="built_in">window</span>.document.documentElement).[<span class="string">'font-size'</span>]</span><br></pre></td></tr></table></figure></li><li><p>设置根节点font size  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(&quot;html&quot;)[0].style.cssText = &apos;font-size: 16px&apos;;</span><br><span class="line">document.getElementsByTagName(&quot;html&quot;)[0].style.fontSize= 16px&apos;;</span><br><span class="line">document.documentElement.style.fontSize = &apos;16px&apos;</span><br></pre></td></tr></table></figure></li><li><p>项目乱码<br>如果某个项目或者某个文件出现中文乱码现象，项目或者文件上右键选择Properties（配置文件）——&gt;Resource,右边找到Text File encoding选项，选择Other，里面有几种编码方式可供选择，选择何时的编码方式(一般是UTF—8或者GBK)，然后Apply就OK了。</p></li><li><p>构建Java项目<br>选中项目，右键选择 run as  -&gt; maven build…<br>填写 maven 命令：<code>clean install assembly:assembly</code><br>或者 尝试命令：<code>mvn package assembly:assembly -Dmaven.test.skip=true -U -B</code><br>执行完在target目录会生成tar包。<br><img src="https://www.haoming.fun/images/WX20200208-181451.png" alt="maven build"></p></li><li><p>执行错误<br><code>·Fatal error compiling: tools.jar not found: C:\Program Files\Java\jre-8u111\..\lib\tools.jar</code><br>Preference —&gt; Java -&gt; Installed JREs -&gt; click Add button -&gt; Standard VM -&gt; click Directory button -&gt; 选择jdk 下的jre: C:\Program Files\Java\jdk1.8.0_131\jre</p></li><li><p>安装 Java 环境（JDK 1.8）<br>下载jdk-8u241-linux-x64.tar.gz，拷贝到阿里云<br>创建目录<br><code>mkdir /usr/local/java/</code><br>解压至安装目录：<br><code>tar -zxvf jdk-8u241-linux-x64.tar.gz -C /usr/local/java/</code><br>编辑文件<br><code>vim /etc/profile</code><br>在末尾添加：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_241</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></li></ul><p>使环境变量生效<br><code>source /etc/profile</code><br>添加软链接<br><code>ln -s /usr/local/java/jdk1.8.0_241/bin/java /usr/bin/java</code><br>检查是否安装成功<br><code>java -version</code></p><ul><li><p>部署Java包<br>bin目录里面是启动停止脚本<br>conf目录是配置文件<br>lib目录就是jar包，后面重新部署就直接替换这一个jar包就可以了<br>修改启动脚本中的服务端口号<br><img src="https://www.haoming.fun/images/WX20200208-183025.png" alt=""><br>jvm 参数设置过大可能会在启动的时候报错，前面一部分带内存空间的参数可以删掉.<br>修改jdbc连接参数<br>创建和同步数据库<br>设置阿里云访问规则，开放端口  </p></li><li><p>运行启动脚本提示No such file or directory错误<br>shell 文件的编码造成<br>用vim打开该sh文件，输入：<br><code>:set ff</code><br>回车，显示fileformat=dos，重新设置下文件格式，输入：<br><code>:set ff=unix</code><br>保存退出:<br>:wq </p></li><li><p>访问服务时mysql出现which is not functionally dependent on columns in GROUP BY clause报错<br>编辑<code>/etc/my.cnf</code>，在文件的最后加上<br><code>sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code><br>重启服务<br><code>systemctl restart mysqld.service</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取根节点font size   &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="工作杂记" scheme="https://www.haoming.fun/tags/%E5%B7%A5%E4%BD%9C%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>H5 体验优化总结（二）</title>
    <link href="https://www.haoming.fun/2020/02/02/H5-%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.haoming.fun/2020/02/02/H5-体验优化总结（二）/</id>
    <published>2020-02-02T15:43:00.000Z</published>
    <updated>2020-02-02T15:43:58.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;本文对近期开发移动端 H5 过程中解决的体验问题进行梳理汇总。内容涉及移动端适配、网络状态监听、DOM元素位置属性的计算、与原生通信、用户行为埋点、包体积优化等。通过小的问题案例，来讲解开发中问题的解决及如何提升用户体验。如果本文有任何不确切的地方，欢迎指正！<br>&emsp;&emsp;本文分为两部分，第一部分包含页面优化、设计优化、性能优化；第二部分包含功能优化。本文内容概要如下：</p><p><img src="https://www.haoming.fun/images/20200123190647.png" alt="本文概览"></p><h2 id="网络状态监听"><a href="#网络状态监听" class="headerlink" title="网络状态监听"></a>网络状态监听</h2><p>&emsp;&emsp;H5 通常需要对网络状态进行监听，比如说断网的时候，给用户一个提示，或者跳转到一个指定的提示页面。那么如何对网络状态进行监听呢？答案是可以在页面添加对<code>offline</code>事件的监听。据MDN的解释，当浏览器失去网络连接时，<code>offline</code>事件被处罚。并且<code>navigator.online</code>的值变为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    <span class="comment">// 添加断网监听</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, <span class="keyword">this</span>.pushNetworkErrorPage);</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">// 移除网络状态监听</span></span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, <span class="keyword">this</span>.pushNetworkErrorPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;断网处理是 APP 比较常见的一个场景，为了提升用户体验，在网络断开或者网络状态不好的时候，及时给出用户提升信息，或者进入到一个类似404的提示页面。我们这里采用后者，用图文来展示断网的提示信息，并且用户通过“点击重试”，可以尝试重连（刷新实际是返回上一页，该过程中如果还是断网状态，又会回到提示页）。</p><h2 id="点击展开按钮，页面自动往上"><a href="#点击展开按钮，页面自动往上" class="headerlink" title="点击展开按钮，页面自动往上"></a>点击展开按钮，页面自动往上</h2><p>&emsp;&emsp;有时候页面内容比较多，一些内容是没有展开的，即便是展开后，内容较长，屏幕长度有限，可能出现下方内容被屏幕遮挡。因此为了提升体验，需要在点击展开按钮的时候，页面能自动往上，滚动到内容区域的起始位置。<br>来看下面的实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展开的时候，滚动到顶部导航下面</span></span><br><span class="line"><span class="comment">// assessmentTableBox 的 offsetParent 是 body，offsetTop 为其到 body 的距离</span></span><br><span class="line"><span class="keyword">const</span> scrollTop = <span class="keyword">this</span>.$refs.assessmentTableBox.offsetTop - <span class="built_in">document</span>.querySelector(<span class="string">'.sticky-wrapper'</span>).clientHeight - <span class="number">40</span>; <span class="comment">// 元素距离顶部的距离 - 顶部 header 高度 - 偏移量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.documentElement.scrollTop) &#123;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了解释这段代码，首先需要了解几个基本概念：<br>&emsp;&emsp;<code>HTMLElement.offsetParent</code> 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 <code>table,td,th,body</code> 元素。如果这个容器元素未进行CSS定位, 则 <code>offsetParent</code> 属性的取值为body元素的引用。<br>&emsp;&emsp;<code>HTMLElement.offsetTop</code> 为只读属性，它返回当前元素相对于其 <code>offsetParent</code> 元素的顶部内边距的距离。<br>&emsp;&emsp;<code>clientHeight</code>它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距，此属性会四舍五入取整。<br>&emsp;&emsp;<code>Element.scrollTop</code> 属性可以获取或设置一个元素的内容垂直滚动的像素数。这里通过设置 <code>document.documentElement</code> 或者 <code>document.body</code> 设置页面向上滚动的像素数，前者返回的是文档对象的根元素通常指<code>&lt;html&gt;</code>，后者返回当前文档的<code>&lt;body&gt;</code>元素。<br>&emsp;&emsp;这里的办法是先获取到页面向上滚动的距离，这个距离scrollTop = 元素距离顶部的距离 - 顶部 header 高度 - 偏移量，然后设置文档根元素或者body元素的 <code>scrollTop</code> 使得页面向上滚动 <code>scrollTop</code> 像素的距离。</p><h2 id="下方还有内容时，给用户提示"><a href="#下方还有内容时，给用户提示" class="headerlink" title="下方还有内容时，给用户提示"></a>下方还有内容时，给用户提示</h2><p>&emsp;&emsp;有时弹窗区域下面还有内容没显示完全时，需要给用户提示，可以向下滑查看更多内容。我们这里的办法是，下方还有内容时，在最下方位置显示一个向下的有动效的箭头，当用户滚动到最下方的时候，该箭头掉转朝上。下面说说怎么实现。</p><h3 id="判断窗口内容是否可滚动"><a href="#判断窗口内容是否可滚动" class="headerlink" title="判断窗口内容是否可滚动"></a>判断窗口内容是否可滚动</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    isDisplay(nv) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nv) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> scrollDiv = <span class="keyword">this</span>.$refs.explainContent;</span><br><span class="line">                <span class="keyword">this</span>.scrollable = scrollDiv.scrollHeight &gt; scrollDiv.clientHeight;</span><br><span class="line">                <span class="keyword">this</span>.scrollable &amp;&amp; scrollDiv.addEventListener(<span class="string">'scroll'</span>, <span class="keyword">this</span>.scrollHandler);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    <span class="keyword">this</span>.scrollable &amp;&amp; <span class="keyword">this</span>.$refs.explainContent.removeEventListener(<span class="string">'scroll'</span>, <span class="keyword">this</span>.scrollHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果元素的 <code>scrollHeight</code> 大于 其<code>clientHeight</code>的话, 我们就说它的内容是可以滚动的。<br>&emsp;&emsp;<code>Element.scrollHeight</code> 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。<br>&emsp;&emsp;<code>scrollHeight</code> 的值等于该元素在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度。 没有垂直滚动条的情况下，<code>scrollHeight</code>值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。<code>scrollHeight</code>也包括 ::before 和 ::after这样的伪元素。<br>&emsp;&emsp;<code>clientHeight</code> 表示元素内部的高度(单位像素)，包含padding，但不包括元素的border和margin。</p><h3 id="判断是否滚动到底部"><a href="#判断是否滚动到底部" class="headerlink" title="判断是否滚动到底部"></a>判断是否滚动到底部</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scrollHandler(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = e.target;</span><br><span class="line">    <span class="keyword">this</span>.isScrollBottom = <span class="built_in">Math</span>.round(element.scrollHeight - element.scrollTop) === element.clientHeight ||</span><br><span class="line">                <span class="built_in">Math</span>.round(element.scrollHeight - element.scrollTop) === element.clientHeight - <span class="number">1</span>;</span><br><span class="line">&#125;,</span><br><span class="line">arrowDownClickHandler(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isScrollBottom) &#123;</span><br><span class="line">        <span class="comment">// 如果箭头朝上，点击滚到顶部</span></span><br><span class="line">        <span class="keyword">this</span>.$refs.explainContent.scrollTop = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果箭头朝下，向下滚一点</span></span><br><span class="line">        <span class="keyword">this</span>.$refs.explainContent.scrollTop = <span class="keyword">this</span>.$refs.explainContent.scrollTop + <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;判断是否滚动到元素内容的最底部，是比较元素的<code>scrollHeight</code>（不出现滚动条的最小高度）减去其内容垂直滚动的像素数与元素可视区域的高度的高度近似。</p><h3 id="箭头CSS动画"><a href="#箭头CSS动画" class="headerlink" title="箭头CSS动画"></a>箭头CSS动画</h3><p>&emsp;&emsp;效果：箭头Y方向位移，渐入渐出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.arrow-down</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">animation</span>: arrow <span class="number">1.5s</span>  ease-in-out  infinite;</span><br><span class="line">    .rotate&#123;</span><br><span class="line">        <span class="selector-tag">transform-origin</span>: <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br><span class="line">        <span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(180<span class="selector-tag">deg</span>);</span><br><span class="line">        <span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 0<span class="selector-class">.2s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> arrow &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0px)</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, -.1rem)</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, -.2rem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切换页面，显示Loading"><a href="#切换页面，显示Loading" class="headerlink" title="切换页面，显示Loading"></a>切换页面，显示Loading</h2><p>&emsp;&emsp;H5 页面的数据一般分为好几个部分组成，比如有总览，分类详情，有图表等等，每个部分通过不同的接口请求数据，如果每个接口在请求前后显示页面 Loading 转圈的话，那么转圈会显示隐藏多次。这里的解决办法是给页面加一个全局的 Loading，在路由到页面前显示，在路由到页面后关闭。这里用 Vue Router 的全局前置守卫和全局后置钩子来实现，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">loading</span> <span class="attr">v-model</span>=<span class="string">"isLoading"</span>&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Router.beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params">to, from, next</span>) </span>&#123;</span><br><span class="line">    store.commit(<span class="string">'updateLoadingStatus'</span>, &#123; <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.afterEach(<span class="function"><span class="keyword">function</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.commit(<span class="string">'updateLoadingStatus'</span>, &#123; <span class="attr">isLoading</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">500</span>); <span class="comment">// 显示时间长一点</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="设置Tooltip-坐标轴指示器十字线"><a href="#设置Tooltip-坐标轴指示器十字线" class="headerlink" title="设置Tooltip 坐标轴指示器十字线"></a>设置Tooltip 坐标轴指示器十字线</h2><p>&emsp;&emsp;Echarts Tooltip 为轴触发，且坐标轴指示器的类型为“cross”，即十字线，显示效果如下：</p><div align="center">    <img src="https://www.haoming.fun/images/20200122162331.png" width="70%" height="70%"></div>&emsp;&emsp;如果需要是不显示指示器的标签和十字轴线，我们可以这样配置Echarts 的tooltip：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tooltip: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    axisPointer: &#123; <span class="comment">// 坐标轴指示器，坐标轴触发有效</span></span><br><span class="line">        type: <span class="string">'cross'</span>, <span class="comment">// 默认为直线，可选为：'line' | 'shadow'</span></span><br><span class="line">        label: &#123;</span><br><span class="line">            color: <span class="string">'#888'</span>,</span><br><span class="line">            show: <span class="literal">false</span> <span class="comment">// 不显示坐标轴指示器标签</span></span><br><span class="line">        &#125;,</span><br><span class="line">        crossStyle: &#123;</span><br><span class="line">            opacity: <span class="number">0</span> <span class="comment">// 不显示坐标轴指示器线</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制浮标拖出页面"><a href="#限制浮标拖出页面" class="headerlink" title="限制浮标拖出页面"></a>限制浮标拖出页面</h2><p>&emsp;&emsp;页面有一个模块入口的圆形浮标，这个浮标需要支持可拖动，且拖动限制在页面内。<a href="https://github.com/desandro/draggabilly" target="_blank" rel="noopener">draggabilly</a> 能支持这个功能。可以通过 npm 来安装，使用也比较简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APP.vue</span></span><br><span class="line"><span class="keyword">import</span> draggabilly <span class="keyword">from</span> <span class="string">'draggabilly'</span>;</span><br><span class="line">Vue.prototype.$draggabilly = draggabilly;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elem = <span class="keyword">this</span>.$refs.entrance;</span><br><span class="line"><span class="keyword">const</span> draggie = <span class="keyword">new</span> <span class="keyword">this</span>.$draggabilly(elem, &#123;</span><br><span class="line">    containment: <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">draggie.on(<span class="string">'dragEnd'</span>, (event, pointer, moveVector) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="keyword">this</span>.$refs.entrance;</span><br><span class="line">    <span class="keyword">let</span> elemTop = +elem.style.top.replace(<span class="string">'px'</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elemTop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超出屏幕上边界，回到屏幕内</span></span><br><span class="line">        elem.style.top = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elem.offsetHeight + elemTop &gt; <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">        <span class="comment">// 超出屏幕下边界，回到屏幕内</span></span><br><span class="line">        elem.style.top = <span class="string">`<span class="subst">$&#123;<span class="built_in">document</span>.documentElement.clientHeight - elem.offsetHeight&#125;</span>px`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原本该插件能限制拖动的范围，但是在有的页面可能以为布局的原因，导致浮标能拖动出下方边界。为了不改动现有布局引发新的问题，遂通过JS事件来限制，在拖动结束的时候，如果元素超出屏幕边界，则使之回到屏幕内。<br>&emsp;&emsp;浮标元素是fixed定位的，我们能获取该元素距屏幕顶部的距离，这个距离加上元素的距离如果大于屏幕的高度的话，说明被拖出屏幕下边界，则设置元素的top属性为屏幕的高度减去元素的高度这么多像素。如果元素的top属性值小于0，则说明被拖出了上边界，则设置其样式top属性为0。<br>&emsp;&emsp;元素的 <code>offsetHeight</code> 是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含 :before 或 :after 等伪类元素的高度。</p><h2 id="趋势图时环比线条出界"><a href="#趋势图时环比线条出界" class="headerlink" title="趋势图时环比线条出界"></a>趋势图时环比线条出界</h2><p>&emsp;&emsp;有时Echarts绘制出现奇怪的问题，比如线条出界，比如两点之间的连线不平滑，出现拐点。遇到这样匪夷所思的问题，或许我们应该检查下代码，是否是实现逻辑出现问题，除此之外还有个原因可以检查一下，那就是：绘制图表前是否有清空 canvas。一个图表组件会被公用，这种情况如果绘制前不清空画板可能就会出现这样怪异的问题。<br>&emsp;&emsp;原来的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chart = <span class="keyword">this</span>.$echarts.init(chartBox, <span class="literal">null</span>, &#123;<span class="attr">renderer</span>: <span class="string">'svg'</span>&#125;);</span><br><span class="line">chart.setOption(&#123;</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;优化后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.chartObj) &#123;</span><br><span class="line">    <span class="keyword">this</span>.chartObj.clear();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.chartObj = <span class="keyword">this</span>.$echarts.init(chartBox, <span class="literal">null</span>, &#123;<span class="attr">renderer</span>: <span class="string">'svg'</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制图表</span></span><br><span class="line"><span class="keyword">this</span>.chartObj.setOption(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用原生"><a href="#调用原生" class="headerlink" title="调用原生"></a>调用原生</h2><p>&emsp;&emsp;APP端通常有PDF预览的需求，比如查看报告等。前端有js或者vue相关的插件可以供我们使用，之前使用过pdf.js，实现出来的体验一般。最近项目中同事也用过vue-pdf，这个插件能用来做 PDF 的预览。我们遇到的情况是，在本地开发的时候没有问题，但是上到测试环境后，拉取PDF数据的请求有发送，但是不显示结果。后来我还发现，使用了这个插件以后，包会增大好几兆，这对H5的性能是不利的。所以后来放弃了使用这些插件，转而调用原生提供的PDF预览功能。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开APP原生页面</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; urlScheme 原生scheme路径地址，这里约定必须以mgstaff://开头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">startNativeActivity(urlScheme = <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (urlScheme.indexOf(<span class="string">'mgstaff://'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`urlScheme必须以mgstaff://开头`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.invokeNative(<span class="string">'handleUrlScheme'</span>, &#123; urlScheme &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;H5 使用原生的功能，通过 <code>JSBridge</code> 实现。<code>JSBridge</code> 主要是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能。这个通信可以是双向的。JavaScript 调用 Native的方式主要有两种：注入API 和 拦截URL SCHEME。<br>&emsp;&emsp;注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。<br>&emsp;&emsp;URL SCHEME 是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，比如：<code>mgstaff://course_pdf_detail?pdf_id=201912011501&amp;pdf_name=weekly_20191201</code>。H5 发送 URL Scheme 请求之后，Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。<br>&emsp;&emsp;Native 调用 JavaScript 的方式，我们主要是采用 JS 向 window下的对象 注册回调函数的方式。H5 在调用原生能力的同时，向 Window 下的对象注册供原生传参调用的方法。比如我们想开启语音识别并返回识别后的文字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启语音识别并返回识别后的文字</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;string&gt;&#125; 识别后的文字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">recognizeVoice() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.openNative(<span class="string">'mgstaff://voice_recognition_dialog'</span>)</span><br><span class="line">        deviceApi.postVoiceRecognition = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res.intent &amp;&amp; res.intent.text)</span><br><span class="line">            <span class="keyword">delete</span> deviceApi.postVoiceRecognition</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a><br><a href="https://www.echartsjs.com/zh/option.html#grid.tooltip.axisPointer.crossStyle" target="_blank" rel="noopener">https://www.echartsjs.com/zh/option.html#grid.tooltip.axisPointer.crossStyle</a><br><a href="https://develop.asyncoder.com:8443/docs/solution/module-Default.html" target="_blank" rel="noopener">https://develop.asyncoder.com:8443/docs/solution/module-Default.html</a><br><a href="https://blog.csdn.net/yuzhengfei7/article/details/93468914" target="_blank" rel="noopener">https://blog.csdn.net/yuzhengfei7/article/details/93468914</a><br><a href="https://juejin.im/post/5bc07ebf6fb9a05d026119a9" target="_blank" rel="noopener">https://juejin.im/post/5bc07ebf6fb9a05d026119a9</a><br><a href="https://docs.elementor.com/article/595-difference-between-px-em-rem-percentage-vw-vh" target="_blank" rel="noopener">https://docs.elementor.com/article/595-difference-between-px-em-rem-percentage-vw-vh</a><br><a href="https://www.cnblogs.com/aspwebchh/p/7675539.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspwebchh/p/7675539.html</a><br><a href="https://www.cnblogs.com/savokiss/p/8514868.html" target="_blank" rel="noopener">https://www.cnblogs.com/savokiss/p/8514868.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文对近期开发移动端 H5 过程中解决的体验问题进行梳理汇总。内容涉及移动端适配、网络状态监听、DOM元素位置属性的
      
    
    </summary>
    
      <category term="移动端开发" scheme="https://www.haoming.fun/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>H5 体验优化总结（一）</title>
    <link href="https://www.haoming.fun/2020/02/02/H5-%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.haoming.fun/2020/02/02/H5-体验优化总结（一）/</id>
    <published>2020-02-02T15:27:00.000Z</published>
    <updated>2020-02-02T15:42:47.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;本文对近期开发移动端 H5 过程中解决的体验问题进行梳理汇总。内容涉及移动端适配、网络状态监听、DOM元素位置属性的计算、与原生通信、用户行为埋点、包体积优化等。通过小的问题案例，来讲解开发中问题的解决及如何提升用户体验。如果本文有任何不确切的地方，欢迎指正！<br>&emsp;&emsp;本文分为两部分，第一部分包含页面优化、设计优化、性能优化；第二部分包含功能优化。本文内容概要如下：</p><p><img src="https://www.haoming.fun/images/20200123190647.png" alt="本文概览"></p><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p>&emsp;&emsp;为了适配不同手机终端的屏幕尺寸，之前开发移动端 H5 的时候，页面字体、间距等属性设置的单位采用rem。最近参与的项目中采用的单位是 vw，据说一些低版本手机浏览器对 viewport-units 的支持不太理想（IOS 8+, Android 4.4+ 支持，见 <a href="https://caniuse.com/#feat=viewport-units" target="_blank" rel="noopener">caniuse</a>），但是就目前的应用场景来看支持还好。H5 页面适配以 rem 和 vw 这两种单位最为常见。<br>&emsp;&emsp;<code>vw</code> 和 <code>rem</code> 的方案的本质都是“等比例缩放”，适合于视觉组件种类较多，视觉设计对元素位置的相对关系依赖较强的移动端页面。但对于文本内容较多，或者说希望引导用户沉浸浏览的页面，有人不推荐完全使用等比缩放的方案，并且在新闻，社区等可阅读内容较多的场景，px 方案可以让大屏幕手机展示出更多的内容，更符合人们的阅读习惯。<br>&emsp;&emsp;<code>rem</code> 是相对于根元素（HTML标签），而 <code>vw</code> 是相对于视口的宽度。下面说说两种方案的计算。</p><h3 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h3><p>&emsp;&emsp;大多数浏览器中，默认的字体大小是 16px，rem 单位的计算是以这个为基准（em以父元素的字体大小为基准）。如果用户将这个根元素的字体大小改成 14px,那么 1rem = 14px (1 * 14)，这样用户通过调整浏览器的默认字体大小，来控制每个元素的相对（缩放）比例。假如为了适配 1920 x 1080 以上尺寸的大屏，我们可以先求得设备像素比 dpr，然后基于 dpr 设置根元素的字体大小为 <code>dpr * 100px</code>。那么设计稿中 12 像素大小的文字，代码中该 <code>font-size</code> 设置为 0.12rem。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> docEle = <span class="built_in">document</span>.documentElement;</span><br><span class="line">docEle.style.minWidth = <span class="string">'1920px'</span>;</span><br><span class="line"><span class="keyword">const</span> dpr = docEle.offsetWidth / <span class="number">1920</span>;</span><br><span class="line">docEle.setAttribute(<span class="string">"data-dpr"</span>, dpr + <span class="string">''</span>);</span><br><span class="line">docEle.style.fontSize = dpr * <span class="number">100</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><h3 id="Viewport-units"><a href="#Viewport-units" class="headerlink" title="Viewport units"></a>Viewport units</h3><p>&emsp;&emsp;Viewport units 代表当前浏览器视口的一个百分比，和 % 单位相似，区别是视口单位按浏览器当前视口大小的百分比计算；而百分比单位是以父元素的百分比计算的。假如一个 375 x 667 的手机（iPhone6），那么1 vw = 1% of the viewport’s width (or 3.75px)。如果 UI 给的高保真宽为 375px，高为 667px，其中有一个按钮，宽为 64px，高为 16px，那么在给这个按钮设定样式的时候 width 属性应该为 <code>(64 / (375/100)) vw</code>。<br>&emsp;&emsp;如果我想在代码中就用 <code>px</code>，有没有插件能帮我们做这个事情呢？经过一番查找发现，<a href="https://github.com/evrone/postcss-px-to-viewport" target="_blank" rel="noopener">postcss-px-to-viewport</a>能解决这个问题，但是这个配置是全局的，也就是所有的px单位都会被转换，除非在它的exclude配置项中配置要排除的文件。如果我们有的地方就想采用px，不需要被转换，并且这种需要忽略的文件比较多怎么办？因此考虑到这些，在实际的应用中没有采用这种方案。<br>&emsp;&emsp;然后又考虑说，能否通过less 的mixins类似的特性，通过less定义方法来实现转换，在写样式的时候简单调用一下，如<code>font-size: px2vw(14)</code>这样就能实现转换呢。翻阅文档发现，less 有提供 <a href="https://less.bootcss.com/features/#plugin-atrules-feature-writing-your-first-plugin" target="_blank" rel="noopener">plugin</a> 功能，另外<a href="https://github.com/seven-phases-max/less-plugin-functions" target="_blank" rel="noopener">less-plugin-functions</a>，也提供类似功能，相当于 css 执行 js 的逻辑。当时由于时间紧，尝试利用 less plugin 来实现没能成功，只能以后再试一下了。<br>&emsp;&emsp;最后还是利用工具来转换的，推荐<a href="https://khaledkzy.github.io/pixel-vh-vw-converter/" target="_blank" rel="noopener">pixel-vh-vw-converter</a>这个工具，注意转换前按下 <code>F12</code>,切换设备为手机模式，然后选择手机尺寸。</p><h2 id="关于等宽字体"><a href="#关于等宽字体" class="headerlink" title="关于等宽字体"></a>关于等宽字体</h2><p>&emsp;&emsp;关于什么是等宽字体，先来了解什么是不等宽字体。我们通常看到的大多字体都是不等宽字体，也就是因为英文的数字1和英文的数字9是不等宽的。那为什么需要字体是等宽的呢，比如用表格来展示各种数据值，数据靠左或靠右显示的情况下，如果字体不等宽，各位数字是对不齐的，不美观且不便于比较。<br>&emsp;&emsp;通常的等宽字体有：Consolas, Monaco, monospace，这些字体可能只对英文字符生效，对中文无效。此外我们也可以让 UI 同学提供他们认为美观的与高保真一致的字体文件，比如“DIN-RegularAlternate.ttf”。示例图如下：  </p><div align="center">    <img src="https://www.haoming.fun/images/20200123100422.png" width="60%" height="60%"></div><h2 id="关于编码规范"><a href="#关于编码规范" class="headerlink" title="关于编码规范"></a>关于编码规范</h2><p>&emsp;&emsp;在H5的开发过程中，适配各种机型是不可避免的，因此系统测试可能会发现一些兼容性问题。具以往经验，一部分兼容问题是不规范的CSS或JS编码造成，比如样式属性用简写，比如js用一些较新的方法，都可能是造成不兼容的原因，特别在低端机容易出现，它不识别某些写法。下面来看一个例子，我们 H5 的一个页面在ios上滑动出现卡顿，经排查和我们写的样式有关系。<br>&emsp;&emsp;以下是示例代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sticky-wrapper</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &amp; + <span class="selector-tag">div</span>&#123; <span class="comment">/* 去掉就OK了 */</span></span><br><span class="line">        <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户事件埋点"><a href="#用户事件埋点" class="headerlink" title="用户事件埋点"></a>用户事件埋点</h2><p>&emsp;&emsp;用户埋点的目的是统计一般的PV和UV，以及对用户的操作进行记录，方便我们统计出用户的行为轨迹、喜欢看的数据、搜索的关键字等等。方便我们有针对性地了解用户的喜好和行为习惯，帮助开发出更加符合用户需求，令用户满意的产品。<br>&emsp;&emsp;起初我们接入的系统埋点能符合一般的需要，但是对于一些个性化的统计还暂不满足。所以后来我们设计了接口，通过代码中埋点调接口的方式，来记录用户行为。<br>&emsp;&emsp;因此通过 Vue 的 mixins 来定义埋点的功能方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userTrack = &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        trackEvent(params) &#123;</span><br><span class="line">            <span class="keyword">const</span> actions = [<span class="string">'click'</span>];</span><br><span class="line">            <span class="keyword">const</span> categories = [<span class="string">'pageView'</span>];</span><br><span class="line">            <span class="keyword">const</span> options = &#123;</span><br><span class="line">                appId: <span class="string">'xxxxxx'</span>, <span class="comment">// 约定appId</span></span><br><span class="line">                userName: localStorage.user, <span class="comment">// 登录用户名</span></span><br><span class="line">                category: categories[<span class="number">0</span>], <span class="comment">// 要监控的目标的类型名称</span></span><br><span class="line">                action: actions[<span class="number">0</span>], <span class="comment">// 用户行为，默认点击</span></span><br><span class="line">                pageId: store.state.moduleName.id, <span class="comment">// 访问页面ID，这里传模块ID</span></span><br><span class="line">                pageName: store.state.moduleName.name, <span class="comment">// 访问页面名称，这里传模块名</span></span><br><span class="line">                eventTime: util.dateFormat(<span class="string">'yyyy-MM-dd HH:mm:ss'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="comment">// 记录事件时间</span></span><br><span class="line">                ...params <span class="comment">// 传入的事件参数</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// JSON对象转字符串，后端需要</span></span><br><span class="line">            options.values &amp;&amp; (options.values = <span class="built_in">JSON</span>.stringify(options.values));</span><br><span class="line">            api.trackEvent(options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包体积优化"><a href="#包体积优化" class="headerlink" title="包体积优化"></a>包体积优化</h2><p>&emsp;&emsp;接手项目构建后的前端包比较大，因此着手进行优化，尽量缩小包的体积大小。优化围绕两个原则，第一个是插件的按需引入，第二个去掉页面文件中没有用到引入。<br>&emsp;&emsp;先减小打包后大的 js 文件的体积，要减小大文件，就得利用 Webpack 分析构建后的 js 文件中哪些插件占用空间大，为多大。我们通过在 <code>package.json</code> <code>的scripts</code> 下配置命令：<code>&quot;analyze&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot;</code>，然后执行 <code>npm run analyze</code>，在打开的页面中进行包分析。</p><ul><li><p>Echarts 按需引入</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">'echarts/lib/echarts'</span>;</span><br><span class="line">Vue.prototype.$echarts = echarts;</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChartPie.vue 等页面按需引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/chart/pie'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/component/tooltip'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/component/legend'</span>;</span><br></pre></td></tr></table></figure></li><li><p>lodash 按需引入</p><p>运行 npm 命令安装依赖：<code>npm install babel-plugin-lodash lodash-webpack-plugin --save-dev</code></p><p>修改<code>.babelrc</code>文件，plugins 中添加 lodash，我的项目添加完成如下：<code>&quot;plugins&quot;: [transform-runtime&quot;, [&quot;import&quot;, {...}], &quot;lodash&quot;]</code></p><p>修改 webpack.base.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = vuxLoader.merge(webpackConfig, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">      ...,</span><br><span class="line">      <span class="keyword">new</span> LodashModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>moments 排除字体包<br>修改 webpack.prod.conf.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        ...,</span><br><span class="line">        <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale/</span>,/moment$/),</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;优化后某大文件的体积从1370kB 减小到 518KB，减少约62.2%。<br>&emsp;&emsp;然后是去掉不必要的引用：首先是去掉之前引入的 vue-pdf，后面没用了。去掉以后包体积减小了几兆。其次是执行静态代码扫描，将错误修复，特别是定义了没有使用的报错（no-unused-vars error）或者 <span style="color:red"> import 后没有使用</span>。<br>&emsp;&emsp;最后配置生产环境不启用 SourceMap，即打包的时候不生成 SourceMap 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改config/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    build: &#123;</span><br><span class="line">        ...,</span><br><span class="line">        productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过上述优化，包的大小从最初的 33,446,583 字节减小到 1,876,526 字节，减小94.4%。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a><br><a href="https://www.echartsjs.com/zh/option.html#grid.tooltip.axisPointer.crossStyle" target="_blank" rel="noopener">https://www.echartsjs.com/zh/option.html#grid.tooltip.axisPointer.crossStyle</a><br><a href="https://develop.asyncoder.com:8443/docs/solution/module-Default.html" target="_blank" rel="noopener">https://develop.asyncoder.com:8443/docs/solution/module-Default.html</a><br><a href="https://blog.csdn.net/yuzhengfei7/article/details/93468914" target="_blank" rel="noopener">https://blog.csdn.net/yuzhengfei7/article/details/93468914</a><br><a href="https://juejin.im/post/5bc07ebf6fb9a05d026119a9" target="_blank" rel="noopener">https://juejin.im/post/5bc07ebf6fb9a05d026119a9</a><br><a href="https://docs.elementor.com/article/595-difference-between-px-em-rem-percentage-vw-vh" target="_blank" rel="noopener">https://docs.elementor.com/article/595-difference-between-px-em-rem-percentage-vw-vh</a><br><a href="https://www.cnblogs.com/aspwebchh/p/7675539.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspwebchh/p/7675539.html</a><br><a href="https://www.cnblogs.com/savokiss/p/8514868.html" target="_blank" rel="noopener">https://www.cnblogs.com/savokiss/p/8514868.html</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文对近期开发移动端 H5 过程中解决的体验问题进行梳理汇总。内容涉及移动端适配、网络状态监听、DOM元素位置属性的
      
    
    </summary>
    
      <category term="移动端开发" scheme="https://www.haoming.fun/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="H5" scheme="https://www.haoming.fun/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>Vue nextTick 原理分析</title>
    <link href="https://www.haoming.fun/2019/08/30/Vue-nextTick-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://www.haoming.fun/2019/08/30/Vue-nextTick-原理分析/</id>
    <published>2019-08-30T13:36:00.000Z</published>
    <updated>2019-08-30T13:37:38.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nextTick-原理分析"><a href="#nextTick-原理分析" class="headerlink" title="nextTick 原理分析"></a>nextTick 原理分析</h2><p>nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。</p><p>看 <a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js" target="_blank" rel="noopener">next-tick.js</a> 源码</p><p>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。后来在Vue 2.5中使用宏任务结合微任务，然而又有一些问题，所以变成了现在的每个地方使用的是微任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是使用微任务的异步延迟包装器（timerFunc）。</span></span><br><span class="line"><span class="comment">// 在2.5中，我们使用（宏）任务（结合微任务）</span></span><br><span class="line"><span class="comment">// 然而，在重绘之前，状态发生改变的时候，它有点细微的问题</span></span><br><span class="line"><span class="comment">// 此外，在事件处理程序中使用（宏）任务会导致一些无法回避的奇怪行为</span></span><br><span class="line"><span class="comment">// 所以我们现在再一次在所有的地方都使用了微任务</span></span><br><span class="line"><span class="comment">// 这样权衡也有它主要的缺点， 那就是有一些场景微任务有太高的优先级，</span></span><br><span class="line"><span class="comment">// 据说在连续事件之间，甚至同一事件的冒泡之间会被触发</span></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextick行为利用微任务队列, 可以通过原生的 Promise.then 或者 MutationObserver 访问该队列</span></span><br><span class="line"><span class="comment">// MutationObserver 拥有广泛的支持, 但是它在 iOS &gt;= 9.3.3 的 UIWebView 中存在严重的问题， 这会发生在touch事件的处理程序中</span></span><br><span class="line"><span class="comment">// 当触发几次后，它就完全停止工作了... </span></span><br><span class="line"><span class="comment">// 因此原生promise如果可以的话，我们将首先使用它:</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="comment">// Promise.resolve()方法调用时不带参数，直接返回一个resolved状态的 Promise 对象</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行</span></span><br><span class="line">    <span class="comment">// 也就是在本轮“事件循环”结束时执行回调方法</span></span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// 在有问题的 UIWebViews 中, Promise.then 不会完全退出, </span></span><br><span class="line">    <span class="comment">// 而是陷入一种奇怪的状态： 回调被推到微任务队列中，但队列不会被刷新</span></span><br><span class="line">    <span class="comment">// 直到浏览器需要做一些其他工作，例如处理计时器</span></span><br><span class="line">    <span class="comment">// 因此我们可以通过添加一个空计时器来“强制”刷新微任务队列</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// 原生 Promise 不可用的话，就用 MutationObserver</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// 如果上面两种不行，回退到使用 setImmediate.</span></span><br><span class="line">  <span class="comment">// 技术上它利用了宏任务队列,</span></span><br><span class="line">  <span class="comment">// 但是仍然是一个比 setTimeout 更好的选择</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 最后回退到使用 setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc() <span class="comment">// 异步执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的源码可以看出，在执行回调方面的优先级为 Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</p><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。</p><p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><p>以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// output: script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><p>以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。</p><p>微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver</p><p>宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</p><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p><p>所以正确的一次 Event loop 顺序是这样的:</p><ol><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 Event loop，执行宏任务中的异步代码</li></ol><p>通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</p><p>##参考</p><p><a href="https://yuchengkai.cn/docs/frontend/browser.html#event-loop" target="_blank" rel="noopener">https://yuchengkai.cn/docs/frontend/browser.html#event-loop</a><br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">https://yuchengkai.cn/docs/frontend/browser.html#event-loop</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nextTick-原理分析&quot;&gt;&lt;a href=&quot;#nextTick-原理分析&quot; class=&quot;headerlink&quot; title=&quot;nextTick 原理分析&quot;&gt;&lt;/a&gt;nextTick 原理分析&lt;/h2&gt;&lt;p&gt;nextTick 可以让我们在下次 DOM 更新循环
      
    
    </summary>
    
      <category term="vue" scheme="https://www.haoming.fun/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Web Workers 和 Comlink 的使用</title>
    <link href="https://www.haoming.fun/2019/08/29/Web-Workers-%E5%92%8C-Comlink-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.haoming.fun/2019/08/29/Web-Workers-和-Comlink-的使用/</id>
    <published>2019-08-29T10:59:00.000Z</published>
    <updated>2019-08-29T10:59:28.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-异步编程回顾"><a href="#JavaScript-异步编程回顾" class="headerlink" title="JavaScript 异步编程回顾"></a>JavaScript 异步编程回顾</h2><p>传统的 Web 是单线程的。一条条命令会按顺序执行，完成一条再开始下一条。同步 API 简化了我们的脚本编写工作，在上一条命令完成之前不会发生任何事情。Web 中的异步 API 比如说从磁盘读取、访问网络资源，这些 API 经常依赖事件或回调来处理这些资源。Node.js 是服务端 JavaScript 环境，使用了大量异步代码，通常使用回调模式进行异步操作。</p><p>虽然回调非常有用，但遗憾的是它们会依赖于先前异步函数的结果。为了解决 “回调地狱” 这个问题，比较新的 API 往往既不使用回调也不使用事件，而是使用 Promise。Promise 使用.then 语法使回调看起来更具可读性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/data.json'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Promise 的功能和回调是一样的，但前者更具可读性，结合箭头函数可以清楚表达Promise的每一步是怎样转换上一步的输出的。Promise 的真正优势在于，他是ES7 中 async/await 语法的基础之一。</p><p>在 async 函数中，await 语句将暂停函数的执行，直到它们等待的 promise 完成或拒绝。代码写法看起来是同步的，但是行为却是异步的，不会阻塞主线程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'data.json'</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;;</span><br><span class="line">getData();</span><br></pre></td></tr></table></figure><p>async 函数将返回一个 promise，它本身可以在其他 async 函数中与 await 并用。</p><h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>目前为止我们谈的都是单线程编程。就是说我们的代码运行在一个CPU线程上，这个线程复制运行JS、解析CSS、网站布局和绘图。如果JS需要运行很长时间将会阻止其他部分的工作，导致比较糟糕的用户体验。</p><p>为了绕过单个线程运行内容的限制，Web 可以通过 Web Workers 来利用多个线程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'/first-worker.js'</span>);</span><br></pre></td></tr></table></figure><p>上面的代码将下载JS文件运行在不同的线程中，使得在不阻塞主线程的前提下运行复杂的JS程序。需要注意的是，Worker 本身是无法显示数字的，因为它无法访问主脚本的变量或文档本身，它所能做的只有传回计算的最终结果。这是线程的性质决定的，它只能访问同一线程内存中的内容。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p><p>线程共享的进程环境包括：进程代码段、进程的公有资源（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、消息队列、信号的处理器、进程的当前目录、进程用户ID、进程组ID。</p><p>线程独占资源：线程ID、寄存器组的值、用户栈、内核栈、错误返回码、线程的信号屏蔽码、线程的优先级。</p><p>一个进程中的所有线程有它们各自独立的（私有的）栈(stack)。堆(heap)的分配与栈有所不同，一般是一个进程有一个运行时堆，这个堆为本进程中所有线程共享。线程切换的时候实际上切换的是一个可以称之为线程控制块的结构，里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。</p><p>一个进程的线程共享堆区，堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p><p>栈是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动的切换栈，就是切换 SS / ESP 寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>不同线程之间可以基于事件来交换信息，每个线程都会侦听message事件，并可以使用postMessage API 发送消息。利用postMessage可以共享数组、对象、字符串。发送这些数据时，浏览器以特殊的序列化格式制作数据结构的副本，然后在另一个线程中重建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the worker:</span></span><br><span class="line">self.postMessage(someObject);</span><br><span class="line"><span class="comment">// In the main thread:</span></span><br><span class="line">worker.addEventListener(<span class="string">'message'</span>, msg =&gt; <span class="built_in">console</span>.log(msg.data));</span><br></pre></td></tr></table></figure><p>someObject 被克隆变转变成可传递的形式，然后主线程接收后再转换成原始对象的副本，这个过程开销比较大。常见的共享数据时传递的对象类型是ArrayBuffer。使用 postMessage 传输 ArrayBuffer 时要小心。一旦它被传输后，它在原始线程中就不能再读取或写入了，并且如果你尝试使用它将抛出错误。</p><h2 id="使用Comlink"><a href="#使用Comlink" class="headerlink" title="使用Comlink"></a>使用Comlink</h2><p>Comlink 将 postMessage 转换成了基于 Promise 的异步 API，它体积非常小，消除了使用postMessage 的顾虑，隐藏使用 workers 的事实，它是 postMessage 和 ES6 代理的 RPC 实现。</p><p>可以这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;wrap&#125; <span class="keyword">from</span> <span class="string">'/comlink/comlink.js'</span>;</span><br><span class="line"><span class="comment">// This web worker uses Comlink's expose to expose a function</span></span><br><span class="line"><span class="keyword">const</span> MyMathLibrary = wrap(<span class="keyword">new</span> Worker(<span class="string">'/mymath.js'</span>));</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> myMath = <span class="keyword">await</span> <span class="keyword">new</span> MyMathLibrary();</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> myMath.add(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> myMath.add(<span class="number">3</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> myMath.multiply(result1, result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Comlink 可以带来的另一大性能提升是利用 ArrayBuffer 之类的可传递对象，不用再复制它们。这会显著提升性能，但用的时候也要小心，因为一旦它们被传递后就不能在原始线程中使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">await</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> toSend = <span class="built_in">Int16Array</span>.from(data);</span><br><span class="line">    <span class="keyword">return</span> myMath.addArray(</span><br><span class="line">        Comlink.transfer(toSend.buffer, [toSend.buffer])</span><br><span class="line">    );</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>Comlink 的一大好处是它让开发人员可以方便地把一部分应用放到 Worker 中，而无需对代码库做大幅度改动。w我们要做的工作主要是把同步函数转换为异步函数，在 await 后调用 Worker 暴露的 api。</p><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247492293&idx=1&sn=dbe2e19c6bfc8c13de59bc83a54c4934&chksm=f9525786ce25de900cae3ac55c762462421bf43863a138297cfea96cad161534d5e022e344a8&mpshare=1&scene=1&srcid=0827kUyWlRRbf3mF1DotaQKJ&sharer_sharetime=1566905344586&sharer_shareid=5d586b1751e23a5d55eb059fa2bd5d8c&key=6a52e6304f29e3a7d719b0845ffba593201a8dd97738bac43e1d4a11c38958361b7090319c8a79cbac520e89856f121c76d62382dbe6111ee441cf1d776fcdba3b0b1f2f5b367a0f354681c4644e03c1&ascene=1&uin=MjE0Njk2MzQ2MA%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=hBWsvE6Yp10hztc9%2Fx2LmKvLtqZmKd%2FxVsWK45TywcXtnvVU5VvNFknoYmdqPmTE" target="_blank" rel="noopener">Web单线程终结者：Web Workers</a></p><p><a href="ttps://www.nowcoder.com/questionTerminal/1ecf3ca506d74384be091b1d6a6d1cb9?toCommentId=1537528" target="_blank" rel="noopener">同一个进程的不同线程，哪个是不能共享的</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376" target="_blank" rel="noopener">进程和线程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-异步编程回顾&quot;&gt;&lt;a href=&quot;#JavaScript-异步编程回顾&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 异步编程回顾&quot;&gt;&lt;/a&gt;JavaScript 异步编程回顾&lt;/h2&gt;&lt;p&gt;传统的 Web 是单
      
    
    </summary>
    
      <category term="前端" scheme="https://www.haoming.fun/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数组：在给定的成对整数数组中找出所有总和等于给定数字的组合</title>
    <link href="https://www.haoming.fun/2019/08/27/%E6%95%B0%E7%BB%84%EF%BC%9A%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E6%88%90%E5%AF%B9%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E6%80%BB%E5%92%8C%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <id>https://www.haoming.fun/2019/08/27/数组：在给定的成对整数数组中找出所有总和等于给定数字的组合/</id>
    <published>2019-08-27T06:42:00.000Z</published>
    <updated>2019-08-27T09:37:01.349Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html" target="_blank" rel="noopener">原文</a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天，我们来看另一个有趣的编程问题：编写一个程序来查找和等于给定数字的所有整数对。例如，如果输入整数数组为2、6、3、9、11，并且给定和为9，则输出应为6、3。听起来很简单？也许许多人可能已经听说过这个问题，有些人可能已经知道这个问题的解决方案，但仅仅知道答案是不够的。在面试中，除了正确的解决方案，其他的一些点也很重要。例如，面试官首先要考虑的是应聘者能否提出正确的问题。因此，在直接编码之前，请留出一两秒钟时间来考虑这个问题，并清除可能存在的任何疑问。例如，您可以根据上面给出的问题描述提出以下问题：</p><ul><li>数组是否只包含正数或负数?</li><li>如果同一对数字出现两次, 是否每次都输出吗？</li><li>相反的数字对是否可接受？ 例如： 如果给定和是5，打印 (4,1) 和 (1,4) </li><li>是否我们只打印不相同的对? (3, 3) 是总和为6的合法对吗？</li><li>数组的长度是多少？</li></ul><p>面试时问问题是好，表明您有在思考问题，这对程序员来说是非常重要的素质。为了简便，我们假设这里跟你对出现的次数打印或一次或两次，并且这一对数字不相同，比如不能是（2，2）（3，3）这样的。</p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>能想到的第一个解决办法：暴力算法，从数组中取出一个数字，然后循环遍历数组和输出对，这些对等于给定的和。对第一个数组中的所有数字都这样做，如下面的Java程序所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java Program to find pairs on integer array whose sum is equal to k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProblemInArray</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] numbersWithDuplicates = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        prettyPrint(numbers, <span class="number">7</span>);</span><br><span class="line">        prettyPrint(numbersWithDuplicates, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all pair of integer values from given array whose sum is is equal to given number.</span></span><br><span class="line"><span class="comment">     * complexity of this solution is O(n^2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairs</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = array[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> second = array[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((first + second) == sum) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"(%d, %d) %n"</span>, first, second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Utility method to print input and output for better explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prettyPrint</span><span class="params">(<span class="keyword">int</span>[] givenArray, <span class="keyword">int</span> givenSum)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Given array : "</span> + Arrays.toString(givenArray));</span><br><span class="line">        System.out.println(<span class="string">"Given sum : "</span> + givenSum);</span><br><span class="line">        System.out.println(<span class="string">"Integer numbers, whose sum is equal to value : "</span> + givenSum);</span><br><span class="line">        printPairs(givenArray, givenSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given array : [2, 4, 3, 5, 7, 8, 9]</span><br><span class="line">Given sum : 7</span><br><span class="line">Integer numbers, whose sum is equal to value : 7</span><br><span class="line">(2, 5) </span><br><span class="line">(4, 3) </span><br><span class="line">Given array : [2, 4, 3, 5, 6, -2, 4, 7, 8, 9]</span><br><span class="line">Given sum : 7</span><br><span class="line">Integer numbers, whose sum is equal to value : 7</span><br><span class="line">(2, 5) </span><br><span class="line">(4, 3) </span><br><span class="line">(3, 4) </span><br><span class="line">(-2, 9)</span><br></pre></td></tr></table></figure><p>以上方法的时间复杂度是O(n^2)，因此需要对其进行改进优化。为了在一个数组中找到和为给定值的两个数字，我们可能不需要对每个数字进行比较。我们在这里可以做的是将所有数字存储在哈希表中，并检查它是否在一对中包含第二个值。例如，如果给定的和是4，成对的一个数是3，那么另一个数必须是1或-7。您还记得我们问的第一个问题吗？如果数组只包含正数，那么我们不需要在map中检查负值。该解决方案如何优于前一个解决方案呢？这个方案需要较少的比较。只有n次迭代数组并在集合中插入值，因为在哈希表中，add()和contains()都是O(1)操作。所以解决方案的总复杂度是O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java Program to find two elements in an array that sum to k.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySumUsingSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       prettyPrint(getRandomArray(<span class="number">9</span>), <span class="number">11</span>);</span><br><span class="line">       prettyPrint(getRandomArray(<span class="number">10</span>), <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an array of integers finds two elements in the array whose sum is equal to n.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairsUsingSet</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet(numbers.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> value : numbers)&#123;</span><br><span class="line">            <span class="keyword">int</span> target = n - value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// if target number is not in set then add</span></span><br><span class="line">            <span class="keyword">if</span>(!set.contains(target))&#123;</span><br><span class="line">                set.add(value);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">"(%d, %d) %n"</span>, value, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Utility method to find two elements in an array that sum to k.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prettyPrint</span><span class="params">(<span class="keyword">int</span>[] random, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Random Integer array : "</span> + Arrays.toString(random));</span><br><span class="line">        System.out.println(<span class="string">"Sum : "</span> + k);</span><br><span class="line">        System.out.println(<span class="string">"pair of numbers from an array whose sum equals "</span> + k);</span><br><span class="line">        printPairsUsingSet(random, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Utility method to return random array of Integers in a range of 0 to 15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getRandomArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] randoms = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            randoms[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> randoms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Random Integer array : [7, 9, 3, 6, 4, 7, 9, 10, 8]</span><br><span class="line">Sum : 11</span><br><span class="line">pair of numbers from an array whose sum equals 11</span><br><span class="line">(4, 7) </span><br><span class="line">(8, 3) </span><br><span class="line">Random Integer array : [0, 13, 6, 5, 14, 6, 4, 11, 11, 3]</span><br><span class="line">Sum : 12</span><br><span class="line">pair of numbers from an array whose sum equals 12</span><br><span class="line">(6, 6)</span><br></pre></td></tr></table></figure><p>这里用到了HashSet，HashSet内部用到了HashMap。因此这个方案需要额外O(n)d的空间来在哈希表或集合中存储数字，所以如果数组非常大，您需要额外的空间也会非常大，这可能是个问题。更有效的不使用额外空间的就地解决方案是对数组进行排序，并使用两个指针从开始和结束两个方向扫描数组。如果这两个值的和等于给定的数字，那么我们将输出该对并将其向前推进。如果两个数字的和小于k，则增大左指针；如果和大于k，则减小右指针，直到两个指针在数组的某个部分相遇。由于排序，此解决方案的复杂性将是O（nlogn）。使用一个就地排序算法（如Quicksort）对数组进行排序，因为没有额外的空间。幸运的是，arrays.sort()方法使用双支点快速排序算法对原始数组进行排序。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java Program to find all pairs on integer array whose sum is equal to k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArrayPairs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       prettyPrint( <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">12</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">20</span>, -<span class="number">11</span>&#125;, <span class="number">9</span>);</span><br><span class="line">       prettyPrint( <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, -<span class="number">1</span>&#125;, <span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given a number finds two numbers from an array so that the sum is equal to that number k.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPairsUsingTwoPointers</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="keyword">int</span> right = numbers.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"(%d, %d) %n"</span>, numbers[left], numbers[right]);</span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">                right = right -<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; k)&#123;</span><br><span class="line">                left = left +<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">                right = right -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Utility method to print two elements in an array that sum to k.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prettyPrint</span><span class="params">(<span class="keyword">int</span>[] random, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"input int array : "</span> + Arrays.toString(random));</span><br><span class="line">        System.out.println(<span class="string">"All pairs in an array of integers whose sum is equal to a given value "</span> + k);</span><br><span class="line">        printPairsUsingTwoPointers(random, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input int array : [12, 14, 17, 15, 19, 20, -11]</span><br><span class="line">All pairs in an array of integers whose sum is equal to a given value 9</span><br><span class="line">(-11, 20) </span><br><span class="line">input int array : [2, 4, 7, 5, 9, 10, -1]</span><br><span class="line">All pairs in an array of integers whose sum is equal to a given value 9</span><br><span class="line">(-1, 10) </span><br><span class="line">(2, 7) </span><br><span class="line">(4, 5)</span><br></pre></td></tr></table></figure><p>以上探讨了三种方法，从最开始暴力算法，到后面的O(n)时间复杂度和空间复杂度，再到O(nlogn)，不断进行优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html&quot; ta
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://www.haoming.fun/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term=" 面试题精选" scheme="https://www.haoming.fun/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>记最近的一些感悟（深度好文）</title>
    <link href="https://www.haoming.fun/2019/08/26/%E8%AE%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%EF%BC%88%E6%B7%B1%E5%BA%A6%E5%A5%BD%E6%96%87%EF%BC%89/"/>
    <id>https://www.haoming.fun/2019/08/26/记最近的一些感悟（深度好文）/</id>
    <published>2019-08-26T09:45:00.000Z</published>
    <updated>2019-08-26T09:51:30.087Z</updated>
    
    <content type="html"><![CDATA[<p>先以迈吉客创始人的一句话开头：</p><blockquote><p>永远保持极度开放和深度思考，我们想要看到世界有什么变化，就必须先让自己有所变化。</p></blockquote><p>做技术的人很容易一头扎进技术里，除了钻研技术什么也不想，想说我就把技术做牛逼了。结果这样就是：我对这个世界开的窗就这么大，只有一些关心的部分才被照射进来。也就是说，思维的开放，是否打开心灵拥抱新鲜事物，决定你的知识面以及你的格局。</p><p>这个世界的信息量太大，可能我们一辈子都没办法对其有深入的理解。有一点我想都是一样的，我们不想成为一个狭隘的人，一个浅薄的人，一个无知的人。因此这需要我们用一辈子的时间来学习和思考。如果自己成天就对着电脑，不与人接触，不输入，就类似于将自己关在窄井里，每天能看到的就是井口那么大一点天空。</p><p>然后就是深度思考，思考范围大到国家、社会、行业、公司，小到个人（自己及他人），需要多多思考，特别是深度的思考，思考现象背后的本质。</p><p>自然界有他规律，社会有他的规则。人是处在社会群体之中，群体有他的规则，那么就有制定规则的人。作为普通的人，很难去制定规则吧。但是我们可以关注行业发展历程及趋势，用户需求和心理，精通某方面业务和技术。一个规章一个规则是为了解决问题，一个产品是为了响应规则的或者满足社会群体心理。社会或行业的发展有国家政策及发展等宏观因素的影响，也有其文化历史等因素的影响，也有社会人生活生理需求的影响，归根到底是人，人组成社会，建立国家，塑造历史。我们需要考虑我们为什么生而为人，活着是为了什么，权利、地位、财富、名誉、家庭？不管怎样，我们应该都想成为一个有价值的人；一个有用的人；有成果的一个人；能够撑起家庭，有富足生活的一个人。当我们能承担好责任，实现价值，也不枉走这一遭。</p><p>前面讲到，了解这个世界，首先是<font color="red">开放</font>格局，对世界open。然后就是了解<font color="red">人类历史文化</font>，中西历史，中外文化，然后就是社会学，社会的运行规律，最后是人的心理分析。总之，了解这个世界就是了解社会和自己。我觉得首先是<font color="red">了解自己，与自己达成和解</font>，建立稳定的人格，然后推己及人，对他人有同情心。据我观察，企业高管好多都是熟读历史，对人文有一定研究和造诣。为什么要读史，就是遇事的时候可以从历史中找到参照，指导决策。</p><p>做研发的目的就是开发一款产品，而产品的存在是为了解决问题，这个问题可能是企业的，可能是个人的。解决问题大多是为了盈利。那么为了创造价值，我们怎么能做好一款产品呢？我觉得，其中包含对行业发展的理解，对业务的钻研，以及对用户需求的把握等。提到互联网产品，还离不开对内容和IP的建设打造，离不开产品的运营，就就牵扯到商业运作，涉及到理解人性。我最近才明白，一个产品的成功，最开始靠的是<font color="red">想法，是创意，是商业运作，是产品设计，而技术是辅助</font>，它被放在了一个较低的位置。有一个人告诉我：技术做得好，就只是混口饭吃！综上，做好事情需要有<font color="red">见识</font>，依赖认知。就这就涉及到对思维方式的训练，以及建立自己的一套专业的合理的<font color="red">知识架构</font>，当面临抉择，就用这套<font color="red">方法论</font>去框去量。为什么有的人（比如说我）对问题没有看法提不出意见，就是没到那个层次，没有概念。以上是我第一方面的感悟。</p><p>现在身为一个技术人不容易，通常来讲，把技术顶尖的少数人成为架构师。为什么说做技术不容易呢？因为有太多的技术要学，不仅要学，还要精通。引用一个对架构师的定义：</p><blockquote><p>细致全面善于沟通，技术上深度广度都没问题， 又喜欢这个工作，还会不时做底层实现，从业务和开发两个角度出发，搭出“架构”来是为了开发效率，为了运行效率，为了开发质量，为了业务灵活和运行稳定，为了维护方便等等这样的人，个人认为可以称为“架构师”。</p></blockquote><p>那么提取以上的关键字：<br>第一、 <font color="red">善于沟通</font><br>第二、<font color="red">技术专家</font>，大牛，技术广度、深度，绝对的动手能力（会底层，搭架构）<br>第三、<font color="red">业务专家</font>，定制化解决方案，兼顾业务和技术</p><p><font color="red">除了重视技术以外，甚至应该更加重视沟通和业务</font>，这是我第二方面的思考。</p><p>然后是对技术方向的一些思考，写业务写久了，难免不会觉得没意思没有技术含量。那什么是有含量的工作呢？就是牛逼的工作？什么工作就牛逼呢？就是很难的工作，多数人惧怕和难以完成的工作。哪些工作很难呢？比如写个编译器，撸一个框架，手动实现一些算法，做一些前沿的应用（比如混合现实）等等。因此我觉得需要做的是：<font color="red">关注底层原理，必要时补一些基础，不妨造造轮子撸撸框架</font>。</p><p>首先是，重视和夯实基础，<font color="red">核心原理和算法</font><br>其次是，<font color="red">阅读开源项目代码</font>，学习好的实践，来个优化或精简版<br>最后是，随着项目和经验的积累，理解现有的不足，根据需要作出改进，解决某些问题，从而动手<font color="red">实现工具框架</font></p><p>行胜于言，说再多想再多，不行动也是白搭。有了想法立马干，<font color="red">执行力要强</font>，切记拖沓，拖延是自己给自己架起的高墙。一切落实到行动，有输出。想好了先做了再说，做出来再说，不要以为还有些欠缺，时机还未到，还有些顾虑。<font color="red">一件事一件事做好，有始有终，有头有尾</font>。</p><p>为什么懂得很多道理，却依然过不好这一生？常常因为自己内心架起的高墙。我<font color="red">不自信</font>，我不敢交流，不敢表达，在意他人的眼光和评价。找不准方向，<font color="red">不知道自己的爱好</font>，这也行那也可以，左瞧瞧右看看，浅尝辄止，有始无终。内心有<font color="red">焦虑</font>，不平和，不坚定，没有主意，容易变化。</p><p>人生漫漫，回头是岸。所谓修行，一是改变内心的想法，第二是做，做的过程中体会，然后在修改内心的想法。必要时用一些方法破除我执。想做的事情很多，到底哪些是必须做的，理清楚抓重点，然后就是做了后需要形成闭环。</p><p>“修心”：</p><ol><li><font color="red">接受自己，包容自己——允许自己做得不好，接纳一个不完美的自己，降低对自己的期望值，承认自己是个普通人。接纳自己，是爱自己的第一步。</font></li><li>无常，不知今天是否最后一天，所以<font color="red">珍惜时间</font>吧</li><li><font color="red">豁达</font>，想想宇宙之大人如尘埃，想想死亡，终究一天我们将离去，破除我执（很难），<font color="red">包容</font>他人</li><li><font color="red">危机意识</font>，如果出来创业，能不能活得了</li></ol><p>“行路”</p><ol><li><font color="red">练习讲话</font>，有输入和输出。读文章发表感想，录音，达到讲话听着舒服。准备一些套路（模板）。重要场合一定准备充分。呼吸非常均匀，非常舒服</li><li><font color="red">坚持锻炼</font></li><li><font color="red">读书和思考，写日志</font></li><li>做科学研究。<font color="red">有目标</font>，理论和实践并重。关注算法、性能、安全、应用（某一方面，比如风控）。精力有限，<font color="red">想清楚要做的事，每天精进一点。建立自己的知识框架和方法论，争取每周有分享</font></li><li>学习<font color="red">商业模式，品牌打造，产品设计。将想法落地，出成果</font></li></ol><p>相信不断修行，会有更多的领悟和收获，喜爱自己，喜爱他人，生活富足，满心欢喜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先以迈吉客创始人的一句话开头：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;永远保持极度开放和深度思考，我们想要看到世界有什么变化，就必须先让自己有所变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做技术的人很容易一头扎进技术里，除了钻研技术什么也不想，想说我就把技术做牛逼了
      
    
    </summary>
    
      <category term="心得感悟" scheme="https://www.haoming.fun/categories/%E5%BF%83%E5%BE%97%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>在Centos安装MongoDB</title>
    <link href="https://www.haoming.fun/2019/08/14/%E5%9C%A8Centos%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>https://www.haoming.fun/2019/08/14/在Centos安装MongoDB/</id>
    <published>2019-08-14T11:10:00.000Z</published>
    <updated>2019-08-14T12:05:16.479Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>创建yum源文件<br>vim /etc/yum.repos.d/mongodb-org-4.0.repo<br>添加以下内容<br>[mongodb-org-4.0]<br>name=MongoDB Repository<br>baseurl=<a href="https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/" target="_blank" rel="noopener">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.0.asc" target="_blank" rel="noopener">https://www.mongodb.org/static/pgp/server-4.0.asc</a></p></li><li><p>使用 yum 安装MongoDB<br>yum install -y mongodb-org</p></li><li><p>配置MongoDB<br>vim /etc/mongod.conf<br>配置mongod.conf 开启远程连接： 把第30行bindIp: 127.0.0.1改为bindIp: 0.0.0.0</p></li><li><p>启动MongoDB服务<br>systemctl start mongod<br>服务器本地连接测试<br>mongo –host 127.0.0.1 –port 27017</p></li><li><p>本地连接MongoDB需要开启防火墙访问策略：<br><img src="https://www.haoming.fun/images/201908140709.png" alt="access strategy"></p></li><li><p>附启用/停止/重启 MongoDB 服务的命令<br>systemctl start mongod.service<br>systemctl stop  mongod.service<br>systemctl restart mongod.service</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建yum源文件&lt;br&gt;vim /etc/yum.repos.d/mongodb-org-4.0.repo&lt;br&gt;添加以下内容&lt;br&gt;[mongodb-org-4.0]&lt;br&gt;name=MongoDB Repository&lt;br&gt;baseurl=&lt;a hr
      
    
    </summary>
    
      <category term="运维" scheme="https://www.haoming.fun/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>数组：如何从整数数组中找出最大和最小值</title>
    <link href="https://www.haoming.fun/2019/08/14/%E6%95%B0%E7%BB%84%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BB%8E%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://www.haoming.fun/2019/08/14/数组：如何从整数数组中找出最大和最小值/</id>
    <published>2019-08-14T06:35:00.000Z</published>
    <updated>2019-08-14T09:56:41.604Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.java67.com/2014/02/how-to-find-largest-and-smallest-number-array-in-java.html" target="_blank" rel="noopener">原文</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于任何软件开发人员来说，很好地理解数组数据结构都是非常重要的，为了增进对其理解，初学者可以做很多编程练习。其中之一是编写一个程序来查找整数数组中最小和最大的数字。Java程序员与其他程序员一样，不仅仅是理解数组，还要知道关系操作符的使用。在这个程序中，您需要编写一个方法，它将接受整数数组，然后从该数组中打印最大和最小的数字。不允许使用任何第三方库或API方法，这意味着您需要使用Java编程语言的基本工具来完成这一练习，其中包括Java语言包中的运算符、控制语句、关键字和一些类。</p><p>该问题也被称为在数组中查找最大值和最小值，这里提到的技术也可以用在任何其他编程语言中。另外，您还可以编写JUnit测试用例来测试您的方法，我没有这样做，而是依赖简单的主方法来测试我的代码，显示输出结果并保持简短，这对于任何示例或演示都是必不可少的。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我们创建了一个名为largestAndSmallest（int[]numbers）的方法来打印传递给程序的int数组中最大和最小的数字。我们使用最大和最小两个变量来存储数组中的最大值和最小值。最初，最大值初始化为integer.MIN_VALUE，最小值初始化为integer.MAX_VALUE。</p><p>在循环的每个迭代中，我们将当前数字与最大值和最小值进行比较，并相应地更新它们。因为如果一个数字大于最大值，它不能小于最小值，这意味着如果第一个条件为真您不需要继续比较，这就是为什么我们使用if else代码块，而其他部分只在第一个条件不为真时执行。</p><p>这里有另一种逻辑，从Java中找到一个数组中最大的元素，这里不是用整数。</p><p>由于Java中数组不重写toString方法，所以我们使用Arrays.toString()来打印数组的内容。记住，这个函数不属于核心逻辑，所以可以使用它。由于这是一个静态的方法，我们可以直接从Java中的主方法调用它，我们的测试代码也是如此。我们将随机数组传递给这个方法，看看该方法返回的最大和最小数字是否正确。对于自动化测试，单元测试更好，但是为了演示，可以使用主要方法。</p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>参考代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java program to find largest and smallest number from an array in Java.</span></span><br><span class="line"><span class="comment"> * You cannot use any library method both from Java and third-party library.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumMinimumArrayDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        largestAndSmallest(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">20</span>, <span class="number">34</span>, <span class="number">21</span>, -<span class="number">87</span>, <span class="number">92</span>,</span><br><span class="line">                             Integer.MAX_VALUE&#125;);</span><br><span class="line">        largestAndSmallest(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, Integer.MIN_VALUE, -<span class="number">2</span>&#125;);</span><br><span class="line">        largestAndSmallest(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Integer.MAX_VALUE, <span class="number">40</span>,</span><br><span class="line">                             Integer.MAX_VALUE&#125;);</span><br><span class="line">        largestAndSmallest(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">largestAndSmallest</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> smallest = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; largest) &#123;</span><br><span class="line">                largest = number;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; smallest) &#123;</span><br><span class="line">                smallest = number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Given integer array : "</span> + Arrays.toString(numbers));</span><br><span class="line">        System.out.println(<span class="string">"Largest number in array is : "</span> + largest);</span><br><span class="line">        System.out.println(<span class="string">"Smallest number in array is : "</span> + smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given integer array : [-20, 34, 21, -87, 92, 2147483647]</span><br><span class="line">Largest number in array is : 2147483647</span><br><span class="line">Smallest number in array is : -87</span><br><span class="line">Given integer array : [10, -2147483648, -2]</span><br><span class="line">Largest number in array is : 10</span><br><span class="line">Smallest number in array is : -2147483648</span><br><span class="line">Given integer array : [2147483647, 40, 2147483647]</span><br><span class="line">Largest number in array is : 2147483647</span><br><span class="line">Smallest number in array is : 40</span><br><span class="line">Given integer array : [1, -1, 0]</span><br><span class="line">Largest number in array is : 1</span><br><span class="line">Smallest number in array is : -1</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这就是如何在Java中从整数数组中找到最大和最小数的问题。正如我所说的，这个问题也可以被问到如何用Java找到数组中的最大值和最小值，所以不要混淆。顺便说一句，有更多的方法来完成相同的任务，您可以通过实践来不同地编写解决方案的代码。你能写一个不同于这个的解决方案吗？去试一试吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.java67.com/2014/02/how-to-find-largest-and-smallest-number-array-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://www.haoming.fun/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="面试题精选" scheme="https://www.haoming.fun/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>数组：怎样不使用Java集合API从数组移除重复元素</title>
    <link href="https://www.haoming.fun/2019/08/13/%E6%95%B0%E7%BB%84%EF%BC%9A%E6%80%8E%E6%A0%B7%E4%B8%8D%E4%BD%BF%E7%94%A8Java%E9%9B%86%E5%90%88API%E4%BB%8E%E6%95%B0%E7%BB%84%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://www.haoming.fun/2019/08/13/数组：怎样不使用Java集合API从数组移除重复元素/</id>
    <published>2019-08-13T07:00:00.000Z</published>
    <updated>2019-08-14T09:57:21.609Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javarevisited.blogspot.com/2014/01/how-to-remove-duplicates-from-array-java-without-collection-API.html" target="_blank" rel="noopener">原文</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是在Java技术面试中经常遇到的一个编程问题。问题是在不使用任何集合API类（如set或linkedhashset）的情况下从整数数组中删除重复项，这可以使此任务变得简单。一般来说，如果您需要在任何项目工作中这样做，我建议更好地使用集合接口，尤其是LinkedHashSet，因为这也保持了元素插入集合的顺序。仅从技术面试的角度来看，您需要使用循环或递归来完成这项工作，这取决于您最擅长的领域是什么。本文分享了一个naive的解决方案，如果应用到生产环境会有很多限制，它不是最好的解决方案，但仍然是一个解决方案。</p><p>主要问题不是找到重复项，而是删除它们。由于数组是静态的固定长度数据结构，因此不能更改其长度。这意味着，从数组中删除元素需要创建一个新数组并将内容复制到该数组中。</p><p>如果输入数组包含大量重复项，那么这可能会导致大量临时数组。它还增加了复制内容的成本，这可能非常糟糕。考虑到这个限制，您需要制定一个策略来最小化内存和CPU需求。</p><p>在这个编程问题中，我们没有使用任何集合类来删除数组重复项，比如使用linkedhashset的删除重复项的方法。如果面试官没有特别提到具体的集合，你仍然可以使用这个解决方案。</p><p>您需要做的只是先将数组转换为arraylist，然后从该arraylist创建一个linkedhashset。在本例中，我们通过不将重复项复制到结果数组中来从数组中删除重复项，此解决方案实际上不是删除重复项，而是用默认值替换它。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>现在看看我们的Java解决方案，从整数数组中删除重复元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java program to remove duplicates from this array. You don't</span></span><br><span class="line"><span class="comment"> * need to physically delete duplicate elements, replacing with null, or</span></span><br><span class="line"><span class="comment"> * empty or default value is ok.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnicalInterviewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] test = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] input : test) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Array with Duplicates       : "</span> + Arrays.toString(input));</span><br><span class="line">            System.out.println(<span class="string">"After removing duplicates   : "</span> + Arrays.toString(removeDuplicates(input)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Method to remove duplicates from array in Java, without using</span></span><br><span class="line"><span class="comment">     * Collection classes e.g. Set or ArrayList. Algorithm for this</span></span><br><span class="line"><span class="comment">     * method is simple, it first sort the array and then compare adjacent</span></span><br><span class="line"><span class="comment">     * objects, leaving out duplicates, which is already in the result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] removeDuplicates(<span class="keyword">int</span>[] numbersWithDuplicates) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sorting array to bring duplicates together      </span></span><br><span class="line">        Arrays.sort(numbersWithDuplicates);     </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[numbersWithDuplicates.length];</span><br><span class="line">        <span class="keyword">int</span> previous = numbersWithDuplicates[<span class="number">0</span>];</span><br><span class="line">        result[<span class="number">0</span>] = previous;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbersWithDuplicates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = numbersWithDuplicates[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (previous != ch) &#123;</span><br><span class="line">                result[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array with Duplicates       : [1, 1, 2, 2, 3, 4, 5]</span><br><span class="line">After removing duplicates   : [1, 0, 2, 0, 3, 4, 5]</span><br><span class="line">Array with Duplicates       : [1, 1, 1, 1, 1, 1, 1]</span><br><span class="line">After removing duplicates   : [1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">Array with Duplicates       : [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">After removing duplicates   : [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">Array with Duplicates       : [1, 2, 1, 1, 1, 1, 1]</span><br><span class="line">After removing duplicates   : [1, 0, 0, 0, 0, 0, 2]</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这就是如何在不使用集合类的情况下从Java中删除重复数组的方法。正如我之前所说，这个解决方案并不完美，并且有一些严重的局限性，就当做一个练习留给您去发现吧。</p><p>关于从结果数组中永久删除重复项，一种方法可以是计算重复项的数量，然后创建一个大小正确的数组，即长度-重复项，然后将内容从中间结果数组复制到最终数组，去掉标记为重复项的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://javarevisited.blogspot.com/2014/01/how-to-remove-duplicates-from-array-java-without-collection-API.html&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://www.haoming.fun/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="面试题精选" scheme="https://www.haoming.fun/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>数组：怎样从1到100的整数数组中找出缺少的数字</title>
    <link href="https://www.haoming.fun/2019/08/13/%EF%BC%9A%E6%80%8E%E6%A0%B7%E4%BB%8E1%E5%88%B0100%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E7%BC%BA%E5%B0%91%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://www.haoming.fun/2019/08/13/：怎样从1到100的整数数组中找出缺少的数字/</id>
    <published>2019-08-13T05:52:00.000Z</published>
    <updated>2019-08-14T09:58:11.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编程面试中最常被问及的问题之一是，编写一个程序来查找数组中缺少的数字。这种编码面试问题不仅在小型初创企业中被问到，而且在谷歌、亚马逊、Facebook、微软等一些最大的技术公司中也被问到，大多是这些公司在校园招聘毕业生时会被问到。</p><p>这个问题最简单的版本是在100个整数的区域中查找缺少的元素，该区域包含1到100之间的数字。这可以通过使用n（n+1）/2计算序列的和很容易地解决，这也是最快和最有效的方法之一，但如果数组包含多个缺少的数字或数组包含重复的数字，则不能使用它。</p><p>这时面试官可以提出后续问题，以考查候选人不同条件下解决问题的能力。所以，如果你通过了这个，他们会要求你在一个重复的数组中找到丢失的数字。这可能很棘手，但您很快就会发现在数组中查找丢失和重复数字的另一种方法是对其进行排序。</p><p>在已排序的数组中，可以比较一个数字是否等于预期的下一个数字。或者，您也可以使用Java中的BitSet来解决这个问题。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们将1到100之间的数字放入一个整数数组中，找出缺少哪个数字的最佳方法是什么？如果面试官特别提到1到100，那么你也可以使用上面的技巧来计算这个系列的总和，如下所示。如果它有多个丢失的元素，那么您可以使用位集类，当然，只有在您的面试官允许的情况下。</p><p>1）级数和：公式：n（n+1）/2（但只适用于缺少的一个数）</p><p>2）如果数组缺少多个元素，则使用位集。</p><p>我提供了另一个目的的位集解决方案，以介绍这个不错的实用程序类。在许多采访中，我曾向Java开发人员询问过这个类，但许多人甚至没有意识到这一点。我认为这个问题是学习如何在Java中使用BITSET的好方法。</p><p>顺便说一句，如果你要去面试，除了这个问题，它还很好地知道如何在数组和程序中找到重复的数字，以在整数数组中找到第二个最高的数字。通常情况下，这些问题都会在这之后作为后续问题被问到。</p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>参考代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java program to find missing elements in a Integer array containing </span></span><br><span class="line"><span class="comment"> * numbers from 1 to 100.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">file</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// one missing number</span></span><br><span class="line">        printMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;, <span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// two missing number</span></span><br><span class="line">        printMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>&#125;, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// three missing number</span></span><br><span class="line">        printMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>&#125;, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// four missing number</span></span><br><span class="line">        printMissingNumber(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>&#125;, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Only one missing number in array</span></span><br><span class="line">        <span class="keyword">int</span>[] iArray = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> missing = getMissingNumber(iArray, <span class="number">5</span>);</span><br><span class="line">        System.out.printf(<span class="string">"Missing number in array %s is %d %n"</span>, </span><br><span class="line">                           Arrays.toString(iArray), missing);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A general method to find missing values from an integer array in Java.</span></span><br><span class="line"><span class="comment">    * This method will work even if array has more than one missing element.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMissingNumber</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missingCount = count - numbers.length;</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(count);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">            bitSet.set(number - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.printf(<span class="string">"Missing numbers in integer array %s, with total number %d is %n"</span>,</span><br><span class="line">        Arrays.toString(numbers), count);</span><br><span class="line">        <span class="keyword">int</span> lastMissingIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; missingCount; i++) &#123;</span><br><span class="line">            lastMissingIndex = bitSet.nextClearBit(lastMissingIndex);</span><br><span class="line">            System.out.println(++lastMissingIndex);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Java method to find missing number in array of size n containing</span></span><br><span class="line"><span class="comment">    * numbers from 1 to n only.</span></span><br><span class="line"><span class="comment">    * can be used to find missing elements on integer array of </span></span><br><span class="line"><span class="comment">    * numbers from 1 to 100 or 1 - 1000</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> totalCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedSum = totalCount * ((totalCount + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> actualSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line">            actualSum += i;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> expectedSum - actualSum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Missing numbers in integer array [1, 2, 3, 4, 6], with total number 6 is </span><br><span class="line">5</span><br><span class="line">Missing numbers in integer array [1, 2, 3, 4, 6, 7, 9, 8, 10], with total number 10 is </span><br><span class="line">5</span><br><span class="line">Missing numbers in integer array [1, 2, 3, 4, 6, 9, 8], with total number 10 is </span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">Missing numbers in integer array [1, 2, 3, 4, 9, 8], with total number 10 is </span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">Missing number in array [1, 2, 3, 5] is 4</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>您可以看到如何使用正确的数据结构轻松地解决问题，这是这个问题的关键收获，对于更多的编码问题，您可以查看<a href="https://aax-us-east.amazon-adsystem.com/x/c/Qu4OnSO4Lds0KdQhnHOM5-kAAAFsiYVQswEAAAFKAS9ktN4/https://assoc-redirect.amazon.com/g/r/http://www.amazon.com/Cracking-Coding-Interview-6th-Edition/dp/0984782850/?creativeASIN=0984782850&linkCode=w61&imprToken=ynLT416dutVM5EAZv6sv-g&slotNum=0&tag=javamysqlanta-20" target="_blank" rel="noopener">《the Cracking the Coding Interviews》</a>，这是来自谷歌、亚马逊、微软等科技公司编程面试的189个编码问题的集合。</p><p>这就是在一个由100个元素组成的数组中查找缺失元素的全部内容。正如我所说，了解这个技巧是很好的，它只需要计算数字的和，然后从实际和中减去它，但是如果数组中有多个缺少的数字，就不能使用这个技巧。另一方面，BitSet解决方案更通用，因为您可以使用它在整数数组中查找多个缺少的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;编程面试中最常被问及的问题之一是，编写一个程序来查找数组中缺少的数字。这种编码面试问题不仅在小型初创企业中被问到，而且在谷歌、亚马逊、Fac
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://www.haoming.fun/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="面试题精选" scheme="https://www.haoming.fun/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>Vue 编码风格官方指南整理</title>
    <link href="https://www.haoming.fun/2019/08/13/%E9%A3%8E%E6%A0%BC%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%E6%95%B4%E7%90%86/"/>
    <id>https://www.haoming.fun/2019/08/13/风格官方指南整理/</id>
    <published>2019-08-13T05:42:00.000Z</published>
    <updated>2019-08-13T05:45:32.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必要"><a href="#必要" class="headerlink" title="必要"></a>必要</h2><ol><li>组件名为多个单词</li></ol><p>组件名应该始终是多个单词的，根组件 App 以及 <transition>、 <component> 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突。</component></transition></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好例子</span></span><br><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'TodoItem'</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>组件的 data 必须是一个函数</li></ol><p>当在组件中使用 data 属性的时候 (除了 newVue 外的任何地方)，它的值必须是返回一个对象的函数。</p><ol start="3"><li>Prop 定义应该尽量详细</li></ol><p>在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好例子</span></span><br><span class="line">props: &#123;</span><br><span class="line">  status: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    validator:  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'syncing'</span>,</span><br><span class="line">        <span class="string">'synced'</span>,</span><br><span class="line">        <span class="string">'version-conflict'</span>, </span><br><span class="line">            <span class="string">'error'</span></span><br><span class="line">        ].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>避免 v-if 和 v-for 用在一起</li></ol><p>当 Vue 处理指令时， v-for 比 v-if 具有更高的优先级</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ol><li>组件文件</li></ol><p>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。</p><p>当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。  </p><ol start="2"><li>组件名中的单词顺序</li></ol><p>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</p><p>要注意在你的应用中所谓的“高级别”是跟语境有关的。</p><p>比如对于一个带搜索表单的应用来说，它可能包含这样的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- ClearSearchButton.vue</span><br><span class="line">|- ExcludeFromSearchInput.vue</span><br><span class="line">|- LaunchOnStartupCheckbox.vue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面命名难看出哪些是针对搜索的，重新命名如下：</span></span><br><span class="line">components/</span><br><span class="line">|- SearchButtonClear.vue</span><br><span class="line">|- SearchInputExcludeGlob.vue</span><br><span class="line">|- SettingsCheckboxLaunchOnStartup.vue</span><br></pre></td></tr></table></figure><p>因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。<br>你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为：</p><ul><li>在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。</li><li>存在组件重名 (比如存在多个 ButtonDelete 组件) 的时候在编辑器里更难快速定位。</li><li>让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。</li></ul><ol start="3"><li>完整单词的组件名</li></ol><p>组件名应该倾向于完整单词而不是缩写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SdSettings.vue</span><br><span class="line">vs</span><br><span class="line">StudentDashboardSettings.vue <span class="comment">// 好例子</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Prop 名大小写</li></ol><p>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。</p><p>我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line">props: &#123;</span><br><span class="line">    <span class="string">'greeting-text'</span>: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 好例子</span></span><br><span class="line">props: &#123;</span><br><span class="line">    <span class="string">'greetingText'</span>: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>多个特性的元素</li></ol><p>多个特性的元素应该分多行撰写，每个特性一行。<br>在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的例子</span></span><br><span class="line"></span><br><span class="line">&lt;img</span><br><span class="line">    src=<span class="string">"https://vuejs.org/images/logo.png"</span></span><br><span class="line">    alt=<span class="string">"Vue Logo"</span> &gt;</span><br><span class="line">&lt;my-component</span><br><span class="line">    foo=<span class="string">"a"</span></span><br><span class="line">    bar=<span class="string">"b"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/my-component&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>简单的计算属性</li></ol><p>应该把复杂计算属性分割为尽可能多的更简单的计算属性。</p><p>更简单、命名得当的计算属性是这样的：</p><ul><li>易于测试<br>当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。</li><li>易于阅读<br>简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。</li><li>更好的“拥抱变化”<br>任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。<br>小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</li></ul><h2 id="谨慎使用（有潜在危险的模式）"><a href="#谨慎使用（有潜在危险的模式）" class="headerlink" title="谨慎使用（有潜在危险的模式）"></a>谨慎使用（有潜在危险的模式）</h2><ol><li>没有在 v-if/ v-else-if/ v-else 中使用 key</li></ol><p>如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 <code>&lt;div&gt;</code> 元素)。<br>默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 好的例子--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"error"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">key</span>=<span class="string">"search-status"</span>&gt;</span></span><br><span class="line">    错误：&#123;&#123; error &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-else</span></span></span><br><span class="line"><span class="tag">    <span class="attr">key</span>=<span class="string">"search-results"</span>&gt;</span></span><br><span class="line">    &#123;&#123; results &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>scoped 中的元素选择器</li></ol><p>在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。<br>大量的元素和特性组合的选择器 (比如 <code>button[data-v-f3f3eg9]</code>) 会比类和特性组合的选择器慢，所以应该尽可能选用类选择器。</p><ol start="3"><li>隐性的父子组件通信</li></ol><p>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。<br>这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</p><ol start="4"><li>非 Flux 的全局状态管理 </li></ol><p>应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。<br>通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。Vuex 提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;必要&quot;&gt;&lt;a href=&quot;#必要&quot; class=&quot;headerlink&quot; title=&quot;必要&quot;&gt;&lt;/a&gt;必要&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;组件名为多个单词&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组件名应该始终是多个单词的，根组件 App 以及 &lt;transition&gt;、 &lt;c
      
    
    </summary>
    
      <category term="编码规范" scheme="https://www.haoming.fun/categories/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="编码规范" scheme="https://www.haoming.fun/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>vs code 常用快捷键</title>
    <link href="https://www.haoming.fun/2019/07/30/vs-code-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://www.haoming.fun/2019/07/30/vs-code-常用快捷键/</id>
    <published>2019-07-30T10:48:00.000Z</published>
    <updated>2019-07-30T11:05:47.906Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>一次搜索所有文件的文本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows: Ctrl + Shift + F</span><br><span class="line">Mac: Command + Shift + F</span><br></pre></td></tr></table></figure></li><li><p>设置主题皮肤，Tab强调色</p></li></ol><p>使用 Material Theme 来扩展 VsCode 的主题；</p><p>快捷键 <code>Ctrl + Shift + P</code>，选择 <code>Material Theme: Set accent color</code>并从列表中选择一个颜色，它将更改选项卡的下划线颜色</p><ol start="3"><li><p>重新打开 关闭的编辑页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows: Ctrl + Shift + T</span><br><span class="line">Mac: command + Shift + T</span><br></pre></td></tr></table></figure></li><li><p>集成终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows: Ctrl + `</span><br><span class="line">Mac: control + `</span><br></pre></td></tr></table></figure></li></ol><p>通过 Ctrl + ` 可以打开或关闭终端</p><ol start="5"><li>查看正在运行的插件</li></ol><p>按下快捷键<code>Ctrl + Shift + P</code>，并输入`Show running extensions来查看所有你安装的正在运行的插件</p><ol start="6"><li>将选项卡交换到不同的组</li></ol><p>通过按<code>Ctrl + Alt +右箭头</code>（Mac：<code>Control + Option +右箭头</code>）将标签移动到右侧的组，或者按<code>Ctrl + Alt + 左箭头</code>将标签转移到单独的标签组 （Mac：<code>Control + Option +左箭头</code>））将标签移动到左侧的组</p><ol start="7"><li>选择左侧/右侧的所有内容</li></ol><p>你可以选择光标右侧或左侧的所有内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows: Ctrl + Shift + Home/End</span><br><span class="line">Mac: command + Shift + Home/End</span><br></pre></td></tr></table></figure><p>苹果笔记本没home键，可以用组合键实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn键+左方向键是HOME</span><br><span class="line"></span><br><span class="line">fn键+右方向键是END</span><br><span class="line"></span><br><span class="line">fn+上方向键是page up</span><br><span class="line"></span><br><span class="line">fn+下方向键是page down</span><br></pre></td></tr></table></figure><ol start="8"><li>删除上一个单词</li></ol><p>要删除前一个单词，可以按<code>Ctrl + Backspace</code> (Mac: <code>option + delete)</code>。这在你打错字的时候非常有用。</p><ol start="9"><li>逐个选择文本</li></ol><p>可以通过快捷键<code>Ctrl + Shift +右箭头</code>(Mac: <code>option + Shift +右箭头</code>)和<code>Ctrl + Shift +左箭头</code>(Mac: <code>option + Shift +左箭头</code>)逐个选择文本</p><ol start="10"><li>重复的行</li></ol><p>复制行只需按 <code>Shift + Alt + 向下箭头</code> (Mac: <code>command + Shift + 向下箭头</code>)</p><ol start="11"><li>移至文件的开头/结尾</li></ol><p>使光标移到文件的第一行或最后一行，最快的方法是按<code>Ctrl + Home</code>(Mac: <code>command + Home</code>)键开头，然后按<code>Ctrl + End</code> (Mac: <code>command + End</code>)键结尾</p><ol start="12"><li>批量修改文本</li></ol><p>可以选择任何一组文本，如果该选中文本出现多个，可以通过按<code>Ctrl + F2</code> (Mac: <code>command + F2</code>)一次改所有出现的文本。</p><ol start="13"><li>向上/向下移动一行</li></ol><p>按<code>Alt + 向上箭头</code>(Mac: <code>command+ 向上箭头</code>)当前行向上移动，按<code>Alt + 向下箭头</code>(Mac: <code>command+ 向下箭头</code>))当前行向下移动</p><ol start="14"><li>删除一行</li></ol><p>使用<code>Ctrl + X</code>剪切命令(Mac：<code>command + X</code>)来删除一行</p><p>或者使用 <code>Ctrl + Shift + K</code>(Mac: <code>command + Shift + K</code>)命令</p><ol start="15"><li>将编辑器向左或向右移动</li></ol><p>通过 <code>Ctrl+Shift+PgUp/PgDown</code>(Mac: <code>command + +Shift+PgUp/PgDown</code>)向左/向右移动编辑器</p><ol start="16"><li>复制光标向上或者向上批量添加内容</li></ol><p>按<code>Ctrl + Alt +向上箭头</code>(Mac: <code>Control + Option +向上箭头</code>)将光标添加到上面，按<code>Ctrl + Alt +向下箭头</code>(Mac: <code>Control + Option + 向下箭头</code>)将光标添加到下面</p><p>选中了多行的光标后，可以按左右键或者End键，然后可以在多个光标位置，批量添加内容。</p><p>以上，try and enjoy it！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;一次搜索所有文件的文本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="IDE" scheme="https://www.haoming.fun/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>中止HTTP请求或文件上传的方法解析</title>
    <link href="https://www.haoming.fun/2019/06/30/%E4%B8%AD%E6%AD%A2HTTP%E8%AF%B7%E6%B1%82%E6%88%96%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.haoming.fun/2019/06/30/中止HTTP请求或文件上传的方法解析/</id>
    <published>2019-06-30T14:23:00.000Z</published>
    <updated>2019-06-30T14:24:17.437Z</updated>
    
    <content type="html"><![CDATA[<p>某些场景，比如切换TAB、关闭窗口或手动触发中止时，我们想取消正在执行中的HTTP请求，特别当上传大文件时候会有中止上传的需求。开始以为中断通信，当socket传输数据时比较好处理。后来一查原来ajax请求中也能处理。</p><ol><li>先看用原生js如何中断http请求<br>API：<code>XMLHttpRequest.abort()</code><br>如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。<br>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</span><br><span class="line">    method = <span class="string">"GET"</span>,</span><br><span class="line">    url = <span class="string">"https://developer.mozilla.org/"</span>;</span><br><span class="line">xhr.open(method,url,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure></li></ol><p>然后想到axios拦截器应该也能中断请求吧</p><ol start="2"><li>Axios拦截器如何中止HTTP请求<br>Axios能使用一个取消token来取消一个请求<blockquote><p>Axios 取消token API 基于 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">JS可取消去异步操作的建议</a></p></blockquote></li></ol><p>可以使用<code>CancelToken.source</code>工厂来生成一个cancel token：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request (the message parameter is optional)</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by the user.'</span>);</span><br></pre></td></tr></table></figure><p>注意，get请求的时候，cancelToken是放在第二个参数里；post的时候，cancelToken是放在第三个参数里。<br>每次执行<code>CancelToken.source()</code>，就会返回一个包含新的“CancelToken”的对象。<br>调用<code>source.cancel()</code>以后，实际执行的是以下函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token.reason) &#123;</span><br><span class="line">        <span class="comment">// Cancellation has already been requested</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">     resolvePromise(token.reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法一旦resolvePromise以后，就会触发promise的then方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">     <span class="comment">// Handle cancellation</span></span><br><span class="line">     config.cancelToken.promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onCanceled</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         request.abort();</span><br><span class="line">         reject(cancel);</span><br><span class="line">         <span class="comment">// Clean up request</span></span><br><span class="line">         request = <span class="literal">null</span>;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 实际上执行abort方法来中止请求，同时调用reject让外层的promise失败。</p><ol start="3"><li>jQuery上传文件中执行取消<br>jQuery通常上传文件会用到<code>jquery.fileupload.js</code>，那么用它上传文件的时候，怎么取消呢？<br>同第一点那样可以通过<code>XMLHttpRequest.abort()</code>来取消，示例代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$( &apos;#fileUpload&apos; ).fileupload( &#123;</span><br><span class="line">        dataType: &apos;json&apos;,</span><br><span class="line">        add: function( e, data ) &#123;</span><br><span class="line">            var abortBtn = $( &apos;&lt;a/&gt;&apos; )</span><br><span class="line">                .attr( &apos;href&apos;, &apos;javascript:void(0)&apos; )</span><br><span class="line">                .append( &apos;Abort&apos; )</span><br><span class="line">                .click( function() &#123;</span><br><span class="line">                    data.abort();</span><br><span class="line">                    data.context.remove();</span><br><span class="line">                &#125; );</span><br><span class="line"></span><br><span class="line">            data.context = $( &apos;&lt;div/&gt;&apos; )</span><br><span class="line">                .appendTo( document.body );</span><br><span class="line"></span><br><span class="line">            data.context.append( $( &apos;&lt;p/&gt;&apos; ) )</span><br><span class="line">                .append( &apos;Uploading &apos; + data.files[0].name )</span><br><span class="line">                .append( abortBtn );</span><br><span class="line"></span><br><span class="line">            data.submit();</span><br><span class="line">        &#125;,</span><br><span class="line">        done: function( e, data ) &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>上面介绍了中止HTTP请求或文件上传的两种请情况。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort" target="_blank" rel="noopener">https://github.com/axios/axios#cancellation</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort" target="_blank" rel="noopener">http://www.qiutianaimeili.com/html/page/2019/03/8grudzwvfmq.html</a></p><p><a href="https://stackoverflow.com/questions/26218571/how-to-add-a-cancel-upload-button-to-jquery-file-upload-basic-plugin" target="_blank" rel="noopener">https://stackoverflow.com/questions/26218571/how-to-add-a-cancel-upload-button-to-jquery-file-upload-basic-plugin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某些场景，比如切换TAB、关闭窗口或手动触发中止时，我们想取消正在执行中的HTTP请求，特别当上传大文件时候会有中止上传的需求。开始以为中断通信，当socket传输数据时比较好处理。后来一查原来ajax请求中也能处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先看用原生js如何中断htt
      
    
    </summary>
    
      <category term="前端" scheme="https://www.haoming.fun/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="经验总结" scheme="https://www.haoming.fun/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何使用GraphQL,Koa和MongoDB建立强大的API</title>
    <link href="https://www.haoming.fun/2019/06/30/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GraphQL-Koa%E5%92%8CMongoDB%E5%BB%BA%E7%AB%8B%E5%BC%BA%E5%A4%A7%E7%9A%84API/"/>
    <id>https://www.haoming.fun/2019/06/30/如何使用GraphQL-Koa和MongoDB建立强大的API/</id>
    <published>2019-06-30T14:16:00.000Z</published>
    <updated>2019-06-30T14:21:43.229Z</updated>
    
    <content type="html"><![CDATA[<p>构建API是很有趣的，特别当你可以在项目中使用诸如koa、graphql和mongodb等技术的时候。</p><p>和Express一样，koa是一个Node框架，很多功能需要借助第三方中间件解决，由于其基于ES6 generator特性的异步流程控制，解决了”回调地狱”和麻烦的错误处理问题，大受开发者欢迎。Express采用callback来处理异步，Koa v1采用generator，Koa v2采用async/await。<br>enerator和async/await使用同步的写法来处理异步，明显好于callback和promise，而async/await在语义化上又要比generator更强。</p><p><img src="https://www.haoming.fun/images/koa.png" alt="koa"></p><p><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">Koa Github 仓库</a><br><a href="https://github.com/expressjs/express" target="_blank" rel="noopener">Express Github 仓库</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>构建API的先决条件如下：</p><ul><li>安装Node</li><li>IDE，建议VS code</li><li>命令行终端</li><li>浏览器</li></ul><p>如果具备了上述的条件，可以继续下面的工作了；如果没有的话，请安装它们。</p><p>打开终端，创建一个node项目，像这样：<br><img src="https://www.haoming.fun/images/init.png" alt="init project"><br>目前为止， 我们创建了项目目录，初始化一个新的node项目。接下来我们通过npm包来安装Koa、Mongo和GraphQL。<br>首先安装koa：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa</span><br></pre></td></tr></table></figure><p>启动一个新的Koa服务非常简单。我们需要一个<code>server.js</code>文件，它的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.listen(<span class="number">9000</span>);</span><br><span class="line">app.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  log.error(<span class="string">'server error'</span>, err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Node启动项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>我们需要使用<code>koa-mount</code>和<code>koa-graphql</code>两个包来安装GraphQL，后者创建Graphql HTTP服务，前者将Koa应用挂载为中间件（挂载到某个路径上）,然后安装依赖包<code>graphql</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa-mount koa-graphql graphql</span><br></pre></td></tr></table></figure><p><img src="https://www.haoming.fun/images/koa-mount.png" alt="koa-mount"><br><img src="https://www.haoming.fun/images/koa-graphql.png" alt="koa-graphql"><br>GraphQL需要传递初始的模式（schema）给GraphQL服务。下面创建一个：将Graphql schema放到<code>graphql/schema.js</code>里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    hello: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = schema;</span><br></pre></td></tr></table></figure><p>将Query类传给buildSchema函数，这里它的参数使用了模版字符串。<br>现在我们能将初始的schema传给graphql服务了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(mount(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">  schema: schema,</span><br><span class="line">  graphiql: <span class="literal">true</span></span><br><span class="line">&#125;)))</span><br></pre></td></tr></table></figure><p>不要忘了导入<code>koa-mount</code>、<code>koa-graphql</code>，以及<code>schema.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = <span class="built_in">require</span>(<span class="string">'koa-mount'</span>);</span><br><span class="line"><span class="keyword">const</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'koa-graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="built_in">require</span>(<span class="string">'https://www.haoming.fun/images/graphql/schema'</span>);</span><br></pre></td></tr></table></figure><p>通过node启动<code>server.js</code>以后，在浏览器地址栏访问<code>localhost:9000/graphql</code><br><img src="https://www.haoming.fun/images/graphql-query.png" alt="access graphql"><br>最初的构建完成，但还不是很有用。我们还想通过 grahql API 来查询 MongoDB 保存的数据。</p><h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><p>为了使用GraphQL来读写数据，我们需要有个读写的来源，这就是MongoDB。下面介绍如何在Centos上安装MongoDB。</p><h3 id="创建yum源文件"><a href="#创建yum源文件" class="headerlink" title="创建yum源文件"></a>创建yum源文件</h3><p><code>vim /etc/yum.repos.d/mongodb-org-4.0.repo</code><br>添加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><h3 id="使用-yum-安装MongoDB"><a href="#使用-yum-安装MongoDB" class="headerlink" title="使用 yum 安装MongoDB"></a>使用 yum 安装MongoDB</h3><p><code>yum install -y mongodb-org</code></p><h3 id="配置MongoDB"><a href="#配置MongoDB" class="headerlink" title="配置MongoDB"></a>配置MongoDB</h3><p><code>vim /etc/mongod.conf</code><br>配置<code>mongod.conf</code>来开启远程连接： 把第30行<code>bindIp: 127.0.0.1</code>改为<code>bindIp: 0.0.0.0</code></p><h3 id="启动MongoDB服务"><a href="#启动MongoDB服务" class="headerlink" title="启动MongoDB服务"></a>启动MongoDB服务</h3><p><code>systemctl start mongod</code><br>服务器本地连接测试<br><code>mongo --host 127.0.0.1 --port 27017</code></p><h3 id="本地连接MongoDB需要开启防火墙访问策略："><a href="#本地连接MongoDB需要开启防火墙访问策略：" class="headerlink" title="本地连接MongoDB需要开启防火墙访问策略："></a>本地连接MongoDB需要开启防火墙访问策略：</h3><p><img src="https://www.haoming.fun/images/open-firewall.png" alt="open firewall"></p><h3 id="另外附上：启用-停止-重启-MongoDB-服务的命令"><a href="#另外附上：启用-停止-重启-MongoDB-服务的命令" class="headerlink" title="另外附上：启用/停止/重启 MongoDB 服务的命令"></a>另外附上：启用/停止/重启 MongoDB 服务的命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mongod.service　　</span><br><span class="line">systemctl stop  mongod.service　　</span><br><span class="line">systemctl restart mongod.service</span><br></pre></td></tr></table></figure><h3 id="创建MongoDB用户"><a href="#创建MongoDB用户" class="headerlink" title="创建MongoDB用户"></a>创建MongoDB用户</h3><p>创建数据库用户，可以参考<a href="https://www.cnblogs.com/damingge/p/6507605.html" target="_blank" rel="noopener">MongoDB 用户权限管理</a></p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在 MongoDB 中默认数据库是：test。 如果还没有创建过任何数据库，则集合/文档将存储在test数据库中。新建数据库可以参考<a href="https://www.cnblogs.com/haoliansheng/p/4390267.html" target="_blank" rel="noopener">怎么创建MongoDB数据库</a></p><h2 id="数据库连接测试"><a href="#数据库连接测试" class="headerlink" title="数据库连接测试"></a>数据库连接测试</h2><p>连接MongoDB的客户端很多，这里选择Robo 3T，新建MongoDB连接如下：<br><img src="https://www.haoming.fun/images/connect1.png" alt="连接"><br><img src="https://www.haoming.fun/images/connect2.png" alt="认证"></p><p>现在我们能使用Mongoose来和MongoDB配对。远程连接数据库的URL像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb:<span class="comment">//$&#123;mongoAuth.user&#125;:$&#123;mongoAuth.pass&#125;@$&#123;ip&#125;:$&#123;port&#125;/$&#123;db&#125;&amp;authMechanism=SCRAM-SHA-256?authSource=admin</span></span><br></pre></td></tr></table></figure><p>安装mongoose</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><p>创建一个专门用来连接数据库的文件<code>database.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initDB = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  mongoose.connect(</span><br><span class="line">    <span class="string">'mongodb://admin:password@47.99.xx.xx/test?authSource=admin&amp;authMechanism=SCRAM-SHA-256'</span>,</span><br><span class="line">    &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  );</span><br><span class="line">  mongoose.connection.once(<span class="string">'open'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'connected to database'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = initDB;</span><br></pre></td></tr></table></figure><p>注意：MongoDB的连接字符串保证是能验证通过的。上面的代码块完成数据库连接的测试。我们需要将<code>database.js</code>引入到<code>server.js</code>，并调用initDB。<code>server.js</code>加入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initDB = <span class="built_in">require</span>(<span class="string">'https://www.haoming.fun/images/database'</span>);</span><br><span class="line"></span><br><span class="line">initDB();</span><br></pre></td></tr></table></figure><p>如果以上的各个步骤都正确完成，控制台会打印“connected to databse”。<br><img src="https://www.haoming.fun/images/connect3.png" alt="connect success"></p><p>怎样可以不用每次修改代码以后，重新启动server呢？我们可以安装<a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">PM2</a>来达到热加载的目的。先全局安装pm2包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><p>再在<code>package.json</code>中添加启动脚本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"pm2 start server.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行<code>yarn run start</code>命令来启动我们的node服务。<br><img src="https://www.haoming.fun/images/pm2.png" alt="pm2 start server"><br>这样服务就在后台运行了，如果想杀掉进程，可以使用<code>pm2 kill</code>。现在我们不必一直重启我们的服务，pm2会自动刷新服务。</p><h2 id="MongoDB-模型"><a href="#MongoDB-模型" class="headerlink" title="MongoDB 模型"></a>MongoDB 模型</h2><p>如果你以前使用过Mongo，你应该知道MongoDB让我们为数据创建模型。对于我们来说，这是一个很好的方法来构造数据的结构。<br>创建一个models目录，下面创建一个文件<code>gadget.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  注意这里没有ID字段. 因为MongoDB会为所有Schema分配默认ID</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> GadgetSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  release_date: <span class="built_in">Date</span>,</span><br><span class="line">  by_company: <span class="built_in">String</span>,</span><br><span class="line">  price: <span class="built_in">Number</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'Gadget'</span>, GadgetSchema);</span><br></pre></td></tr></table></figure><p>接下来需要在数据库添加一个集合和一次测试数据，对应的集合名必须是复数，这里用<code>gadgets</code>.<br><img src="https://www.haoming.fun/images/gadgets1.png" alt="gadgets"></p><h2 id="GraphQL-查询"><a href="#GraphQL-查询" class="headerlink" title="GraphQL 查询"></a>GraphQL 查询</h2><p>GrpahQL需要我们创建类型，可以将它类比为计算机指令一样。<br><code>https://www.haoming.fun/images/graphql/gadgetType.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graphql = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; GraphQLObjectType, GraphQLString &#125; = graphql;</span><br><span class="line"><span class="keyword">const</span> GadgetType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">'Gadget'</span>,</span><br><span class="line">  fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = GadgetType;</span><br></pre></td></tr></table></figure><p>我们创建了一个graphql类型，然后再具体定义给定类型内部的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graphql = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; GraphQLObjectType, GraphQLString &#125; = graphql;</span><br><span class="line"><span class="keyword">const</span> GadgetType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">'Gadget'</span>,</span><br><span class="line">  fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    id: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    name: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    release_date: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    by_company: &#123; <span class="attr">type</span>: GraphQLString &#125;,</span><br><span class="line">    price: &#123; <span class="attr">type</span>: GraphQLString &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = GadgetType;</span><br></pre></td></tr></table></figure><p>注意将<code>GraphQLObjectType</code>和<code>GraphQLObjectType</code>从graphql解构出来，它们是graphql的基本类型。创建GraphQL类型使得创建查询语句时会有类型提示。</p><p>最后一件事情是重构<code>schema.js</code>。我们想通过id查询gadget。向<code>schema.js</code>导入模型Gadget，从graphql导入``GraphQLSchema<code>、</code>GraphQLObjectType<code>、</code>GraphQLString<code>，以及导入graphql类型</code>gadgetGraphQLType`。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; GraphQLSchema, GraphQLObjectType, GraphQLString&#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> gadgetGraphQLType =  <span class="built_in">require</span>(<span class="string">'https://www.haoming.fun/images/gadgetType'</span>);</span><br><span class="line"><span class="keyword">const</span> Gadget = <span class="built_in">require</span>(<span class="string">'.https://www.haoming.fun/images/models/gadget'</span>);</span><br></pre></td></tr></table></figure><p>接下来需要一个根查询，每个graphql查询都以花括号开头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RootQuery = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">  name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    gadget: &#123;</span><br><span class="line">      type: gadgetGraphQLType,</span><br><span class="line">      args: &#123; <span class="attr">id</span>: &#123; <span class="attr">type</span>: GraphQLString &#125;&#125;,</span><br><span class="line">      resolve(parent, args) &#123;</span><br><span class="line">        <span class="keyword">return</span> Gadget.findById(args.id)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>gadget查询里面有三个属性：</p><ul><li>type-查询的类型</li><li>args-提供给graphql查询的参数</li><li>resolve-查询完成后要做什么？这里是按照id返回gadget</li></ul><p>最后导出schema：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">  query: RootQuery</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在浏览器地址栏输入 <a href="http://localhost:9000/graphql" target="_blank" rel="noopener">http://localhost:9000/graphql</a> ，然后编写查询语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    gadget(id: <span class="string">"5cc5109a41aedb25d85c211d"</span>) &#123;</span><br><span class="line">        name</span><br><span class="line">        price</span><br><span class="line">        by_company</span><br><span class="line">        release_date</span><br><span class="line">        id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的查询结果应该是这样：<br><img src="https://www.haoming.fun/images/query.png" alt="graphql query"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/sybboy/p/6418526.html" target="_blank" rel="noopener">https://www.cnblogs.com/sybboy/p/6418526.html</a><br><a href="https://www.cnblogs.com/haoliansheng/p/4390267.html" target="_blank" rel="noopener">https://www.cnblogs.com/haoliansheng/p/4390267.html</a><br><a href="https://www.cnblogs.com/damingge/p/6507605.html" target="_blank" rel="noopener">https://www.cnblogs.com/damingge/p/6507605.html</a><br><a href="https://www.yiibai.com/mongodb/mongodb_create_database.html" target="_blank" rel="noopener">https://www.yiibai.com/mongodb/mongodb_create_database.html</a><br><a href="https://www.strilliant.com/2019/01/27/how-to-setup-a-powerful-api-with-graphql-koa-and-mongodb/" target="_blank" rel="noopener">https://www.strilliant.com/2019/01/27/how-to-setup-a-powerful-api-with-graphql-koa-and-mongodb/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;构建API是很有趣的，特别当你可以在项目中使用诸如koa、graphql和mongodb等技术的时候。&lt;/p&gt;
&lt;p&gt;和Express一样，koa是一个Node框架，很多功能需要借助第三方中间件解决，由于其基于ES6 generator特性的异步流程控制，解决了”回调地狱”
      
    
    </summary>
    
      <category term="前端" scheme="https://www.haoming.fun/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="API" scheme="https://www.haoming.fun/tags/API/"/>
    
      <category term="GraphQL" scheme="https://www.haoming.fun/tags/GraphQL/"/>
    
      <category term="Koa" scheme="https://www.haoming.fun/tags/Koa/"/>
    
      <category term="MongoDB" scheme="https://www.haoming.fun/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>IE下将Web中的SVG导出PNG图片</title>
    <link href="https://www.haoming.fun/2019/04/29/IE%E4%B8%8B%E5%B0%86Web%E4%B8%AD%E7%9A%84SVG%E5%AF%BC%E5%87%BAPNG%E5%9B%BE%E7%89%87/"/>
    <id>https://www.haoming.fun/2019/04/29/IE下将Web中的SVG导出PNG图片/</id>
    <published>2019-04-29T12:15:00.000Z</published>
    <updated>2019-06-30T04:11:36.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文的目的是介绍一种将Web中SVG元素导出成PNG图片的方法，并阐述如何通过修改插件源码做到兼容IE浏览器（IE10以及以上）。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图形一般分为两种：矢量图和栅格图。所谓栅格图就是由固定数量的正方形像素（简称“图元”）组成，每个像素填充一种颜色。JPG、PNG、GIF格式的数组图像都属于栅格图。栅格图有一个明显的特征，即缩放时会变得模糊，更确切地说，是像素化。这是由其渲染方式造成的。而矢量图不会被像素化，SVG可缩放矢量图形，是W3C XML的分支语言之一，用于标记可缩放的矢量图形，已经成为一项Web标准技术，IE8以上主流浏览器能够解析其提供的绘图指令。<br>因为SVG可缩放的特性以及实现了DOM接口，我们会利用其提供的元素和接口编程绘制复杂的组合图形。目前我们有一个功能需求就是将Web中复杂的SVG图形导出成PNG这样的图片文件。我们在页面上绘制的SVG图形包含若干矩形、圆、线、文本、嵌入的svg图片等。</p><h2 id="SVG图形导出PNG图片"><a href="#SVG图形导出PNG图片" class="headerlink" title="SVG图形导出PNG图片"></a>SVG图形导出PNG图片</h2><p>需要将D3.js绘制的图形导出并下载成为PNG图片文件，通过查阅资料发现<a href="https://github.com/exupero/saveSvgAsPng" target="_blank" rel="noopener">saveSvgAsPng.js</a>对嵌入图片的SVG图形和图形中设定的样式支持较好，在Chrome中能将Web的Svg图形导出Png图片成功。</p><h3 id="安装使用saveSvgAspng"><a href="#安装使用saveSvgAspng" class="headerlink" title="安装使用saveSvgAspng"></a>安装使用saveSvgAspng</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install save-svg-as-png</span><br></pre></td></tr></table></figure><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>SaveSvgAsPng依赖JavaScript的promise，所以不支持标准<code>Promise</code>对象的浏览器需要有个polyfill（IE说你们都看我干嘛？！）。下面是在项目中安装和配置babel/polyfill，它提供完整ES2015+环境所需的polyfill(垫片)：</p><ol><li><p>安装依赖</p><figure class="highlight plain"><figcaption><span>install --save @babel/polyfill```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 在入口文件main.js引入依赖</span><br><span class="line">```import &apos;@babel/polyfill&apos;</span><br></pre></td></tr></table></figure></li><li><p>修改babel.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      &apos;@vue/app&apos;,</span><br><span class="line">      &#123;</span><br><span class="line">        useBuiltIns: &apos;entry&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 .browserslistrc 目标浏览器配置<br>根据提供的目标浏览器的环境来，智能添加css前缀，js的polyfill垫片,来兼容旧版本浏览器。避免不必要的兼容代码，以提高代码的编译质量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1%</span><br><span class="line">last 2 versions</span><br><span class="line">not ie &lt;= 9</span><br></pre></td></tr></table></figure></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>为了保存png图片，在页面中包含<code>saveSvgAsPng.js</code>脚本，然后用一个SVG节点和一个文件名作为参数来调用<code>saveSvgAsPng</code>函数。<br>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; svgAsDataUri, saveSvgAsPng &#125; from &apos;saveSvgAsPng&apos; // 导入方法</span><br><span class="line">saveSvgAsPng(document.getElementById(&quot;diagram&quot;), &quot;diagram.png&quot;) // 保存png图片</span><br></pre></td></tr></table></figure><p>如果想获得SVG的dataURL，然后定义一个回调。我们可以将SVG节点，options，回调函数作为参数来调用<code>svgAsDataUri</code>方法，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import canvg from &apos;canvg&apos;</span><br><span class="line">svgAsPngUri(document.querySelector(`#$&#123;id&#125; svg`), &#123; backgroundColor: &apos;#fff&apos;, canvg: canvg &#125;, (uri) =&gt; &#123;</span><br><span class="line">    // 回调自定义处理逻辑</span><br><span class="line">    const imageName = &apos;pngFileName.png&apos;</span><br><span class="line">    downloadImage(imageName, uri) // url下载成png图片</span><br><span class="line">    loading.close() // 关闭loading</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例代码的选项说明如下：</p><ul><li>backgroundColor - 创建一个PNG采用设定的背景颜色，默认是透明的</li><li>canvg - 如果传入canvg参数，用来将SVG转为Canvas，以支持IE</li><li>其他参见插件README</li></ul><h3 id="IE下saveSvgAsPng的兼容问题"><a href="#IE下saveSvgAsPng的兼容问题" class="headerlink" title="IE下saveSvgAsPng的兼容问题"></a>IE下saveSvgAsPng的兼容问题</h3><p>虽然saveSvgAsPng提供了canvg参数以兼容IE，实际经过IE11的测试发现：即便传入canvg参数，在插件调用canvas的<code>toDataURL</code>方法时仍然会抛出<code>SecurityError</code>异常。<br>为了兼容IE，我们还要借助<a href="https://github.com/canvg/canvg" target="_blank" rel="noopener">canvg</a>插件，它是Canvas上SVG的解析器和渲染器，它获取SVG文件的URL或者文本，用JavaScript解析，并在Canvas元素上呈现结果。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>通过分析saveSvgAsPng的源码得知它<code>svgAsPngUri</code>方法的执行有三个步骤：</p><ol><li>将获取传入svg节点中的所有image元素，也就是内部嵌入的图片元素，通过在canvas上绘制改图形的办法来获取内联图片的dataURL，将其设置为图片href属性。</li><li>获取页面中的所有css样式，并将svg节点克隆一份，创建style标签，将所有的css样式代码插入到style标签内，将style标签插入到克隆节点的后面，将它们(HTML)一起作为src返回</li><li>按照以上步骤完成准备工作以后，将上面的src作为内容绘制到canvas上面，再调用canvas的toDataURL方法获得uri并返回给回调函数。这一步需要判断是否传入canvg参数，如果传入的话则调用canvg方法将src转换为canvas，以达到调用<code>canvas.toDataURL()</code>不会报错。<h4 id="解决IE下导出图片文件报错"><a href="#解决IE下导出图片文件报错" class="headerlink" title="解决IE下导出图片文件报错"></a>解决IE下导出图片文件报错</h4>经过进一步分析得知，在上面第一步中获取内联图片的dataURL时在IE下会报错，那么解决办法是增加是否获取uri的参数，并作如下判断，如果需要获取uri参数（IE下不获取，也就是有设置canvg参数选项），才调用toDataURL方法。</li></ol><h3 id="解决导出图片无背景问题"><a href="#解决导出图片无背景问题" class="headerlink" title="解决导出图片无背景问题"></a>解决导出图片无背景问题</h3><p>经过以上的处理，在IE下可以正常导出图片，但是导出的png没有背景颜色（呈黑色背景）。经过查询资料发现：利用canvas的toDataURL创建图像，如果图像类型支持透明（比如PNG），那么背景颜色则会是透明，否则是黑色。w3c的说明参考<a href="https://www.w3.org/TR/2010/WD-html5-20100624/the-canvas-element.html" target="_blank" rel="noopener">这里</a><br>在上面第三步返回dataURL的时候，我们判断如果没有传入canvg参数，正常调用canvas的toDataURL方法，否则我们这样处理：</p><ol><li>从canvas中得到ImageData</li><li>将<code>globalCompositeOperation</code>属性设置为<code>destination-over</code>. 这将会在当前存在的图形之下绘制新的图形</li><li>画一个整个canvas大小的rectangle，填充你想要的背景色</li><li>生成canvas的dataURL</li><li>清空整个canvas（包含背景）</li><li>拷贝原来的绘图数据到canvas</li><li>重置<code>globalCompositeOperation</code>为你开始想要的值</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上我们介绍了如何增加垫片使得ES6的API能在IE下兼容运行，以及修改saveSVGAsPng的源码来使得IE下能正常将svg元素导出为png图片。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>图说D3数据可视化利器从入门到进阶</li><li><a href="https://blog.csdn.net/w13707470416/article/details/85017570" target="_blank" rel="noopener">Vue CLI 3 配置兼容IE10</a></li><li><a href="https://github.com/exupero/saveSvgAsPng" target="_blank" rel="noopener">saveSvgAsPng github</a></li><li><a href="https://github.com/canvg/canvg" target="_blank" rel="noopener">canvg github</a></li><li><a href="https://www.w3.org/TR/2010/WD-html5-20100624/the-canvas-element.html" target="_blank" rel="noopener">canvas w3c</a></li><li><a href="http://www.mikechambers.com/blog/2011/01/31/setting-the-background-color-when-generating-images-from-canvas-todataurl/" target="_blank" rel="noopener">Setting the background color when generating images from Canvas.toDataURL</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;本文的目的是介绍一种将Web中SVG元素导出成PNG图片的方法，并阐述如何通过修改插件源码做到兼容IE浏览器（IE10以及以上）。&lt;/p&gt;

      
    
    </summary>
    
      <category term="可视化" scheme="https://www.haoming.fun/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="源码分析" scheme="https://www.haoming.fun/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>记一次crontab执行scp异常解决</title>
    <link href="https://www.haoming.fun/2018/10/22/%E8%AE%B0%E4%B8%80%E6%AC%A1crontab%E6%89%A7%E8%A1%8Cscp%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3/"/>
    <id>https://www.haoming.fun/2018/10/22/记一次crontab执行scp异常解决/</id>
    <published>2018-10-22T07:57:00.000Z</published>
    <updated>2019-06-30T04:11:36.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python执行shell命令时的奇怪问题"><a href="#Python执行shell命令时的奇怪问题" class="headerlink" title="Python执行shell命令时的奇怪问题"></a>Python执行shell命令时的奇怪问题</h3><p>通过crontab命令，周期性执行Python脚本。简单来说，用Python脚本实现的是将一些指定目录下的文件scp到远程主机的某个目录下。奇怪的是，该scp命令在命令行中执行没问题，通过上述的方式执行就不能成功，日志记录的是“scp传输失败”</p><h3 id="问题具体一些"><a href="#问题具体一些" class="headerlink" title="问题具体一些"></a>问题具体一些</h3><p>我们通过crontab命令，可以在固定的间隔时间执行指定的系统指令或shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br>任务定义格式：<br>.—————- minute (0 - 59)<br>|  .————- hour (0 - 23)<br>|  |  .———- day of month (1 - 31)<br>|  |  |  .——- month (1 - 12) OR jan,feb,mar,apr …<br>|  |  |  |  .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat<br>|  |  |  |  |<br><code>*  *  *  *  * user-name  command to be executed</code>  </p><p>例如：每五分钟执行一次验证脚本<br><code>*/5 * * * * python /data/mgxy/scripts/verify.py MGSM ZL BLXY</code></p><p>crontab有个用户域，也就是说当前用户可以设置自己的crontab命令，设置成功可以通过<code>crontab -l</code>命令查看当前用户设置的任务，不能看到其他用户设置的任务。通过<code>crontab -e</code>命令来编辑当前用户的crontab，也就是在执行命令后的编辑器中输入上面的验证脚本，然后保存后会将编辑的crontab文件提交给cron进程执行。</p><p>“verify.py”中执行scp命令是采用免密方式，免密登录是通过sshpass来实现的，用-p参数指定明文密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshpass -p loginPassord scp -oUserKnownHostsFile=/dev/null -oStrictHostKeyChecking=no /sourcePath/sourceFile username@targetIp:/targetPath/</span><br></pre></td></tr></table></figure><p>每次ssh访问过的计算机公钥都会记录在<code>~/.ssh/known_hosts</code>，方便下次访问该计算机时核对。记得首次ssh登录一个主机的时候，命令行都会提示：“RSA key fingerprint is *****. Are you sure you want to continue connecting (yes/no)?”，如果回复yes,ssh客户端就会继续登录，将主机key存在文件<code>~/.ssh/known_hosts</code>中，如果回复no，连接就会中断。</p><p>scp 可以通过<code>-o</code>来指定ssh选项。<code>StrictHostKeyChecking=no</code>，该选项会禁用掉上面的交互提示，自动将主机key添加到文件<code>~/.ssh/known_hosts</code>中。如果我们确认远程主机密码更改时合法的，我们可以跳过主机密钥的校验，通过设置<code>UserKnownHostsFile=/dev/null</code>将密钥发送到一个null的known_hosts文件中。</p><h3 id="一些尝试"><a href="#一些尝试" class="headerlink" title="一些尝试"></a>一些尝试</h3><ul><li>将实际执行的命令，放到命令行中执行<br>结果：能够正常执行。<br>猜想：<ol><li>会不会命令行用户和执行脚本的用户不同导致？实际这两个都同一个用户。</li><li>会不会是Python脚本的问题？python脚本在另一台机器运行正常。</li></ol></li><li>不用crontab命令，将Python脚本在命令行执行<br>结果：脚本正常执行。说明是crontab执行任务的问题。<br>涛哥指导：crontab的用户比较特殊，尽可能使用绝对路径</li><li>crontab命令中将python改为绝对路径<br>结果：<code>*/5 * * * * /usr/bin/python xxx</code>问题依然存在<br>设想：会不会是python脚本中执行的scp命令也要换成绝对路径</li><li>将python中执行的命令换成绝对路径<br>结果：成功！能够正常拷贝文件。<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3>想想修改python中的命令为绝对路径，这不是通用办法。有没有通用点的办法，不用修改python脚本呢。然后我谷歌了一下，发现<code>/etc/contab</code>中可以设置环境变量，如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure></li></ul><p>很多命令就在以上的$PATH中啊。想想该怎么设置环境变量呢，在哪里设置呢？他们以前会不会也有这样的问题呢？是怎么解决的呢？所以我去线上环境<code>crontab -l</code>看了一下，发现类似的设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/10 * * * * . /etc/profile;/bin/sh xxx.sh</span><br></pre></td></tr></table></figure><p>然后百度了一下，有这么一段描述(来自<a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="noopener">博客</a>)：</p><blockquote><p>当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：<br><code>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</code></p></blockquote><p>最后，我在crontab命令按照以上配置（crontab命令设置绝对路径是好习惯）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * . /etc/profile;/usr/bin/python  xxx.py xxx</span><br></pre></td></tr></table></figure><p>并在/etc/profile中设置环境变量：<br><code>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$PATH</code><br>bingo, 成功！</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.cnblogs.com/chenlaichao/p/7727554.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenlaichao/p/7727554.html</a><br><a href="https://www.shellhacks.com/disable-ssh-host-key-checking/" target="_blank" rel="noopener">https://www.shellhacks.com/disable-ssh-host-key-checking/</a><br><a href="https://stackoverflow.com/questions/2388087/how-to-get-cron-to-call-in-the-correct-paths" target="_blank" rel="noopener">https://stackoverflow.com/questions/2388087/how-to-get-cron-to-call-in-the-correct-paths</a><br><a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="noopener">https://www.cnblogs.com/intval/p/5763929.html</a>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python执行shell命令时的奇怪问题&quot;&gt;&lt;a href=&quot;#Python执行shell命令时的奇怪问题&quot; class=&quot;headerlink&quot; title=&quot;Python执行shell命令时的奇怪问题&quot;&gt;&lt;/a&gt;Python执行shell命令时的奇怪问题&lt;/
      
    
    </summary>
    
      <category term="运维" scheme="https://www.haoming.fun/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="异常解决" scheme="https://www.haoming.fun/tags/%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hive2Hbase入库逻辑</title>
    <link href="https://www.haoming.fun/2018/09/19/Hive2Hbase%E5%85%A5%E5%BA%93%E9%80%BB%E8%BE%91/"/>
    <id>https://www.haoming.fun/2018/09/19/Hive2Hbase入库逻辑/</id>
    <published>2018-09-19T12:21:00.000Z</published>
    <updated>2019-06-30T04:11:36.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Parquet格式hdfs文件根据规则生成HFile"><a href="#Parquet格式hdfs文件根据规则生成HFile" class="headerlink" title="Parquet格式hdfs文件根据规则生成HFile"></a>Parquet格式hdfs文件根据规则生成HFile</h3><ol><li>创建和设置habse参数</li><li>清楚输出目录下HFile文件</li><li>创建mapreduce job</li><li>设置mapper：job.setJarByClass, job.setMapperClass, job.setMapOutputKeyClass, job.setMapOutputValueClass；</li><li>设置Parquet格式的解析器；</li><li>设置合并方法：job.setCombinerClass(Combiner.class)，Combiner继承自Reducer，reduce方法用于数据去重；</li><li>设置写HFile的reduce：HFileOutputFormat2.configureIncrementalLoad, HFileOutputFormat2.setOutputPath; job.setReducerClass(KeyValueSortReducer.class)：设置reducer class, 如KeyValue、Put、Text，以正确地对输入值进行排序。configureIncrementalLoad中会根据前面设置的MapOutputKeyClass来设置ReducerClass，见下面的源代码。</li><li>提交job，轮询等到其完成，退出程序执行。<br>第7步configureIncrementalLoad源代码：   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configureIncrementalLoad</span><span class="params">(Job job, HTableDescriptor tableDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RegionLocator regionLocator, Class&lt;? extends OutputFormat&lt;?, ?&gt;&gt; cls)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">        UnsupportedEncodingException </span>&#123;</span><br><span class="line">    Configuration conf = job.getConfiguration();</span><br><span class="line">    job.setOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">    job.setOutputValueClass(KeyValue.class);</span><br><span class="line">    job.setOutputFormatClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Based on the configured map output class, set the correct reducer to properly</span></span><br><span class="line">    <span class="comment">// sort the incoming values.</span></span><br><span class="line">    <span class="comment">// TODO it would be nice to pick one or the other of these formats.</span></span><br><span class="line">    <span class="keyword">if</span> (KeyValue.class.equals(job.getMapOutputValueClass())) &#123;</span><br><span class="line">        job.setReducerClass(KeyValueSortReducer.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Put.class.equals(job.getMapOutputValueClass())) &#123;</span><br><span class="line">        job.setReducerClass(PutSortReducer.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Text.class.equals(job.getMapOutputValueClass())) &#123;</span><br><span class="line">        job.setReducerClass(TextSortReducer.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Unknown map output value type:"</span> + job.getMapOutputValueClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conf.setStrings(<span class="string">"io.serializations"</span>, conf.get(<span class="string">"io.serializations"</span>),</span><br><span class="line">            MutationSerialization.class.getName(), ResultSerialization.class.getName(),</span><br><span class="line">            KeyValueSerialization.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use table's region boundaries for TOP split points.</span></span><br><span class="line">    LOG.info(<span class="string">"Looking up current regions for table "</span> + tableDescriptor.getTableName());</span><br><span class="line">    List&lt;ImmutableBytesWritable&gt; startKeys = getRegionStartKeys(regionLocator);</span><br><span class="line">    LOG.info(<span class="string">"Configuring "</span> + startKeys.size() + <span class="string">" reduce partitions "</span> +</span><br><span class="line">            <span class="string">"to match current region count"</span>);</span><br><span class="line">    job.setNumReduceTasks(startKeys.size());</span><br><span class="line"></span><br><span class="line">    configurePartitioner(job, startKeys);</span><br><span class="line">    <span class="comment">// Set compression algorithms based on column families</span></span><br><span class="line">    configureCompression(conf, tableDescriptor);</span><br><span class="line">    configureBloomType(tableDescriptor, conf);</span><br><span class="line">    configureBlockSize(tableDescriptor, conf);</span><br><span class="line">    configureDataBlockEncoding(tableDescriptor, conf);</span><br><span class="line"></span><br><span class="line">    TableMapReduceUtil.addDependencyJars(job);</span><br><span class="line">    TableMapReduceUtil.initCredentials(job);</span><br><span class="line">    LOG.info(<span class="string">"Incremental table "</span> + regionLocator.getName() + <span class="string">" output configured."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="加载HFile到HBase表"><a href="#加载HFile到HBase表" class="headerlink" title="加载HFile到HBase表"></a>加载HFile到HBase表</h3><ol><li>加载配置文件hbase-site.xml</li><li>读取hdfs配置文件hbase-hdfs-site.xml，然后配置hbase-site.xml的一些参数：<br>● 配置dfs.ha.namenodes.[nameservice ID]，让DataNode知道每个集群的所有NameNode<br>● 配置dfs.client.failover.proxy.provider.[nameservice    ID]，该参数定义HDFS客户端用来和活动的namenode节目联系的java类。配置的java类是用来给HDFS客户端判断哪个namenode节点是活动的，当前是哪个namenode处理客户端的请求。<br>● 配置dfs.namenode.rpc-address.[nameservice ID].[name node ID] ， 即配置每个namenode监听的RPC地址。<br>● 配置dfs.nameservices–自定义的HDFS服务名，在NameNode节点的集群中，对HDFS集群访问的入口是NameNode所在的服务器。但是在两个NameNode节点的HA集群中，无法配置单一服务器入口。所以需要指定一个逻辑上的服务名，这个服务名是自定义的。当外界访问HDFS集群时，入口就变为这个服务。用户不必关心当前具体是哪台服务器在提供服务（Active状态），只要访问这个服务就可以了。<br>● 配置mapreduce.job.hdfs-servers.token-renewal.exclude为名字服务id的数组，ResourceManager为应用程序更新委托令牌。只有当令牌的更新者是非空字符串时，此行为才被更新为令牌。MapReduce作业可以指示ResourceManager通过指定具有配置mapreduce.job.hdfs-servers.token-renewal.exclude = <host1>，<host2>，..，<hostn>的主机来跳过从某些主机获取的令牌的更新。   </hostn></host2></host1></li><li>向HBASE表加载数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableB);</span><br><span class="line">LoadIncrementalHFile loader = <span class="keyword">new</span> LoadIncrementalHFile(conf);</span><br><span class="line">loader.doBulkLoad(<span class="keyword">new</span> Path(outputPathOnHbase), table);  <span class="comment">// outputPathOnHbase是HBASE的hdfs上HFile的路径</span></span><br></pre></td></tr></table></figure></li></ol><p>API解释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class LoadIncrementalHFiles：Tool to load the output of HFileOutputFormat into an existing table.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBulkLoad</span><span class="params">(org.apache.hadoop.fs.Path hfofDir,</span></span></span><br><span class="line"><span class="function"><span class="params">              Admin admin,</span></span></span><br><span class="line"><span class="function"><span class="params">              Table table,</span></span></span><br><span class="line"><span class="function"><span class="params">              RegionLocator regionLocator)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> TableNotFoundException,</span></span><br><span class="line"><span class="function">                       IOException</span></span><br><span class="line"><span class="function">Perform a bulk load of the given directory into the given pre-existing table. This method is not threadsafe.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">hfofDir - the directory that was provided as the output path of a job using HFileOutputFormat</span></span><br><span class="line"><span class="function">table - the table to load into</span></span><br><span class="line"><span class="function">Throws:</span></span><br><span class="line"><span class="function">TableNotFoundException - <span class="keyword">if</span> table does not yet exist</span></span><br><span class="line"><span class="function">IOException</span></span><br></pre></td></tr></table></figure><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://blog.csdn.net/book_mmicky/article/details/25714339" target="_blank" rel="noopener">https://blog.csdn.net/book_mmicky/article/details/25714339</a><br><a href="https://segmentfault.com/a/1190000007239743" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007239743</a><br><a href="http://www.searchdoc.cn/hadoop/hadoop.apache.org/docs/r3.0.0-alpha1/hadoop-project-dist/hadoop-common/release/3.0.0-alpha1/RELEASENOTES.3.0.0-alpha1.com.coder114.cn.html" target="_blank" rel="noopener">http://www.searchdoc.cn/hadoop/hadoop.apache.org/docs/r3.0.0-alpha1/hadoop-project-dist/hadoop-common/release/3.0.0-alpha1/RELEASENOTES.3.0.0-alpha1.com.coder114.cn.html</a><br><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.apache.hadoop.hbase.mapreduce.KeyValueSortReducer" target="_blank" rel="noopener">https://www.programcreek.com/java-api-examples/index.php?api=org.apache.hadoop.hbase.mapreduce.KeyValueSortReducer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Parquet格式hdfs文件根据规则生成HFile&quot;&gt;&lt;a href=&quot;#Parquet格式hdfs文件根据规则生成HFile&quot; class=&quot;headerlink&quot; title=&quot;Parquet格式hdfs文件根据规则生成HFile&quot;&gt;&lt;/a&gt;Parquet格
      
    
    </summary>
    
      <category term="大数据" scheme="https://www.haoming.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="数据入库" scheme="https://www.haoming.fun/tags/%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93/"/>
    
      <category term="Hbase" scheme="https://www.haoming.fun/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019技术书单</title>
    <link href="https://www.haoming.fun/2018/09/18/2018-2019%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95/"/>
    <id>https://www.haoming.fun/2018/09/18/2018-2019技术书单/</id>
    <published>2018-09-18T12:42:00.000Z</published>
    <updated>2019-06-30T04:11:36.654Z</updated>
    
    <content type="html"><![CDATA[<p>2018到2019书单<br>       —— 计算机系统化学习，大神进化之路   </p><h5 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h5><p>具体数学<br>图论及其应用<br>矩阵理论<br>线性代数与空间解析几何<br>最优化理论与方法<br>组合数学<br>深入浅出统计学  </p><h5 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h5><p>统计学习方法<br>机器学习(西瓜书)<br>机器学习(经典)  </p><h5 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h5><p>Hadoop权威指南   </p><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><p>css世界<br>Java核心技术(卷一)<br>深入理解Java虚拟机<br>webkit技术内幕<br>高性能JavaScript  </p><h4 id="数据结构及算法"><a href="#数据结构及算法" class="headerlink" title="数据结构及算法"></a>数据结构及算法</h4><p>算法导论<br>算法：C语言实现<br>算法心得<br>数据结构与算法分析——C语言描述  </p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>TCP/IP详解<br>计算机网络自顶向下方法  </p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>深入理解计算机系统<br>Linux内核设计与实现(第三版)<br>Linux程序设计实践<br>Unix操作系统设计<br>老码识途  </p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库系统概论<br>MySQL DBA修炼之道<br>高性能MySQL  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018到2019书单&lt;br&gt;       —— 计算机系统化学习，大神进化之路   &lt;/p&gt;
&lt;h5 id=&quot;数学&quot;&gt;&lt;a href=&quot;#数学&quot; class=&quot;headerlink&quot; title=&quot;数学&quot;&gt;&lt;/a&gt;数学&lt;/h5&gt;&lt;p&gt;具体数学&lt;br&gt;图论及其应用&lt;br&gt;矩
      
    
    </summary>
    
      <category term="基础科学" scheme="https://www.haoming.fun/categories/%E5%9F%BA%E7%A1%80%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="书单" scheme="https://www.haoming.fun/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
</feed>
